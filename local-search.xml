<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>LaTex 系列 - 5. `amsthm` 定理环境编号</title>
    <link href="/2025/11/20/code/Latex/latex_5-thm_number-2025-11-20/"/>
    <url>/2025/11/20/code/Latex/latex_5-thm_number-2025-11-20/</url>
    
    <content type="html"><![CDATA[<h2 id="美国数学学会-ams-提供的-定理类环境-latex-宏包-amsthm">1. 美国数学学会 AMS 提供的 “定理类环境” LaTeX 宏包 – <code>amsthm</code></h2><p><code>amsthm</code> 是 美国数学学会 <code>AMS</code> 提供的 <code>LaTeX</code> 宏包，专门用来处理：</p><ul><li><p>定理 / 引理 / 命题 / 推论等 “定理类环境” 的定义和编号</p></li><li><p>proof（证明环境）的排版</p></li><li><p>不同风格的定理格式（斜体/正常体/备注型）</p></li><li><p>可以理解成：“让定理环境更好用、更好看”的官方标准包。</p></li></ul><h2 id="定理环境的编号">2. 定理环境的编号</h2><h3 id="case-1">2.1 case 1</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\usepackage</span>&#123;amsthm&#125;<br><span class="hljs-keyword">\newtheorem</span>&#123;thm&#125;&#123;定理&#125;[section]  <span class="hljs-comment">% [section]：随 section 重置</span><br>                                 <span class="hljs-comment">% &#123;定理&#125;：&quot;定理 3.1&quot;</span><br>                                 <span class="hljs-comment">% &#123;thm&#125;：\begin&#123;thm&#125;...\end&#123;thm&#125;</span><br></code></pre></td></tr></table></figure><h3 id="case-2">2.2 case 2</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\usepackage</span>&#123;amsthm&#125;<br><span class="hljs-keyword">\newtheorem</span>&#123;thm&#125;&#123;定理&#125;  <span class="hljs-comment">% &#123;thm&#125;：\begin&#123;thm&#125;...\end&#123;thm&#125;</span><br>                        <span class="hljs-comment">% &#123;定理&#125;：&quot;定理 1&quot;</span><br>                        <span class="hljs-comment">% 定理号不随 section 重置</span><br></code></pre></td></tr></table></figure><h3 id="case-3">2.3 case 3</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\usepackage</span>&#123;amsthm&#125;<br><span class="hljs-keyword">\newtheorem</span>&#123;thm&#125;&#123;定理&#125;       <span class="hljs-comment">% &#123;thm&#125;：\begin&#123;thm&#125;...\end&#123;thm&#125;</span><br>                             <span class="hljs-comment">% &#123;定理&#125;：&quot;定理 1&quot;</span><br><span class="hljs-keyword">\numberwithin</span>&#123;thm&#125;&#123;section&#125;  <span class="hljs-comment">% 定理号随 section 重置</span><br></code></pre></td></tr></table></figure><h3 id="case-4">2.4 case 4</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\usepackage</span>&#123;amsthm&#125;<br><span class="hljs-keyword">\newtheorem</span>&#123;thm&#125;&#123;定理&#125;<br><span class="hljs-keyword">\newtheorem</span>&#123;lem&#125;[thm]&#123;引理&#125;<br></code></pre></td></tr></table></figure><p>文中顺序是： <figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\begin</span>&#123;thm&#125; ... <span class="hljs-keyword">\end</span>&#123;thm&#125;<br><span class="hljs-keyword">\begin</span>&#123;lem&#125; ... <span class="hljs-keyword">\end</span>&#123;lem&#125;<br><span class="hljs-keyword">\begin</span>&#123;thm&#125; ... <span class="hljs-keyword">\end</span>&#123;thm&#125;<br><span class="hljs-keyword">\begin</span>&#123;lem&#125; ... <span class="hljs-keyword">\end</span>&#123;lem&#125;<br></code></pre></td></tr></table></figure> 编号会是： <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">定理 1<br>引理 2<br>定理 3<br>引理 4<br></code></pre></td></tr></table></figure></p><h3 id="case-5">2.5 case 5</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\newtheorem</span>&#123;thm&#125;&#123;定理&#125;[section]   <span class="hljs-comment">% 或者 \numberwithin&#123;thm&#125;&#123;section&#125;</span><br><span class="hljs-keyword">\newtheorem</span>&#123;lem&#125;[thm]&#123;引理&#125;<br></code></pre></td></tr></table></figure><p><code>Section 3</code> 中顺序是： <figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\begin</span>&#123;thm&#125; ... <span class="hljs-keyword">\end</span>&#123;thm&#125;<br><span class="hljs-keyword">\begin</span>&#123;lem&#125; ... <span class="hljs-keyword">\end</span>&#123;lem&#125;<br><span class="hljs-keyword">\begin</span>&#123;thm&#125; ... <span class="hljs-keyword">\end</span>&#123;thm&#125;<br><span class="hljs-keyword">\begin</span>&#123;lem&#125; ... <span class="hljs-keyword">\end</span>&#123;lem&#125;<br></code></pre></td></tr></table></figure> 编号会是： <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">定理 3.1<br>引理 3.2<br>定理 3.3<br>引理 3.4<br></code></pre></td></tr></table></figure></p><h3 id="case-6-希望它们各自从-1-开始">2.6 case 6 希望它们“各自”从 1 开始</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\newtheorem</span>&#123;thm&#125;&#123;定理&#125;   <span class="hljs-comment">% 定理 1, 2, 3, ...</span><br><span class="hljs-keyword">\newtheorem</span>&#123;lem&#125;&#123;引理&#125;   <span class="hljs-comment">% 引理 1, 2, 3, ...</span><br></code></pre></td></tr></table></figure><p>文中： <figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\begin</span>&#123;thm&#125; ... <span class="hljs-keyword">\end</span>&#123;thm&#125;    <span class="hljs-comment">% 定理 1</span><br><span class="hljs-keyword">\begin</span>&#123;lem&#125;  ... <span class="hljs-keyword">\end</span>&#123;lem&#125;   <span class="hljs-comment">% 引理 1</span><br><span class="hljs-keyword">\begin</span>&#123;thm&#125; ... <span class="hljs-keyword">\end</span>&#123;thm&#125;    <span class="hljs-comment">% 定理 2</span><br><span class="hljs-keyword">\begin</span>&#123;lem&#125;  ... <span class="hljs-keyword">\end</span>&#123;lem&#125;   <span class="hljs-comment">% 引理 2</span><br></code></pre></td></tr></table></figure> 编号会是： <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">定理 1<br>引理 1<br>定理 2<br>引理 2<br></code></pre></td></tr></table></figure></p><h3 id="case-7-按章节重置且各自从-1-开始">2.7 case 7 按章节重置且各自从 1 开始</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\newtheorem</span>&#123;thm&#125;&#123;定理&#125;[section]   <span class="hljs-comment">% 定理 3.1, 3.2, 4.1, ...</span><br><span class="hljs-keyword">\newtheorem</span>&#123;lem&#125;&#123;引理&#125;[section]   <span class="hljs-comment">% 引理 3.1, 3.2, 4.1, ...</span><br></code></pre></td></tr></table></figure><h2 id="证明-proof-环境">3. 证明 proof 环境</h2><p>写证明时不用自己手敲 “证明.”，“□” 等： <figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\begin</span>&#123;proof&#125;<br>这是证明内容……<br><span class="hljs-keyword">\end</span>&#123;proof&#125;<br></code></pre></td></tr></table></figure> 会自动排成类似： <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">证明. 这是证明内容…… □<br></code></pre></td></tr></table></figure></p><p>你也可以改成英文 “Proof.”，或者自定义名字： <figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\begin</span>&#123;proof&#125;[定理3的证明]<br>这是证明内容…… □<br><span class="hljs-keyword">\end</span>&#123;proof&#125;<br><span class="hljs-keyword">\begin</span>&#123;proof&#125;[解]<br>这是求解过程…… □<br><span class="hljs-keyword">\end</span>&#123;proof&#125;<br></code></pre></td></tr></table></figure> 会自动排成类似： <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">定理3的证明. 这是证明内容…… □<br>解. 这是求解过程…… □<br></code></pre></td></tr></table></figure></p><h2 id="修改定理风格">4. 修改定理风格</h2><p>三种常见风格： <figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\theoremstyle</span>&#123;plain&#125;       <span class="hljs-comment">% 粗体标题 + 斜体正文（默认，适合 Theorem/Lemma）</span><br><span class="hljs-keyword">\newtheorem</span>&#123;thm&#125;&#123;定理&#125;<br><br><span class="hljs-keyword">\theoremstyle</span>&#123;definition&#125;  <span class="hljs-comment">% 粗体标题 + 正文字体（适合 Definition）</span><br><span class="hljs-keyword">\newtheorem</span>&#123;defn&#125;&#123;定义&#125;<br><br><span class="hljs-keyword">\theoremstyle</span>&#123;remark&#125;      <span class="hljs-comment">% 斜体标题 + 正文字体（适合 Remark/Note）</span><br><span class="hljs-keyword">\newtheorem</span>&#123;rem&#125;&#123;注&#125;<br></code></pre></td></tr></table></figure></p><p>这样可以轻松实现“定理是斜体、定义是正体、备注是小字”的常见数学排版规范。</p><h2 id="拓展">5. 拓展</h2><h3 id="amsthm-和-普通-latex-有什么关系">5.1 <code>amsthm</code> 和 <code>普通 LaTeX</code> 有什么关系？</h3><p><code>LaTeX</code> 本身也有一个 <code>\newtheorem</code>，但功能比较简单。</p><p>amsthm 在此基础上扩展了：</p><ul><li><p>多种 \theoremstyle</p></li><li><p>更灵活的编号方式</p></li><li><p>标准的 proof 环境</p></li></ul><p>绝大多数数学论文/讲义都默认加载 amsthm（或者基于它的更高级包）。</p><h3 id="数学定理环境包汇总">5.2 数学定理环境包汇总</h3><p>功能类似包</p><ul><li><p><code>amsthm</code>：<code>AMS</code> 官方，简洁、稳定、最常用；大部分期刊模板都会直接用它。</p></li><li><p><code>ntheorem</code>：功能更强，能统一定理/证明/脚注等样式，但略复杂，有时和其他宏包冲突。</p></li><li><p><code>thmtools</code>：在 <code>amsthm</code> 上再封一层，提供更高级的接口（自动列表、<code>reference name</code> 等）。</p></li></ul><p>如果只是正常写数学讲义 / 论文，直接用 <code>amsthm</code> 就足够了。</p>]]></content>
    
    
    <categories>
      
      <category>code</category>
      
      <category>LaTex</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LaTex</tag>
      
      <tag>amsthm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pandoc系列 - 2. tex → docx 常见问题与解决方案</title>
    <link href="/2025/11/19/software/Pandoc/Pandoc_2/"/>
    <url>/2025/11/19/software/Pandoc/Pandoc_2/</url>
    
    <content type="html"><![CDATA[<p>在处理 tex 文件转换为 docx 文件时，可能会遇到一些问题。</p><p>下面是对于一些情况的讨论以及解决方案。</p><h2 id="文献问题">1. 文献问题</h2><!-- info 可以换成：primarysuccesswarningdangerinfo --><h3 id="生成参考文献---citeproc-和---bibliography">1.1 生成参考文献 <code>--citeproc</code> 和 <code>--bibliography</code></h3><div class="note note-danger">            <p>【问题描述】<code>tex</code> 文件使用 <code>bibtex</code> 格式引用文献： <figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\bibliographystyle</span>&#123;plain&#125;  <span class="hljs-comment">% 参考文献格式</span><br><span class="hljs-keyword">\bibliography</span>&#123;bibfile&#125;     <span class="hljs-comment">% bib文件名</span><br></code></pre></td></tr></table></figure> 执行以下指令进行 <code>tex</code> → <code>docx</code> 转换： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pandoc -s input.tex -o output.docx<br></code></pre></td></tr></table></figure> 生成的 word 文档中，既没有参考文献列表，正文中的引用 <code>\cite{XXX}</code> 也没有显示</p>          </div><div class="note note-info">            <p>【解决方案】进行 <code>tex</code> → <code>docx</code> 转换时添加以下指令： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pandoc -s template.tex --citeproc --bibliography=template.bib -o template.docx<br></code></pre></td></tr></table></figure></p>          </div><p>说明：</p><ul><li><code>--citeproc</code>：让 Pandoc 内置的 “citation processor” 工作：<ul><li>识别文中的引用（比如 <span class="citation" data-cites="Smith2020">[@Smith2020]</span> 这种 pandoc-style 引用）</li><li>按照引用样式把它们排版成真正的引文格式</li><li>自动生成文末参考文献列表（bibliography）</li></ul></li><li><code>--bibliography=template.bib</code>：指定参考文献数据库文件。<ul><li>citeproc 会从这个 .bib 里按键值（key）查文献条目。</li><li>文献格式和引用格式还有问题，还需进一步调整</li></ul></li></ul><h3 id="调整文献格式---csl">1.2 调整文献格式 <code>--csl</code></h3><ul><li>不做任何设置的前提下，<code>Pandoc</code> 会使用默认的参考文献格式 <code>Chicago author-date</code>。如下图所示</li></ul><figure><img src="Pandoc_cite.png" alt="Chicago author-date 参考文献格式" /><figcaption aria-hidden="true">Chicago author-date 参考文献格式</figcaption></figure><ul><li>在使用 <code>Pandoc</code> 进行 <code>tex</code> → <code>docx</code> 转换时，可以任意指定 <code>docx</code> 的参考文献格式，并且 <strong><code>docx</code> 的参考文献格式不需要和 <code>tex</code> 中的参考文献格式相同</strong>。</li></ul><p>步骤如下</p><ul><li>去 Zotero Style Repository 下载一个数字型样式：在浏览器访问以下网址 <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">https://www.zotero.org/styles<br></code></pre></td></tr></table></figure> 搜索 numeric 或 ieee 或 7714 之类，点进去后点击 “Download Style”，保存为本地文件，这里我们将 7714 存为 china.csl。</li></ul><figure><img src="Pandoc_zotero.png" alt="zotero 下载 GB/T7714 样式" /><figcaption aria-hidden="true"><code>zotero</code> 下载 <code>GB/T7714</code> 样式</figcaption></figure><ul><li><p>在 <code>meta.yaml</code> 添加 <figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">bibliography:</span> template.bib<br><span class="hljs-symbol">csl:</span> numeric.csl     <span class="hljs-meta"># 或你下载的那个 csl 文件名</span><br></code></pre></td></tr></table></figure></p></li><li><p>执行以下指令进行 <code>tex</code> → <code>docx</code> 转换： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pandoc -s template.tex --citeproc --metadata-file=meta.yaml -o template.docx<br></code></pre></td></tr></table></figure> 注意，这里指令不再需要</p><ul><li><code>--bibliography=template.bib</code></li><li><code>--csl=china.csl</code></li></ul><p>因为已经在 <code>meta.yaml</code> 中指定了。最后参考文献列表和文章中 <code>\cite</code> 引用效果如下</p></li></ul><p><img src="Pandoc_cite_good_1.png" alt="docx 中 GB/T7714 样式的参考文献" /> <img src="Pandoc_cite_good_2.png" alt="docx 中 \cite 引用样式" /></p><h2 id="字体问题">2. 字体问题</h2><p>数学字体</p><ul><li>❌：<span class="math inline">\({\rm d}\)</span> <code>$&#123;\rm d&#125;$</code> 无法处理，Pandoc 会报错</li><li>✅：<span class="math inline">\(\mathrm{d}\)</span> <code>$\mathrm&#123;d&#125;$</code> 可以处理，Pandoc 不报错</li></ul><p>latex 公式</p><ul><li>❌：<span class="math inline">\(\mathop {\lim }\limits_{t \to \infty } \dot V(e,\tilde \theta )\)</span> （<code>$\mathop &#123;\lim &#125;\limits_&#123;t \to \infty &#125; \dot V(e,\tilde \theta )$</code>）</li><li>✅：<span class="math inline">\(\lim_{t\to\infty} \dot V(e,\tilde\theta)\)</span> （<code>$\lim_&#123;t\to\infty&#125; \dot V(e,\tilde\theta)$</code>）</li></ul><h2 id="公式问题">3. 公式问题</h2><h3 id="安装-pandoc-tex-numbering-滤波器">3.1 安装 <code>pandoc-tex-numbering</code> 滤波器</h3><div class="note note-danger">            <p>【问题描述】章节、公式都没有编号</p><ul><li><code>\section{XXX}</code> 和 <code>\subsection{XXX}</code> 等章节编号，在 <code>word</code> 中不显示</li><li><code>eqnarray</code> 环境中的公式没有自动编号</li></ul>          </div><div class="note note-info">            <p>【解决方案】安装 <code>pandoc-tex-numbering</code> 滤波器</p><ol type="1"><li><p><code>conda</code> 创建 <code>python</code> 环境 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda create -n pandoc_py310 python=3.10<br></code></pre></td></tr></table></figure></p></li><li><p>激活环境 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda activate pandoc_py310<br></code></pre></td></tr></table></figure> 接下来的操作都在 <code>pandoc_py310</code> 环境下进行。</p></li><li><p><code>pip</code> 安装 <code>pandoc-tex-numbering</code> 插件 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install pandoc-tex-numbering<br></code></pre></td></tr></table></figure></p></li><li><p>进行 <code>tex</code> → <code>docx</code> 转换时使用以下指令： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pandoc template.tex --citeproc --bibliography=template.bib -F pandoc-tex-numbering -o tempalte.docx<br></code></pre></td></tr></table></figure></p></li></ol>          </div><p>说明：</p><ul><li>只改命令行参数是解决不了“自动编号”的问题的</li><li>必须加一个专门的 pandoc 过滤器，在 LaTeX→Word 的转换过程中，把 eqnarray 等环境里的编号“补”出来。</li><li><code>pandoc-tex-numbering</code>：这个过滤器就是处理从 LaTeX 转成 docx 时【自动编号】的问题。</li><li><code>--filter</code> / <code>-F</code> (二者等价)：调用外部可执行程序作为过滤器（这里是 <code>pandoc-tex-numbering</code>，所以可以推测：<code>pip</code> 安装 <code>pandoc-tex-numbering</code> 插件后，提供了一个可执行程序）</li></ul><h3 id="eqnarray-环境慎用这里只是讲解-pandoc-转换-tex-文件时与-eqnarray-环境不兼容的解决方案eqnarray-与-pandoc-结合会有很多问题本节方案只能解决一部分问题不能都完美解决完美方案可以直接阅读-3.2.5-节">3.2 <code>eqnarray</code> 环境慎用（这里只是讲解 <code>Pandoc</code> 转换 tex 文件时与 <code>eqnarray</code> 环境不兼容的解决方案，<code>eqnarray</code> 与 <code>Pandoc</code> 结合会有很多问题，本节方案只能解决一部分问题，不能都完美解决，完美方案可以直接阅读 3.2.5 节）</h3><h3 id="eqnarray-环境中-nonumber-失效">3.2.1 <code>eqnarray</code> 环境中 <code>\nonumber</code> 失效</h3><div class="note note-danger">            <p>【问题描述】<code>Pandoc</code> 进行 <code>tex</code> → <code>docx</code> 转换时，直接使用<code>eqnarray</code> 环境主要有两个问题：</p><ul><li><code>Pandoc</code> 会将 <code>eqnarray</code> 环境中的公式整块处理，不能实现在最后一行添加自动编号</li><li><code>eqnarray</code> 环境中的 <code>\nonumber</code> 指令在 <code>Pandoc</code> 中失效</li></ul>          </div><p>具体见下图 <img src="Pandoc_2-2.png" alt="eqnarray 环境中 \nonumber 指令不能正常工作" /></p><p>根本原因：</p><ul><li><code>pandoc-tex-numbering</code> 只在<code>multiline-environments</code> 环境，才会识别 <code>\nonumber</code>。</li><li><code>multiline-environments</code> 环境包括<ul><li>cases</li><li>align</li><li>aligned</li><li>gather</li><li>gathered</li><li>multline</li><li>flalign</li></ul></li><li><mark>注意：<code>multiline-environments</code> 环境不包括 <code>eqnarray</code> 环境</mark>。</li></ul><div class="note note-info">            <p>【解决方案1】（<strong>☆推荐这种方案</strong>） Latex中 <code>eqnarray</code> 环境都替换为 <code>align</code> 环境，这样 <code>\nonumber</code> 指令才可以正常工作</p>          </div><div class="note note-info">            <p>【解决方案2】 把 <code>eqnarray</code> 环境加入 <code>multiline-environments</code>，具体操作有两种途径（以下方案二选一即可）</p><ul><li><p>直接命令行添加 <code>-M</code> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">pandoc template.tex \<br>--citeproc --bibliography=template.bib \<br>-F pandoc-tex-numbering \<br>-M multiline-environments=<span class="hljs-string">&quot;cases,align,aligned,gather,gathered,multline,flalign,eqnarray&quot;</span> \<br>-o template.docx<br></code></pre></td></tr></table></figure></p></li><li><p>用 meta.yaml：<code>tex</code> 文件同目录新建一个 <code>meta.yaml</code>： <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">multiline-environments:</span> <span class="hljs-string">&quot;cases,align,aligned,gather,gathered,multline,flalign,eqnarray&quot;</span><br></code></pre></td></tr></table></figure> 然后执行以下指令进行转换： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">pandoc template.tex \<br>--citeproc --bibliography=template.bib \<br>-F pandoc-tex-numbering \<br>--metadata-file=meta.yaml \<br>-o template.docx<br></code></pre></td></tr></table></figure></p></li></ul>          </div><ul><li><p>配置好以后，<code>eqnarray</code> 就会像 <code>align</code> 一样按行处理，这一行末尾有 <code>\nonumber</code> 就不会编号。</p></li><li><p>如果想整个 <code>eqnarray</code> 都不要编号，那就给每一行都加上 <code>\nonumber</code>（包括最后一行）。</p></li><li><p>如果只想让中间几步不编号，就只在这些行后面写 <code>\nonumber</code></p></li><li><p>进行上述操作后，<code>eqnarray</code> 环境中 <code>\nonumber</code> 指令就可以正常工作了，见下图。</p></li></ul><figure><img src="Pandoc_2-3.png" alt="eqnarray 环境中 \nonumber 指令正常工作" /><figcaption aria-hidden="true">eqnarray 环境中 <code>\nonumber</code> 指令正常工作</figcaption></figure><h3 id="行间公式环境默认强制编号">3.2.2 行间公式环境：默认强制编号</h3><p>这里行间公式环境指的是 <code>$$...$$</code> 和 <code>\[...\]</code></p><ul><li>Pandoc 就是会为 <code>$$...$$</code> 和 <code>\[...\]</code> 这些环境中的公式添加编号。</li><li>Pandoc 没有办法彻底取消 <code>$$...$$</code> 和 <code>\[...\]</code> 这些环境中的编号</li></ul><div class="note note-info">            <p>【解决方案】</p><ul><li><p>Latex中 <code>$$...$$</code> 和 <code>\[...\]</code> 环境都替换为 <code>align</code> 环境（或者 <code>eqnarray</code> 环境，但是需要进行 3.3 节中的【解决方案2】操作）</p></li><li><p>然后添加 <code>\nonumber</code> 指令，即可取消编号。</p></li></ul>          </div><h3 id="pandoc-进行-tex-docx-转换时支持用户自定义指令前提是用户自定义指令需要合法">3.2.3 <code>Pandoc</code> 进行 <code>tex</code> → <code>docx</code> 转换时，支持用户自定义指令，前提是用户自定义指令需要合法</h3><p>下面这种自定义指令是可以的 <figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\newcommand</span>&#123;<span class="hljs-keyword">\rmd</span>&#125;&#123;&#123;<span class="hljs-keyword">\mathrm</span>&#123;d&#125;&#125;&#125;<br></code></pre></td></tr></table></figure> 下面这种自定义指令不可以（不可以的原因是因为<code>\rm</code>而不是因为自定义） <figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\newcommand</span>&#123;<span class="hljs-keyword">\rmd</span>&#125;&#123;&#123;<span class="hljs-keyword">\rm</span>&#123;d&#125;&#125;&#125;<br></code></pre></td></tr></table></figure></p><h3 id="公式编号含有章节编号">3.2.4 公式编号含有章节编号</h3><div class="note note-danger">            <p>【问题描述】<code>pandoc-tex-numbering</code> 可以为章节和公式添加编号，但是公式编号包含章节编号，但是我们希望全文公式统一编号，不附带章节信息</p>          </div><p>上述问题具体见下图 <img src="Pandoc_2-1.png" alt="公式编号含有章节编号" /></p><div class="note note-info">            <p>【解决方案】</p><ul><li><p><code>pandoc-tex-numbering</code> 里有个总的参数 <code>number-reset-level</code>，意思是 <code>在哪一级 section 时把计数器归零</code>：</p></li><li><p>默认 <code>number-reset-level: 1</code>：在每个一级标题（section/chapter）处重置，所以会得到 (6.1)、(6.2) 这种风格；</p></li><li><p>如果想“永远不重置”，可以设成 <code>0</code> 或一个非常大的数。</p></li><li><p>具体操作：新建一个 meta.yaml，内容如下 <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">number-reset-level:</span> <span class="hljs-number">0</span>        <span class="hljs-comment"># 不随 section 重置</span><br><span class="hljs-attr">equation-src-format:</span> <span class="hljs-string">&quot;\\qquad(&#123;this_num&#125;)&quot;</span><br><span class="hljs-attr">equation-ref-format:</span> <span class="hljs-string">&quot;&#123;this_num&#125;&quot;</span><br><span class="hljs-attr">equation-cref-format:</span> <span class="hljs-string">&quot;(&#123;this_num&#125;)&quot;</span><br></code></pre></td></tr></table></figure> 然后命令行： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">pandoc template.tex \<br>--citeproc --bibliography=template.bib \<br>-F pandoc-tex-numbering \<br>--metadata-file=meta.yaml \<br>-o template.docx<br></code></pre></td></tr></table></figure></p></li></ul>          </div><p>上述方案效果如下 <img src="Pandoc_2-4.png" alt="公式编号不包含章节编号" /></p><h3 id="公式引用问题最好还是禁用-eqnarray">3.2.5 公式引用问题：最好还是禁用 eqnarray</h3><div class="note note-danger">            <p>【问题描述】<code>eqnarray</code> 环境经过前面的方案，可以解决一些问题，但在引用上还是会有很多奇怪的问题。比如</p><ul><li><code>eqnarray</code> 环境添加 <code>\label</code> 后，其他位置引用公式时用 <code>\eqref</code> 指令，虽然引用标号可以正确显示，但是引用不会自动添加括号</li><li>多个 <code>\eqref</code> 公式引用只能保证最后一个有显示，前面的 <code>\eqref</code> 都没有显示</li></ul>          </div><div class="note note-info">            <p>【解决方案】</p><ul><li><p>彻底禁用 <code>eqnarray</code> 环境</p><ul><li>彻底放弃 <code>eqnarray</code>，只用 <code>amsmath</code> 的 <code>equation</code> / <code>align</code> / <code>split</code> / <code>aligned</code> 环境</li><li>多行只打一 个编号：用 <code>equation</code> + (<code>split</code> / <code>aligned</code>) 套娃写法 （<code>equation</code> 在外层） <figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\begin</span>&#123;equation&#125;<br><span class="hljs-keyword">\begin</span>&#123;aligned&#125;<br>    f(x) <span class="hljs-built_in">&amp;</span>= x<span class="hljs-built_in">^</span>2 + 2x + 1 <span class="hljs-keyword">\\</span><br>    g(x) <span class="hljs-built_in">&amp;</span>= <span class="hljs-keyword">\sin</span>(x)<br><span class="hljs-keyword">\end</span>&#123;aligned&#125;<br><span class="hljs-keyword">\label</span>&#123;eq:quadratic&#125;<br><span class="hljs-keyword">\end</span>&#123;equation&#125;<br><br><span class="hljs-keyword">\begin</span>&#123;align&#125;<br>a <span class="hljs-built_in">&amp;</span>= b + c <span class="hljs-keyword">\label</span>&#123;eq:align1&#125; <span class="hljs-keyword">\\</span><br>d <span class="hljs-built_in">&amp;</span>= e - f <span class="hljs-keyword">\label</span>&#123;eq:align2&#125; <span class="hljs-keyword">\\</span><br>g <span class="hljs-built_in">&amp;</span>= h <span class="hljs-keyword">\nonumber</span> <span class="hljs-keyword">\\</span><br>i <span class="hljs-built_in">&amp;</span>= j + k <span class="hljs-keyword">\label</span>&#123;eq:align3&#125;<br><span class="hljs-keyword">\end</span>&#123;align&#125;<br></code></pre></td></tr></table></figure></li><li>不想编号的多行：老老实实在每行加 <code>\nonumber</code></li><li>用 <code>\label</code> + <code>\eqref</code>，括号交给 <code>pandoc-tex-numbering</code> 的 <code>metadata</code> 控制</li></ul></li><li><p>创建 <code>meta.yaml</code> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Pandoc-TeX-Numbering 过滤器设置</span><br><span class="hljs-attr">number-reset-level:</span> <span class="hljs-number">1</span>           <span class="hljs-comment"># 编号随 section 重置，不重置设为 0</span><br><br><span class="hljs-comment"># 公式编号设置</span><br><span class="hljs-attr">number-equations:</span> <span class="hljs-literal">true</span>          <span class="hljs-comment"># 让过滤器接管所有公式编号</span><br><span class="hljs-attr">equation-src-format:</span> <span class="hljs-string">&quot;\\qquad(&#123;num&#125;)&quot;</span>   <span class="hljs-comment"># 公式右侧显示：(1)</span><br><span class="hljs-attr">equation-ref-format:</span> <span class="hljs-string">&quot;(&#123;num&#125;)&quot;</span>          <span class="hljs-comment"># \ref / \eqref 显示：(1)</span><br><span class="hljs-attr">equation-cref-format:</span> <span class="hljs-string">&quot;(&#123;num&#125;)&quot;</span>         <span class="hljs-comment"># 若将来用 \cref 也是加括号</span><br></code></pre></td></tr></table></figure></p></li><li><p>执行 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">pandoc template.tex \<br>--citeproc --bibliography=template.bib \<br>-F pandoc-tex-numbering \<br>--metadata-file=meta.yaml \<br>-o template.docx<br></code></pre></td></tr></table></figure></p></li></ul>          </div><h2 id="交叉引用编号问题">4. 交叉引用编号问题</h2><h3 id="公式引用">4.1 公式引用</h3><p>以 “公式 (3.1)” 为例：</p><ul><li>{num} = 完整编号串：“3.1”</li><li>{this_num} = 当前层的编号：“1”</li><li>{parent_num} = 上一层编号（就是章节号）：“3”</li></ul><p>所以：</p><ul><li>要 3.1 这种编号 → 用 <code>number-reset-level: 1</code> 控制，按 section 重置</li><li>想在 中只要 “3.1” → {num}；</li><li>“{prefix}{num}” → “3.1” （默认 “.” 连接）</li><li>“{prefix}-{num}” → “3-1”</li></ul><h3 id="定理引用">4.2 定理引用</h3><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\usepackage</span>&#123;amsthm&#125;<br><span class="hljs-keyword">\newtheorem</span>&#123;thm&#125;&#123;定理&#125;<br><span class="hljs-keyword">\newtheorem</span>&#123;lem&#125;[thm]&#123;引理&#125;<br><span class="hljs-keyword">\numberwithin</span>&#123;thm&#125;&#123;section&#125; <span class="hljs-comment">% thm 计数器随\section重置</span><br></code></pre></td></tr></table></figure><p>创建 <code>meta.yaml</code> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 定理编号设置</span><br><span class="hljs-attr">number-theorems:</span> <span class="hljs-literal">true</span>       <span class="hljs-comment"># 让过滤器接管所有定理编号</span><br><span class="hljs-attr">prefix-space:</span> <span class="hljs-literal">true</span>          <span class="hljs-comment"># “定理 3.1”中“定理”和“3.1”之间空格  </span><br><span class="hljs-attr">theorem-names:</span> <span class="hljs-string">&quot;thm,lem&quot;</span>    <span class="hljs-comment"># 告诉过滤器：有 \begin&#123;thm&#125; 和 \begin&#123;lem&#125; 环境</span><br><span class="hljs-attr">theorem-thm-prefix:</span> <span class="hljs-string">&quot;定理&quot;</span>  <span class="hljs-comment"># 前缀文字（引用时显示）</span><br><span class="hljs-attr">theorem-lem-prefix:</span> <span class="hljs-string">&quot;定理&quot;</span>  <span class="hljs-comment"># 前缀文字（引用时显示）</span><br><span class="hljs-attr">thm-thm-src-format:</span> <span class="hljs-string">&quot;定理 &#123;parent_num&#125;.&#123;this_num&#125;&quot;</span> <span class="hljs-comment"># 源位置的格式：“定理 3.1”  </span><br><span class="hljs-attr">thm-thm-ref-format:</span> <span class="hljs-string">&quot;&#123;num&#125;&quot;</span>         <span class="hljs-comment"># \ref&#123;thm:stab&#125; 的显示：“3.1”   </span><br></code></pre></td></tr></table></figure></p><p>然并卵</p><div class="note note-warning">            <p>【Pandoc的局限】</p><ul><li>定理编号和引用强制从 1 开始</li><li><code>{parent_num}.{this_num}</code> 对于定理环境失效</li></ul>          </div><h3 id="图片引用">4.3 图片引用</h3><p>创建 <code>meta.yaml</code> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 图片编号设置</span><br><span class="hljs-attr">number-figures:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">figure-prefix:</span> <span class="hljs-string">&quot;图&quot;</span><br><span class="hljs-attr">fig-src-format:</span> <span class="hljs-string">&quot;&#123;prefix&#125;&#123;parent_num&#125;-&#123;this_num&#125;&quot;</span>   <span class="hljs-comment"># “图 3-1”</span><br><span class="hljs-attr">fig-cref-format:</span> <span class="hljs-string">&quot;&#123;prefix&#125;&#123;parent_num&#125;-&#123;this_num&#125;&quot;</span>  <span class="hljs-comment"># \cref 同样样式</span><br><span class="hljs-attr">fig-ref-format:</span> <span class="hljs-string">&quot;&#123;parent_num&#125;-&#123;this_num&#125;&quot;</span>           <span class="hljs-comment"># \ref 只要数字</span><br></code></pre></td></tr></table></figure> 执行 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">pandoc template.tex \<br>--citeproc --bibliography=template.bib \<br>-F pandoc-tex-numbering \<br>--metadata-file=meta.yaml \<br>-o template.docx<br></code></pre></td></tr></table></figure></p><h3 id="表格引用">4.4 表格引用</h3><p>Latex 中表格建议这样写（因为下面方式与Pandoc兼容） <figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\begin</span>&#123;table&#125;[htbp]<br><span class="hljs-keyword">\centering</span><br><span class="hljs-keyword">\caption</span>&#123;控制器参数整定结果&#125;<br><span class="hljs-keyword">\label</span>&#123;tab:ctrl-params&#125;<br><span class="hljs-keyword">\begin</span>&#123;tabular&#125;&#123;ccc&#125;<br><span class="hljs-keyword">\hline</span><br>参数 <span class="hljs-built_in">&amp;</span> 数值 <span class="hljs-built_in">&amp;</span> 说明 <span class="hljs-keyword">\\</span><br><span class="hljs-keyword">\hline</span><br><span class="hljs-built_in">$</span>K<span class="hljs-built_in">_</span>p<span class="hljs-built_in">$</span> <span class="hljs-built_in">&amp;</span> 1.2 <span class="hljs-built_in">&amp;</span> 比例系数 <span class="hljs-keyword">\\</span><br><span class="hljs-built_in">$</span>K<span class="hljs-built_in">_</span>i<span class="hljs-built_in">$</span> <span class="hljs-built_in">&amp;</span> 0.5 <span class="hljs-built_in">&amp;</span> 积分系数 <span class="hljs-keyword">\\</span><br><span class="hljs-built_in">$</span>K<span class="hljs-built_in">_</span>d<span class="hljs-built_in">$</span> <span class="hljs-built_in">&amp;</span> 0.01 <span class="hljs-built_in">&amp;</span> 微分系数 <span class="hljs-keyword">\\</span><br><span class="hljs-keyword">\hline</span><br><span class="hljs-keyword">\end</span>&#123;tabular&#125;<br><span class="hljs-keyword">\end</span>&#123;table&#125;<br></code></pre></td></tr></table></figure></p><p>创建 <code>meta.yaml</code> <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 表格编号设置</span><br><span class="hljs-attr">number-tables:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">table-prefix:</span> <span class="hljs-string">&quot;表&quot;</span><br><span class="hljs-attr">table-src-format:</span> <span class="hljs-string">&quot;&#123;prefix&#125;&#123;num&#125;&quot;</span> <span class="hljs-comment"># 出现在 caption 里的格式：表3.1 控制器参数整定结果</span><br><span class="hljs-attr">table-ref-format:</span> <span class="hljs-string">&quot;&#123;num&#125;&quot;</span>         <span class="hljs-comment"># \ref&#123;tab:...&#125; 输出：3.1</span><br><span class="hljs-attr">table-cref-format:</span> <span class="hljs-string">&quot;&#123;prefix&#125;&#123;num&#125;&quot;</span> <span class="hljs-comment"># \cref&#123;tab:...&#125; 输出：表3.1</span><br></code></pre></td></tr></table></figure> 执行 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">pandoc template.tex \<br>--citeproc --bibliography=template.bib \<br>-F pandoc-tex-numbering \<br>--metadata-file=meta.yaml \<br>-o template.docx<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>software</category>
      
      <category>Pandoc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>software</tag>
      
      <tag>Pandoc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pandoc系列 - 1. 安装和基本语法</title>
    <link href="/2025/11/19/software/Pandoc/Pandoc_1/"/>
    <url>/2025/11/19/software/Pandoc/Pandoc_1/</url>
    
    <content type="html"><![CDATA[<h2 id="windows-系统安装-pandoc">1. windows 系统安装 Pandoc</h2><ul><li>下载地址：<a href="https://pandoc.org/installing.html">Pandoc 下载</a></li><li>安装步骤：<ul><li>双击下载的安装包，按照提示进行安装。</li><li>安装完成后，打开命令提示符（CMD）或 PowerShell，输入 <code>pandoc -v</code> 查看安装是否成功。</li></ul></li></ul><h2 id="命令行使用-pandoc">2 命令行使用 Pandoc</h2><ul><li>基本命令：<ul><li><code>pandoc -s input.md -o output.pdf</code>：将 <code>input.md</code> 转换为 <code>output.pdf</code>。</li><li><code>pandoc -s input.md -o output.html</code>：将 <code>input.md</code> 转换为 <code>output.html</code>。</li><li><code>pandoc -s input.tex -o output.docx</code>：将 <code>input.tex</code> 转换为 <code>output.docx</code>。</li></ul></li></ul><p>说明： - <code>-o output.pdf</code> 的作用：指定输出文件名和格式。 - 删掉 <code>-o output.pdf</code>，Pandoc 会把结果输出到命令行，不会自动生成 <code>output.pdf</code> - <code>-o</code> 不可以删除：<code>pandoc -s input.md output.pdf</code> 不会把 <code>output.pdf</code> 当成“输出文件名”，而是当成第二个输入文件来处理 - 如果当前目录下本来就有一个 <code>output.pdf</code> 文件，Pandoc 会把它当成一个要读取的 <code>md</code> 文件去解析（基本上会是乱码/报错） - 如果没有这个文件，会直接报错：<code>找不到文件 output.pdf</code>。 - <code>-s = --standalone</code> 的作用：生成一个完整的独立文档（有必要的前导、头部等），而不是一个“片段”。 - 必须使用 <code>-s</code> 或 <code>--standalone</code>：转换为 HTML 时，需要包含必要的 <code>&lt;head&gt;</code>、<code>&lt;body&gt;</code> 等标签。 - 可以删掉 <code>-s</code> 或 <code>--standalone</code>：转换为 PDF 或 DOCX 等格式时，通常会自动按“独立文档”处理，所以加不加 <code>-s</code> 多数情况下效果一样。例如 <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">pandoc -s <span class="hljs-selector-tag">input</span><span class="hljs-selector-class">.md</span> -o output<span class="hljs-selector-class">.pdf</span><br>pandoc <span class="hljs-selector-tag">input</span><span class="hljs-selector-class">.md</span> -o output.pdf<br></code></pre></td></tr></table></figure> 很多时候效果是一样的，都能得到一个正常的 PDF。</p><p>总结</p><ul><li><code>-o output.pdf</code>：不建议删，否则不会自动生成 pdf 文件。</li><li><code>-o</code> 不可以删除</li><li><code>-s</code>：在 md → pdf 这种用法中，多数情况下可以删，效果一样；保留也没坏处，是比较保险的写法。</li></ul><h2 id="conda-创建-python-环境">2. <code>conda</code> 创建 <code>python</code> 环境</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda create -n pandoc_py310 python=3.10<br></code></pre></td></tr></table></figure><p>激活环境 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda activate pandoc_py310<br></code></pre></td></tr></table></figure></p><h3 id="pip-安装-pandoc-插件">2.1 <code>pip</code> 安装 <code>pandoc</code> 插件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install pandocfilters<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>software</category>
      
      <category>Pandoc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>software</tag>
      
      <tag>Pandoc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 系列 - 1. 介绍</title>
    <link href="/2025/11/17/code/Cpp/cpp_1-intro-2025-11-17/"/>
    <url>/2025/11/17/code/Cpp/cpp_1-intro-2025-11-17/</url>
    
    <content type="html"><![CDATA[<p>test</p>]]></content>
    
    
    <categories>
      
      <category>code</category>
      
      <category>Cpp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>argparse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TensorFlow 系列 - 1. 介绍</title>
    <link href="/2025/11/17/code/TensorFlow/tf_1-intro-2025-11-17/"/>
    <url>/2025/11/17/code/TensorFlow/tf_1-intro-2025-11-17/</url>
    
    <content type="html"><![CDATA[<p>test</p>]]></content>
    
    
    <categories>
      
      <category>code</category>
      
      <category>TensorFlow</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>argparse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows 系列 - 1. 介绍</title>
    <link href="/2025/11/17/os/Windows/windows_1-pblm-2025-11-17/"/>
    <url>/2025/11/17/os/Windows/windows_1-pblm-2025-11-17/</url>
    
    <content type="html"><![CDATA[<p>test</p>]]></content>
    
    
    <categories>
      
      <category>os</category>
      
      <category>Windows</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>argparse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VSCode 系列 - LaTex 公式渲染配置</title>
    <link href="/2025/11/17/software/vscode/vscode_math/"/>
    <url>/2025/11/17/software/vscode/vscode_math/</url>
    
    <content type="html"><![CDATA[<h1 id="vscode-系列---latex-公式渲染配置">VSCode 系列 - LaTex 公式渲染配置</h1><h2 id="数学引擎介绍">数学引擎介绍</h2><ul><li><code>MathJax</code> / <code>KaTeX</code> 都是<strong>浏览器端</strong>的 <code>LaTeX</code> 数学公式渲染库</li><li><code>MathJax</code> / <code>KaTeX</code> 都不是完整的 LaTeX 编译器，只实现了一部分“类似 LaTeX 的数学命令”，而不是整套 LaTeX 宏包系统</li><li>简单说：<code>MathJax</code> 更像 <code>LaTeX</code>，<code>KaTeX</code> 更快、更轻。</li><li>如果最关心 <code>LaTeX</code> 语法兼容性，一般推荐 <code>MathJax</code>。</li><li><code>MathJax</code>: 目标是尽可能完整地支持 TeX / LaTeX 中的数学命令, <code>MathJax</code> 兼容性更完整，但体积更大、渲染相对更重。</li><li><code>KaTeX</code>: 官方维护了一个“支持的 TeX 函数列表”，兼容了相当大一部分常用 LaTeX 数学命令。<ul><li>只能保证常规符号/环境没有问题（分数、根号、矩阵、积分、求和、cases、对齐环境等），</li><li>一些冷门命令、特殊宏包、自定义命令需要手工改写或者会直接报错</li></ul></li></ul><p>👉 <code>LaTeX</code> 兼容性: <code>MathJax</code> &gt; <code>KaTe</code>X</p><h2 id="markdown-的渲染机制">markdown 的渲染机制</h2><ul><li><p>.md → .pdf <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">input</span><span class="hljs-selector-class">.md</span><br>└─(Pandoc 解析 Markdown)<br>    └─ 生成一个 <span class="hljs-selector-class">.tex</span> 中间文件（包含公式的 LaTeX）<br>        └─ 调用 pdflatex / xelatex / lualatex<br>            └─ 得到 out.pdf<br></code></pre></td></tr></table></figure></p></li><li><p>.md → .html <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">input</span><span class="hljs-selector-class">.md</span><br>└─(Markdown 解析器：markdown-it / pandoc / remark 等)<br>    └─ 生成 <span class="hljs-selector-tag">HTML</span> 页面（<span class="hljs-selector-class">.html</span>）<br>        ├─ 方案 <span class="hljs-number">1</span>：页面里嵌入 MathJax 脚本<br>        └─ 方案 <span class="hljs-number">2</span>：构建时就用 KaTeX 预渲染公式<br></code></pre></td></tr></table></figure></p></li><li><p>.md 预览</p><p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gams">input.md (在 VSCode 里打开)<br>└─ 内置 markdown-it 解析 Markdown<br>    └─ 内置 KaTeX 渲染 <span class="hljs-symbol">$</span>...<span class="hljs-symbol">$</span> / <span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>...<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br>        └─ 在侧边的 WebView 里显示预览<br></code></pre></td></tr></table></figure></p></li></ul><table><thead><tr class="header"><th>流程</th><th>典型实现方式</th><th>是否用 LaTeX 编译器</th><th>是否用 MathJax/KaTeX</th></tr></thead><tbody><tr class="odd"><td><strong>md → PDF（LaTeX 路线）</strong></td><td>Pandoc → <code>.tex</code> → <code>xelatex</code></td><td>✅ 是</td><td>❌ 否</td></tr><tr class="even"><td><strong>md → PDF（HTML 路线）</strong></td><td>md → HTML → 浏览器打印/Chromium</td><td>❌ 否</td><td>✅ 一般用 MathJax/KaTeX</td></tr><tr class="odd"><td><strong>md → HTML</strong></td><td>Hexo/Hugo/MkDocs/Jekyll + 插件</td><td>❌ 否</td><td>✅ 通常 MathJax 或 KaTeX</td></tr><tr class="even"><td><strong>md 在 VSCode 预览</strong></td><td>内置 Markdown 预览 + KaTeX</td><td>❌ 否</td><td>✅（默认 KaTeX）</td></tr><tr class="odd"><td><strong>md 在 VSCode + MPE 等</strong></td><td>扩展自己加载 MathJax/KaTeX</td><td>❌ 否（除非扩展特意调用 LaTeX）</td><td>✅ 视扩展而定</td></tr></tbody></table><h2 id="安装支持-mathjax-的预览插件">安装支持 MathJax 的预览插件</h2><ol type="1"><li><p>安装 <code>Markdown Preview Enhanced（MPE）</code> 插件</p></li><li><p>使用 <code>MPE插件预览</code>:</p><ul><li><code>Ctrl+Shift+P</code> → <code>Markdown Preview Enhanced: Open Preview to the Side</code> → 回车</li><li>或者 <code>右键编辑区</code> → <code>Markdown Preview Enhanced: Open Preview to the Side</code></li><li><mark>注意：<code>MPE</code> 默认用 <code>KaTeX</code> 渲染公式，不支持 LaTex 语言的 <code>align</code> 等公式环境和 <code>\label</code>、<code>\eqref</code> 等公式引用命令。</mark> <code>KaTeX</code> 的具体渲染情况见下图。</li></ul></li></ol><figure><img src="vscode-math-1.png" alt="图1.错误渲染" /><figcaption aria-hidden="true">图1.错误渲染</figcaption></figure><h2 id="vs-code-配置-mpe-的数学引擎为-mathjax"><code>VS Code</code> 配置 <code>MPE</code> 的数学引擎为 <code>MathJax</code></h2><ol type="1"><li><p><strong>修改 MPE 插件的数学引擎为 <code>MathJax</code></strong>：<mark>因为 <code>MPE</code> 默认用 <code>KaTeX</code> 渲染公式，需要把 MPE 的数学引擎改成 <code>MathJax</code></mark>，具体操作如下</p><ul><li><code>ctrl + ,</code> → <code>Settings</code> 页面 → <code>Code Actions on Save</code> 选项 → 点击 <code>Edit in settings.json</code> <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;editor.fontSize&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">20</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;terminal.integrated.commandsToSkipShell&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;language-julia.interrupt&quot;</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;julia.symbolCacheDownload&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;editor.codeActionsOnSave&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <br><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-comment">// 添加下面这一行</span><br>    <span class="hljs-attr">&quot;markdown-preview-enhanced.mathRenderingOption&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;MathJax&quot;</span><span class="hljs-punctuation">,</span>  <br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li>做完上述操作后，重新预览 Markdown 文件，公式应该就能正确渲染了，但是引用公式的编号会错误，例如 <code>\eqref{eq:exp}</code> 等都不能正常显示。</li></ul><figure><img src="vscode-math-2.png" alt="图2.正确渲染但引用错误" /><figcaption aria-hidden="true">图2.正确渲染但引用错误</figcaption></figure></li><li><p><mark>修改 <code>MPE</code> 的设置文件 <code>config.js</code> 开启公式自动编号和引用</mark>：<code>Ctrl + Shift + P</code> → 输入 <code>Markdown Preview Enhanced: Open Config Script (Global)</code> → 回车 → 弹出 <code>config.js</code>文件，进行如下修改： <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs json">(<span class="hljs-punctuation">&#123;</span><br>katexConfig<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;macros&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><br>mathjaxConfig<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    tex<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> tags<span class="hljs-punctuation">:</span> &#x27;all&#x27; <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// ★关键：给所有行间公式自动编号，支持 \label / \eqref</span><br>    options<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    loader<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><br>mermaidConfig<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;startOnLoad&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br><span class="hljs-punctuation">&#125;</span>)<br></code></pre></td></tr></table></figure> <code>tags: 'all'</code> 是 <code>MathJax v3</code> 推荐的写法，实测在 <code>MPE</code> 里可以让所有 <code>display</code> 公式自动编号，并且 <code>\label</code> / <code>\eqref</code> 生效。</p></li></ol><figure><img src="vscode-math-3.png" alt="图3.正确渲染且正确错误" /><figcaption aria-hidden="true">图3.正确渲染且正确错误</figcaption></figure><p>如果同时装了 <code>Markdown All in One</code> 等其他 <code>Markdown</code> 插件，预览冲突的话，可以把其他插件的 <code>自动打开预览</code> 功能关掉，只保留 <code>MPE</code> 的 <code>自动打开预览</code> 功能即可。</p>]]></content>
    
    
    <categories>
      
      <category>software</category>
      
      <category>VS-Code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MathJax</tag>
      
      <tag>VS Code</tag>
      
      <tag>KaTex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo 系列 - 4. LaTex 公式测试 （Pandoc + MathJax 渲染效果）</title>
    <link href="/2025/11/15/code/HEXO/hexo_4/"/>
    <url>/2025/11/15/code/HEXO/hexo_4/</url>
    
    <content type="html"><![CDATA[<p>本页用于测试 <strong>pandoc + MathJax</strong> 在 Hexo/Fluid 中的渲染效果。</p><h2 id="行内公式">1. 行内公式</h2><p>这是一个行内公式：<span class="math inline">\(E = mc^2\)</span>，<br />再来一个：<span class="math inline">\(\alpha, \beta, \gamma \in \mathbb{R}\)</span>，<br />以及一个简单的向量：<span class="math inline">\(\boldsymbol{x} = (x_1, x_2, \dots, x_n)^\top\)</span>。</p><h2 id="单行行间公式-label-eqref">2. 单行行间公式 + <code>\label</code> + <code>\eqref</code></h2><p>下面是一个带编号的行间公式，我们给它加上 <code>\label</code>：</p><p><span class="math display">\[\begin{equation}E = mc^2\label{eq:einstein}\end{equation}\]</span></p><p>现在在正文中引用它：式 <span class="math inline">\(\eqref{eq:einstein}\)</span> 是著名的质能方程。</p><h2 id="多行-align-环境-tag-label">3. 多行 align 环境 + <code>\tag</code> + <code>\label</code></h2><p>测试多行对齐的推导过程，并且对其中一行添加 <code>\tag</code>： <span id="eq:J"></span> <span class="math display">\[\begin{align}J(\theta)  &amp;= \mathbb{E}_{s \sim d^\pi,\, a \sim \pi_\theta}     \bigl[ r(s,a) \bigr] \label{eq:obj} \\[4pt]\nabla_\theta J(\theta)  &amp;= \mathbb{E}_{s \sim d^\pi,\, a \sim \pi_\theta}     \Bigl[ \nabla_\theta \log \pi_\theta(a \mid s)\, Q^\pi(s,a) \Bigr]     \label{eq:pg-basic} \\[4pt]  &amp;= \mathbb{E}_{s \sim d^\pi}     \Bigl[ \sum_a \nabla_\theta \pi_\theta(a \mid s)\, Q^\pi(s,a) \Bigr]     \tag{PG*} \label{eq:pg-tag}\end{align}\]</span></p><p>上面我们给了三个公式编号：</p><ul><li>目标函数：式 <span class="math inline">\(\eqref{eq:obj}\)</span>；</li><li>基本形式的策略梯度：式 <span class="math inline">\(\eqref{eq:pg-basic}\)</span>；</li><li>带自定义标签的那一行：式 <span class="math inline">\(\eqref{eq:pg-tag}\)</span>，其显式编号为 <code>(PG*)</code>。见公式 <a href="#eq:J">(2)</a>。</li></ul><h2 id="更复杂的符号与矩阵">4. 更复杂的符号与矩阵</h2><p>再测试希腊字母、集合、矩阵等：</p><p>行内测试：<span class="math inline">\(\forall \epsilon &gt; 0,\ \exists \delta &gt; 0\)</span>，<br />使得当 <span class="math inline">\(0 &lt; \lVert x - x^\ast \rVert &lt; \delta\)</span> 时，有 <span class="math inline">\(\lVert f(x) - f(x^\ast) \rVert &lt; \epsilon\)</span>。</p><p>行间矩阵：</p><p><span class="math display">\[\begin{equation}A =\begin{bmatrix}  1      &amp; 0      &amp; \cdots &amp; 0 \\  0      &amp; 1      &amp; \cdots &amp; 0 \\  \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\  0      &amp; 0      &amp; \cdots &amp; 1\end{bmatrix}, \quad\boldsymbol{b} =\begin{bmatrix}  b_1 \\ b_2 \\ \vdots \\ b_n\end{bmatrix}.\label{eq:matrix}\end{equation}\]</span></p><p>矩阵 <span class="math inline">\(A\)</span> 和向量 <span class="math inline">\(\boldsymbol{b}\)</span> 的定义如式  所示。</p><h2 id="分段函数与条件概率">5. 分段函数与条件概率</h2><p>最后测试分段函数和概率符号：</p><p><span class="math display">\[\begin{equation}p(x) =\begin{cases}\lambda e^{-\lambda x}, &amp; x \ge 0, \\0,                       &amp; x &lt; 0,\end{cases}\quad \lambda &gt; 0.\label{eq:exp}\end{equation}\]</span></p><p>条件概率示例：</p><p><span class="math display">\[\begin{equation}\mathbb{P}(A \mid B) = \frac{\mathbb{P}(A \cap B)}{\mathbb{P}(B)},\qquad \mathbb{P}(B) &gt; 0.\label{eq:cond-prob}\end{equation}\]</span></p><p>在正文中再次引用式  和式 ，确认交叉引用是否正常工作。</p><h2 id="section">6.</h2><ul><li><p>用 <code>Markdown</code> / <code>HTML</code> 做个锚点，伪装成可引用公式 <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;eq:newton&quot;</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br>$$<br>F = ma \tag&#123;1&#125;<br>$$<br><br>在文中这样写：见公式 [<span class="hljs-string">(1)</span>](<span class="hljs-link">#eq:newton</span>)。<br><br></code></pre></td></tr></table></figure></p><p>渲染效果如下</p><p><span id="eq:newton"></span> <span class="math display">\[F = ma \tag{1}\]</span> 在文中这样写：见公式 <a href="#eq:newton">(1)</a>。</p></li></ul><hr /><p>如果本页所有公式（行内、行间、多行 align、、自定义 + ）都正常显示，<br />说明你的 <strong>pandoc + MathJax + Fluid 配置已经完全 OK</strong> 了。</p>]]></content>
    
    
    <categories>
      
      <category>code</category>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
      <tag>pandoc</tag>
      
      <tag>MathJax</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo 系列 - 3. 使用 pandoc + MathJax 渲染公式</title>
    <link href="/2025/11/15/code/HEXO/hexo_3/"/>
    <url>/2025/11/15/code/HEXO/hexo_3/</url>
    
    <content type="html"><![CDATA[<p>本页用于测试 <strong>pandoc + MathJax</strong> 在 Hexo/Fluid 中的渲染效果。</p><h2 id="行内公式">1. 行内公式</h2><p>这是一个行内公式：<span class="math inline">\(E = mc^2\)</span>，<br />再来一个：<span class="math inline">\(\alpha, \beta, \gamma \in \mathbb{R}\)</span>，<br />以及一个简单的向量：<span class="math inline">\(\boldsymbol{x} = (x_1, x_2, \dots, x_n)^\top\)</span>。</p><h2 id="单行行间公式">2. 单行行间公式 + + </h2><p>下面是一个带编号的行间公式，我们给它加上 <code>\label</code>：</p><p><span class="math display">\[\begin{equation}E = mc^2\label{eq:einstein}\end{equation}\]</span></p><p>现在在正文中引用它：式 <span class="math inline">\(\eqref{eq:einstein}\)</span> 是著名的质能方程。</p><h2 id="多行-align-环境">3. 多行 align 环境 + + </h2><p>测试多行对齐的推导过程，并且对其中一行添加 <code>\tag</code>： <span id="eq:J"></span> <span class="math display">\[\begin{align}J(\theta)  &amp;= \mathbb{E}_{s \sim d^\pi,\, a \sim \pi_\theta}     \bigl[ r(s,a) \bigr] \label{eq:obj} \\[4pt]\nabla_\theta J(\theta)  &amp;= \mathbb{E}_{s \sim d^\pi,\, a \sim \pi_\theta}     \Bigl[ \nabla_\theta \log \pi_\theta(a \mid s)\, Q^\pi(s,a) \Bigr]     \label{eq:pg-basic} \\[4pt]  &amp;= \mathbb{E}_{s \sim d^\pi}     \Bigl[ \sum_a \nabla_\theta \pi_\theta(a \mid s)\, Q^\pi(s,a) \Bigr]     \tag{PG*} \label{eq:pg-tag}\end{align}\]</span></p><p>上面我们给了三个公式编号：</p><ul><li>目标函数：式 <span class="math inline">\(\eqref{eq:obj}\)</span>；</li><li>基本形式的策略梯度：式 <span class="math inline">\(\eqref{eq:pg-basic}\)</span>；</li><li>带自定义标签的那一行：式 <span class="math inline">\(\eqref{eq:pg-tag}\)</span>，其显式编号为 <code>(PG*)</code>。见公式 <a href="#eq:J">(2)</a>。</li></ul><h2 id="更复杂的符号与矩阵">4. 更复杂的符号与矩阵</h2><p>再测试希腊字母、集合、矩阵等：</p><p>行内测试：<span class="math inline">\(\forall \epsilon &gt; 0,\ \exists \delta &gt; 0\)</span>，<br />使得当 <span class="math inline">\(0 &lt; \lVert x - x^\ast \rVert &lt; \delta\)</span> 时，有 <span class="math inline">\(\lVert f(x) - f(x^\ast) \rVert &lt; \epsilon\)</span>。</p><p>行间矩阵：</p><p><span class="math display">\[\begin{equation}A =\begin{bmatrix}  1      &amp; 0      &amp; \cdots &amp; 0 \\  0      &amp; 1      &amp; \cdots &amp; 0 \\  \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\  0      &amp; 0      &amp; \cdots &amp; 1\end{bmatrix}, \quad\boldsymbol{b} =\begin{bmatrix}  b_1 \\ b_2 \\ \vdots \\ b_n\end{bmatrix}.\label{eq:matrix}\end{equation}\]</span></p><p>矩阵 <span class="math inline">\(A\)</span> 和向量 <span class="math inline">\(\boldsymbol{b}\)</span> 的定义如式  所示。</p><h2 id="分段函数与条件概率">5. 分段函数与条件概率</h2><p>最后测试分段函数和概率符号：</p><p><span class="math display">\[\begin{equation}p(x) =\begin{cases}\lambda e^{-\lambda x}, &amp; x \ge 0, \\0,                       &amp; x &lt; 0,\end{cases}\quad \lambda &gt; 0.\label{eq:exp}\end{equation}\]</span></p><p>条件概率示例：</p><p><span class="math display">\[\begin{equation}\mathbb{P}(A \mid B) = \frac{\mathbb{P}(A \cap B)}{\mathbb{P}(B)},\qquad \mathbb{P}(B) &gt; 0.\label{eq:cond-prob}\end{equation}\]</span></p><p>在正文中再次引用式  和式 ，确认交叉引用是否正常工作。</p><h2 id="section">6.</h2><ul><li><p>用 <code>Markdown</code> / <code>HTML</code> 做个锚点，伪装成可引用公式 <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;eq:newton&quot;</span>&gt;</span></span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br>$$<br>F = ma \tag&#123;1&#125;<br>$$<br><br>在文中这样写：见公式 [<span class="hljs-string">(1)</span>](<span class="hljs-link">#eq:newton</span>)。<br><br></code></pre></td></tr></table></figure></p><p>渲染效果如下</p><p><span id="eq:newton"></span> <span class="math display">\[F = ma \tag{1}\]</span> 在文中这样写：见公式 <a href="#eq:newton">(1)</a>。</p></li></ul><hr /><p>如果本页所有公式（行内、行间、多行 align、、自定义 + ）都正常显示，<br />说明你的 <strong>pandoc + MathJax + Fluid 配置已经完全 OK</strong> 了。</p>]]></content>
    
    
    <categories>
      
      <category>code</category>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
      <tag>pandoc</tag>
      
      <tag>MathJax</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo 系列 - 2. 搭建网站并安装 Fluid 主题</title>
    <link href="/2025/11/15/code/HEXO/hexo_2/"/>
    <url>/2025/11/15/code/HEXO/hexo_2/</url>
    
    <content type="html"><![CDATA[<h1 id="利用-hexo-建站">1. 利用 hexo 建站</h1><p>在指定文件夹中新建所需要的文件 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init &lt;folder&gt; <span class="hljs-comment"># 1. 在当前路径下创建文件夹 &lt;folder&gt;</span><br>                   <span class="hljs-comment"># 并在 &lt;folder&gt; 中初始化 hexo 项目</span><br><span class="hljs-built_in">cd</span> &lt;folder&gt;        <span class="hljs-comment"># 2. 进入 hexo 项目文件夹 &lt;folder&gt;</span><br>npm install        <span class="hljs-comment"># 3. 在项目文件夹中安装 hexo 引擎</span><br></code></pre></td></tr></table></figure></p><p>执行 <code>hexo init myblog</code> 后，文件夹目录如下 <figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs nix">MYBLOG<br>├── .github<span class="hljs-symbol">/</span>                 <span class="hljs-comment"># （可选）GitHub 相关配置</span><br>├── node_modules<span class="hljs-symbol">/</span>            <span class="hljs-comment"># npm 安装的所有依赖包</span><br>    └── hexo-theme-landscape<span class="hljs-symbol">/</span>   ← 主题完整代码<br>├── scaffolds<span class="hljs-symbol">/</span>               <span class="hljs-comment"># 新建文章/页面的模板</span><br>│   ├── draft.md<br>│   ├── page.md<br>│   └── post.md<br>├── source<span class="hljs-symbol">/</span>                  <span class="hljs-comment"># 你真正写内容的地方</span><br>│   └── _posts<span class="hljs-symbol">/</span>              <span class="hljs-comment"># 博文目录（文章都放这里）</span><br>│       └── hello-world.md   <span class="hljs-comment"># 示例文章</span><br>├── themes<span class="hljs-symbol">/</span>                  <span class="hljs-comment"># 主题目录（每个主题一个子文件夹）</span><br>│   └── .gitkeep             <span class="hljs-comment"># 占位文件，保证 themes 目录能被 git 提交</span><br>├── .gitignore               <span class="hljs-comment"># Git 要忽略的文件/文件夹</span><br>├── _config.yml              <span class="hljs-comment"># 站点的主配置文件（最重要）</span><br>├── _config.landscape.yml    <span class="hljs-comment"># landscape 主题的专用配置（按主题命名）</span><br>├── package-lock.json        <span class="hljs-comment"># 锁定依赖具体版本</span><br>└── package.json             <span class="hljs-comment"># 项目信息 &amp; npm 依赖 &amp; 常用脚本</span><br></code></pre></td></tr></table></figure></p><h2 id="博客内容">1.1 博客内容</h2><ul><li><code>source/_posts/</code><ul><li>是默认的文章目录</li><li>除 _posts 文件夹之外，开头命名为 <code>_</code> (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。 Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。</li><li>之后写的博客文章 <code>.md</code> 都放在这里。</li><li><code>hexo new "my-first-post"</code> 会自动在 <code>source/_posts/</code> 下面生成一个 <code>my-first-post.md</code><br /></li><li><code>Hexo</code> 会把 <code>source</code> 里的内容“编译”成静态网页输出到 <code>public</code>/（执行 <code>hexo g</code> 后才会出现 <code>public</code> 目录）</li></ul></li><li><code>scaffolds/</code><ul><li>博客模板目录，新建文章/页面时用的“初始模板”。</li><li>post.md：使用 <code>hexo new post</code> 创建 “标题” 时的模板</li><li>page.md：使用 <code>hexo new page</code> 创建 “about” 时的模板</li><li>draft.md：使用 <code>hexo new draft</code> 创建 “草稿标题” 时的模板</li><li>可以改这些文件，让每篇新文章自动带上固定的 front-matter（比如作者、分类等）。</li></ul></li></ul><h2 id="设置">1.2 设置</h2><ul><li><p><code>_config.yml</code>：整个站点的主配置文件。包括：</p><ul><li><p>站点标题、副标题、语言</p></li><li><p>URL、permalink 结构</p></li><li><p>主题</p></li><li><p>Markdown / 部署等配置</p></li><li><p>Hexo 相关设置</p></li></ul></li><li><p><code>_config.landscape.yml</code>：和主题名字对应的主题配置文件</p><ul><li><p>是 <code>Hexo</code> 的一种“按主题拆分配置”的写法。</p></li><li><p>使用 <code>theme: landscape</code> 时，这个文件会作为 <code>landscape</code> 主题的配置生效。</p></li><li><p>换成 <code>Fluid</code> 主题时，可以也搞一个 <code>_config.fluid.yml</code>。</p></li></ul></li><li><p><code>node_modules/</code></p><ul><li><code>npm</code> 安装的所有依赖包都在这里（hexo 核心、插件、主题依赖等）。</li><li>非常大但不用管，不需要手动修改。</li><li>一般不会提交到 git（被 .gitignore 忽略）。</li></ul></li><li><p><code>package.json</code></p><ul><li><p>项目的“说明书 + 依赖清单”。</p></li><li><p>内容包括：</p><ul><li><p>“scripts”：给 Hexo 命令起别名 <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>  # 把 source/ 的内容编译后输出到 public/ 目录<br>  <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;hexo generate&quot;</span><span class="hljs-punctuation">,</span><br>  # 清理缓存和 public/ 输出目录，遇到奇怪问题时重置<br>  <span class="hljs-attr">&quot;clean&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;hexo clean&quot;</span><span class="hljs-punctuation">,</span><br>  # 把生成好的 public/ 部署到远端（例如 GitHub Pages）。<br>  # 具体怎么部署，要配置 _config.yml 里的 deploy<br>  <span class="hljs-attr">&quot;deploy&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;hexo deploy&quot;</span><span class="hljs-punctuation">,</span><br>  # 启动本地预览服务器，默认地址 http<span class="hljs-punctuation">:</span><span class="hljs-comment">//localhost:4000</span><br>  <span class="hljs-attr">&quot;server&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;hexo server&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure> npm run build = hexo generate npm run clean = hexo clean npm run deploy = hexo deploy npm run server = hexo server</p></li><li><p>dependencies：依赖哪些 npm 包 <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;dependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <br>  # Hexo 的核心引擎<br>  <span class="hljs-attr">&quot;hexo&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^8.0.0&quot;</span><span class="hljs-punctuation">,</span><br>  # 生成器（generators）：负责生成不同页面类型<br>  <span class="hljs-attr">&quot;hexo-generator-archive&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^2.0.0&quot;</span><span class="hljs-punctuation">,</span> <br>  <span class="hljs-attr">&quot;hexo-generator-category&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^2.0.0&quot;</span><span class="hljs-punctuation">,</span> <br>  <span class="hljs-attr">&quot;hexo-generator-index&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^4.0.0&quot;</span><span class="hljs-punctuation">,</span> <br>  <span class="hljs-attr">&quot;hexo-generator-tag&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^2.0.0&quot;</span><span class="hljs-punctuation">,</span> <br>  # 渲染器（renderers）：把模板/Markdown/CSS 变成最终网页<br>  <span class="hljs-attr">&quot;hexo-renderer-ejs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^2.0.0&quot;</span><span class="hljs-punctuation">,</span> <br>  <span class="hljs-attr">&quot;hexo-renderer-marked&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^7.0.0&quot;</span><span class="hljs-punctuation">,</span> <br>  <span class="hljs-attr">&quot;hexo-renderer-stylus&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^3.0.1&quot;</span><span class="hljs-punctuation">,</span> <br>  # Hexo 自带的本地预览服务器：hexo server / hexo s 就靠它。<br>  <span class="hljs-attr">&quot;hexo-server&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^3.0.0&quot;</span><span class="hljs-punctuation">,</span> <br>  # 默认自带的主题 landscape<br>  <span class="hljs-attr">&quot;hexo-theme-landscape&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^1.0.0&quot;</span> <br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></p></li></ul></li></ul></li></ul><h2 id="主题">1.3 主题</h2><ul><li><code>themes/</code>：每个主题一个子文件夹，如 <code>themes/landscape</code>。<ul><li><p>现在只有一个 .gitkeep 占位文件，说明没有真正的主题文件夹。</p></li><li><p><code>_config.yml</code> 配置了 <code>theme: landscape</code>，<code>Hexo</code> 需要判断</p><ul><li><p>有 <code>themes/landscape/</code> → 用这份（本地主题）</p></li><li><p>没有 <code>themes/landscape/</code> → 用 npm 安装的 <code>node_modules/hexo-theme-landscape/</code></p></li><li><p>优先级：<code>本地主题</code> &gt; <code>npm 安装的主题</code></p></li><li><p><code>node_modules</code> 里的主题当作“依赖包”，不要直接改，避免以后 <code>npm install</code> 覆盖你的修改。</p></li></ul></li></ul></li></ul><h2 id="git-相关">1.4 Git 相关</h2><ul><li><p><code>.gitignore</code> 告诉 <code>Git</code> 哪些文件不要提交，比如：</p><ul><li><p><code>node_modules/</code></p></li><li><p><code>public/</code></p></li></ul><p>主要作用是避免仓库变得又大又乱。</p></li><li><p><code>.github/</code></p><p>专门提供给 <code>GitHub</code> 使用的配置目录，比如：</p><ul><li><p><code>GitHub Actions</code> 工作流</p></li><li><p><code>issue</code> 模板等</p></li></ul><p>对 <code>Hexo</code> 本身没影响，有需要再用即可。</p></li></ul><h1 id="更换-hexo-默认主题为-fluid-主题">2. 更换 Hexo 默认主题为 Fluid 主题</h1><h2 id="安装-fluid-主题">2.1 安装 Fluid 主题</h2><p>安装 Fluid 主题的 npm 包 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install --save hexo-theme-fluid<br></code></pre></td></tr></table></figure> 会在 <code>node_modules/hexo-theme-fluid/</code> 文件中安装 Fluid 主题的代码。</p><p>更新主题 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm update --save hexo-theme-fluid<br></code></pre></td></tr></table></figure> ## 2.2 配置 Fluid 主题 然后在 <code>_config.yml</code> 里改： <figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">theme:</span> fluid     <span class="hljs-meta"># 指定主题</span><br><span class="hljs-symbol">language:</span> <span class="hljs-built_in">zh</span>-CN  <span class="hljs-meta"># 指定语言</span><br></code></pre></td></tr></table></figure> 项目根目录下创建空的 <code>_config.fluid.yml</code>，作为 Fluid 主题的配置文件。</p><h2 id="创建关于页面">2.3 创建“关于”页面</h2><ul><li>执行 <code>hexo new page about</code> 会在 <code>source/about/</code> 下创建一个 <code>about.md</code> 文件。</li><li>编辑 <code>about.md</code>，添加 front-matter： <figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">title:</span> 关于<br><span class="hljs-symbol">layout:</span> about<br></code></pre></td></tr></table></figure></li></ul><h1 id="本地发布并访问">3. 本地发布并访问</h1><p>进行 Hexo 三件套就可以本地发布并访问 <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">hexo clean<br>hexo <span class="hljs-selector-tag">g</span><br>hexo s<br></code></pre></td></tr></table></figure></p><h1 id="部署到-github-pages">4. 部署到 GitHub Pages</h1><p>github 建立一个空项目</p><p>注意，部署到 GitHub Pages 时，需要在 <code>_config.yml</code> 里配置： <figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repo:</span> https:<span class="hljs-comment">//github.com/yourusername/yourusername.github.io.git</span><br><span class="hljs-symbol">  branch:</span> master<br></code></pre></td></tr></table></figure> 并且需要安装 <code>hexo-deployer-git</code> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g hexo-deployer-git<br></code></pre></td></tr></table></figure></p><p>本地git 克隆github空项目</p><p>然后执行部署三件套 <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">hexo clean<br>hexo <span class="hljs-selector-tag">g</span><br>hexo d<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>code</category>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo 系列 - 1. 安装</title>
    <link href="/2025/11/14/code/HEXO/hexo_1/"/>
    <url>/2025/11/14/code/HEXO/hexo_1/</url>
    
    <content type="html"><![CDATA[<h1 id="安装-node.js">1. 安装 <code>Node.js</code></h1><ul><li>前往 <code>Node.js</code> 官网下载安装包，根据提示安装即可。</li><li>安装 <code>Node.js</code> 之后，<code>npm</code> 会一起安装好。两者关系可以简单理解成：<ul><li><code>Node.js</code> = 运行环境（让你能在本机运行 JavaScript 的“引擎”）</li><li><code>npm</code> = 包管理器（用来安装 / 更新 / 管理 各种 JavaScript / Node 的第三方库）</li><li>就像：Python（解释器） + pip（包管理器）</li></ul></li><li>安装后，检查版本号： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">node -v<br>npm -v<br></code></pre></td></tr></table></figure> 命令行输出版本号说明安装成功</li><li>上名指令之所以会在命令行成功执行，是因为<ul><li><code>PATH</code> 里添加了 <code>Node</code> 的安装目录： <code>C:\Program Files\nodejs\</code></li><li><code>PATH</code> 里添加了 <code>npm</code> 的安装目录：<code>%APPDATA%\npm</code> = <code>C:\Users\XXX\AppData\Roaming\npm</code></li></ul></li></ul><h1 id="安装-git">2. 安装 git</h1><p>安装 git 这里不再赘述，安装完 git 后，检查版本号： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git --version<br></code></pre></td></tr></table></figure> 命令行输出版本号说明安装成功</p><p>接下来需要让 npm 识别 git： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g hexo-deployer-git<br></code></pre></td></tr></table></figure> 命令行无报错说明安装成功</p><h1 id="利用-npm-安装-hexo">3. 利用 <code>npm</code> 安装 <code>Hexo</code></h1><p>注意以下两种安装方式的区别</p><p>🔍 全局安装 <code>npm install -g hexo-cli</code></p><ul><li><p><code>-g</code>：全局安装（global）</p></li><li><p>安装的包：<code>hexo-cli</code>，也就是 <code>hexo</code> 的“命令行工具”</p></li><li><p>作用：在系统里安装一个全局的 <code>hexo</code> 命令，之后<strong>在任意目录</strong>都可以在命令行执行： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init<br>hexo new<br>hexo g<br>hexo s<br></code></pre></td></tr></table></figure></p><p>这相当于装了一个“Hexo 启动器”。</p></li></ul><p>🔍 本地安装 <code>npm install hexo</code></p><ul><li><p>没有 <code>-g</code>：本地安装（只装在当前目录的 node_modules 下）</p></li><li><p>安装的包：<code>hexo</code> 核心引擎（生成博客的真正库）</p></li><li><p>作用：给当前博客项目目录 <code>myblog</code> 安装 Hexo 作为依赖。接下来，只能在博客项目目录 <code>myblog</code> 运行： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo<br></code></pre></td></tr></table></figure> 博客项目目录 <code>myblog</code> 会有：</p><ul><li><code>node_modules/hexo</code> 文件夹</li><li><code>package.json</code> 文件</li></ul><p>博客项目目录 <code>myblog</code> 的 <code>hexo</code> 优先级会高于全局的 hexo-cli 。</p></li></ul><p>✅ 搭建博客时 - 全局安装 hexo-cli：<code>npm install -g hexo-cli</code> - 后面使用 <code>hexo</code> 初始化博客项目目录 <code>myblog</code> 时，也会在博客项目目录 <code>myblog</code> 下创建 - <code>node_modules/hexo</code> 文件夹 - <code>package.json</code> 文件</p>]]></content>
    
    
    <categories>
      
      <category>code</category>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LaTex 系列 - 4. TikZ 绘图</title>
    <link href="/2025/11/14/code/Latex/latex_4-Tikz-2025-11-14/"/>
    <url>/2025/11/14/code/Latex/latex_4-Tikz-2025-11-14/</url>
    
    <content type="html"><![CDATA[<p>LaTex 中为了展示一个图片，需要使用 <code>\includegraphics</code> 命令，具体做法如下： - 编写 matlab/python 代码绘制曲线 - 保存图片为 pdf 格式，按照LaTex文档要求放置到指定路径 - 在 LaTex 文档中使用 <code>\includegraphics</code> 命令引入图片</p><p>这种方式可以在 LaTex 文档中展示图片，但是需要注意的是，图片的大小和位置需要手动调整，否则会影响文档的布局。</p><p>这里介绍一个便捷的工具 – TikZ</p><p>下面通过几个例子展示如何使用 TikZ 绘图。</p><h2 id="例-1">例 1</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs latex"><span class="hljs-keyword">\begin</span>&#123;tikzpicture&#125;[&gt;=stealth, scale=1]<br>  <span class="hljs-comment">% 开始 tikzpicture 环境。</span><br>  <span class="hljs-comment">% 选项：</span><br>  <span class="hljs-comment">%   &gt;=stealth  表示之后所有的箭头 (-&gt;) 默认使用 “stealth” 箭头样式；</span><br>  <span class="hljs-comment">%   scale=1    图形整体缩放比例为 1（即不缩放）。</span><br><br>  <span class="hljs-comment">% 坐标轴</span><br>  <span class="hljs-keyword">\draw</span>[-&gt;] (0,0) -- (5,0) node[below] &#123;<span class="hljs-built_in">$</span>t<span class="hljs-built_in">$</span>&#125;;<br>  <span class="hljs-comment">% 画横轴：</span><br>  <span class="hljs-comment">%   从坐标 (0,0) 画到 (5,0)，并在终点加一个箭头（因为使用了 -&gt;）。</span><br>  <span class="hljs-comment">%   在终点 (5,0) 上附着一个 node，位置在 below（线段下方），内容为 t，</span><br>  <span class="hljs-comment">%   作为横轴标签。</span><br><br>  <span class="hljs-keyword">\draw</span>[-&gt;] (0,-2.2) -- (0,2.8) node[left] &#123;<span class="hljs-built_in">$</span>x(t)<span class="hljs-built_in">$</span>&#125;;<br>  <span class="hljs-comment">% 画纵轴：</span><br>  <span class="hljs-comment">%   从 (0,-2.2) 画到 (0,2.8)，在顶部加箭头。</span><br>  <span class="hljs-comment">%   在终点处加一个 node，位置在 left（线段左侧），内容为 x(t)，</span><br>  <span class="hljs-comment">%   作为纵轴标签。</span><br><br>  <span class="hljs-keyword">\draw</span>[dashed,gray] (0,0) -- (5,0);<br>  <span class="hljs-comment">% 画一条灰色虚线：</span><br>  <span class="hljs-comment">%   从 (0,0) 到 (5,0)，与横轴重合，用来表示 x(t)=0 这条“零线”。</span><br><br>  <span class="hljs-comment">% 用公式 x(t) = 2.4 e^&#123;-t&#125; 画一条轨迹</span><br>  <span class="hljs-keyword">\draw</span>[thick,blue, domain=0:5, samples=100]<br>    plot (<span class="hljs-keyword">\x</span>,&#123;2.4*exp(-<span class="hljs-keyword">\x</span>)&#125;);<br>  <span class="hljs-comment">% 画第一条曲线：</span><br>  <span class="hljs-comment">%   线条样式：</span><br>  <span class="hljs-comment">%     thick  加粗；</span><br>  <span class="hljs-comment">%     blue   蓝色；</span><br>  <span class="hljs-comment">%     domain=0:5   自变量 \x 的取值范围是 0 到 5；</span><br>  <span class="hljs-comment">%     samples=100  在区间 [0,5] 上取 100 个采样点来近似这条曲线。</span><br>  <span class="hljs-comment">%   plot (\x,&#123;2.4*exp(-\x)&#125;)：</span><br>  <span class="hljs-comment">%     TikZ 自动把 \x 当作横坐标变量；</span><br>  <span class="hljs-comment">%     纵坐标是 &#123;2.4*exp(-\x)&#125;，即 y = 2.4 * e^&#123;-x&#125;；</span><br>  <span class="hljs-comment">%     所以这条曲线表示解轨迹 x(t) = 2.4 e^&#123;-t&#125;。</span><br><br>  <span class="hljs-comment">% 再画一条 x(t) = -1.6 e^&#123;-t&#125; 的轨迹</span><br>  <span class="hljs-keyword">\draw</span>[thick,blue, domain=0:5, samples=100]<br>    plot (<span class="hljs-keyword">\x</span>,&#123;-1.6*exp(-<span class="hljs-keyword">\x</span>)&#125;);<br>  <span class="hljs-comment">% 第二条曲线：</span><br>  <span class="hljs-comment">%   样式同上（加粗、蓝色、[0,5] 区间、100 个采样点）。</span><br>  <span class="hljs-comment">%   纵坐标公式为 -1.6*exp(-\x)，即 y = -1.6 e^&#123;-x&#125;，</span><br>  <span class="hljs-comment">%   表示从负初值 -1.6 出发，同样指数衰减到 0 的解轨迹。</span><br><br><span class="hljs-keyword">\end</span>&#123;tikzpicture&#125;<br></code></pre></td></tr></table></figure><p>运行效果 <img src="f1.png" alt="regular" /></p><h2 id="例-2">例 2</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs python">\begin&#123;tikzpicture&#125;[&gt;=stealth, scale=<span class="hljs-number">1</span>]<br>  % 开始 tikzpicture 环境，用来绘图。<br>  % 选项：<br>  %   &gt;=stealth ：把之后所有 <span class="hljs-string">&quot;-&gt;&quot;</span> 箭头的箭头样式设为 stealth；<br>  %   scale=<span class="hljs-number">1</span>   ：整体缩放因子为 <span class="hljs-number">1</span>（不缩放，如果改成 <span class="hljs-number">1.2</span> 就会整体放大 <span class="hljs-number">1.2</span> 倍）。<br><br>  % 坐标轴<br>  \draw[-&gt;] (<span class="hljs-number">0</span>,<span class="hljs-number">0</span>) -- (<span class="hljs-number">5</span>,<span class="hljs-number">0</span>) node[below] &#123;$t$&#125;;<br>  % 画横轴：<br>  %   从点 (<span class="hljs-number">0</span>,<span class="hljs-number">0</span>) 到 (<span class="hljs-number">5</span>,<span class="hljs-number">0</span>) 画一条直线，末端带箭头（因为使用了 <span class="hljs-string">&quot;-&gt;&quot;</span>）。<br>  %   在终点 (<span class="hljs-number">5</span>,<span class="hljs-number">0</span>) 上附着一个 node，位置在 below（线段下方），内容为 t，<br>  %   作为横轴的标签。<br><br>  \draw[-&gt;] (<span class="hljs-number">0</span>,-<span class="hljs-number">2.2</span>) -- (<span class="hljs-number">0</span>,<span class="hljs-number">2.8</span>) node[left] &#123;$x(t)$&#125;;<br>  % 画纵轴：<br>  %   从 (<span class="hljs-number">0</span>,-<span class="hljs-number">2.2</span>) 到 (<span class="hljs-number">0</span>,<span class="hljs-number">2.8</span>) 画一条直线，末端带箭头。<br>  %   在终点左侧放置一个 node，内容为 x(t)，作为纵轴标签。<br><br>  \draw[dashed,gray] (<span class="hljs-number">0</span>,<span class="hljs-number">0</span>) -- (<span class="hljs-number">5</span>,<span class="hljs-number">0</span>);<br>  % 画一条灰色虚线：<br>  %   从 (<span class="hljs-number">0</span>,<span class="hljs-number">0</span>) 到 (<span class="hljs-number">5</span>,<span class="hljs-number">0</span>)，与横轴重合；<br>  %   样式为 dashed（虚线）、gray（灰色），表示 x(t)=<span class="hljs-number">0</span> 的零线。<br><br>  % 在 t=<span class="hljs-number">0</span> 左侧标注不同的初值<br>  \draw (<span class="hljs-number">0</span>,<span class="hljs-number">2.4</span>) node[left] &#123;$x_0^&#123;(<span class="hljs-number">1</span>)&#125;$&#125;;<br>  % 在坐标 (<span class="hljs-number">0</span>,<span class="hljs-number">2.4</span>) 放一个 node，位置在该点左侧（left），<br>  % 文本为 x_0^&#123;(<span class="hljs-number">1</span>)&#125;，表示第一条轨迹的初始值。<br><br>  \draw (<span class="hljs-number">0</span>,<span class="hljs-number">1.5</span>) node[left] &#123;$x_0^&#123;(<span class="hljs-number">2</span>)&#125;$&#125;;<br>  % 在 (<span class="hljs-number">0</span>,<span class="hljs-number">1.5</span>) 左侧标注 x_0^&#123;(<span class="hljs-number">2</span>)&#125;。<br><br>  \draw (<span class="hljs-number">0</span>,<span class="hljs-number">0.7</span>) node[left] &#123;$x_0^&#123;(<span class="hljs-number">3</span>)&#125;$&#125;;<br>  % 在 (<span class="hljs-number">0</span>,<span class="hljs-number">0.7</span>) 左侧标注 x_0^&#123;(<span class="hljs-number">3</span>)&#125;。<br><br>  \draw (<span class="hljs-number">0</span>,-<span class="hljs-number">0.8</span>) node[left] &#123;$x_0^&#123;(<span class="hljs-number">4</span>)&#125;$&#125;;<br>  % 在 (<span class="hljs-number">0</span>,-<span class="hljs-number">0.8</span>) 左侧标注 x_0^&#123;(<span class="hljs-number">4</span>)&#125;。<br><br>  \draw (<span class="hljs-number">0</span>,-<span class="hljs-number">1.6</span>) node[left] &#123;$x_0^&#123;(<span class="hljs-number">5</span>)&#125;$&#125;;<br>  % 在 (<span class="hljs-number">0</span>,-<span class="hljs-number">1.6</span>) 左侧标注 x_0^&#123;(<span class="hljs-number">5</span>)&#125;。<br>  % 这五个标记一起表示：在 t=<span class="hljs-number">0</span> 时，系统可能的五个不同初始状态 x_0^&#123;(i)&#125;。<br><br>  % 用 x(t) = x0 * e^&#123;-t&#125; 画 <span class="hljs-number">5</span> 条轨迹<br>  \foreach \xzero <span class="hljs-keyword">in</span> &#123;<span class="hljs-number">2.4</span>, <span class="hljs-number">1.5</span>, <span class="hljs-number">0.7</span>, -<span class="hljs-number">0.8</span>, -<span class="hljs-number">1.6</span>&#125; &#123;<br>    % \foreach 是 TikZ 的循环语句：<br>    %   循环变量 \xzero 依次取 <span class="hljs-number">2.4</span>, <span class="hljs-number">1.5</span>, <span class="hljs-number">0.7</span>, -<span class="hljs-number">0.8</span>, -<span class="hljs-number">1.6</span> 这五个值。<br>    %   对每个 \xzero，都执行大括号中的 \draw 命令，画出一条对应初值的轨迹。<br><br>    \draw[thick,blue, domain=<span class="hljs-number">0</span>:<span class="hljs-number">5</span>, samples=<span class="hljs-number">100</span>]<br>      plot (\x,&#123;\xzero*exp(-\x)&#125;);<br>    % 对当前的初值 x0=\xzero 画出解轨迹 x(t)=x0*e^&#123;-t&#125;：<br>    %   thick     ：线条加粗；<br>    %   blue      ：线条颜色为蓝色；<br>    %   domain=<span class="hljs-number">0</span>:<span class="hljs-number">5</span>：自变量 \x 的范围是 [<span class="hljs-number">0</span>,<span class="hljs-number">5</span>]；<br>    %   samples=<span class="hljs-number">100</span>：在这个区间内取 <span class="hljs-number">100</span> 个采样点来近似这条曲线。<br>    %   plot (\x,&#123;...&#125;)：<br>    %     横坐标为 \x，纵坐标为 \xzero*exp(-\x)，<br>    %     即从不同 x0 出发的指数衰减轨迹。<br>  &#125;<br><br>  % \node at (<span class="hljs-number">2.6</span>,<span class="hljs-number">2.4</span>) &#123;\small 好的 $F$&#125;;<br>  % \node at (<span class="hljs-number">2.5</span>,-<span class="hljs-number">2</span>) &#123;任意 $x_0$ 都收敛到 <span class="hljs-number">0</span>&#125;;<br>  % 上面两行被注释掉了（行首有 %，LaTeX 不会执行）：<br>  %   如果取消注释，它们会在指定坐标位置放置说明文字，<br>  %   用来说明这是一个“好的 F（反馈/映射）”，任意初值都收敛到 <span class="hljs-number">0</span>。<br><br>\end&#123;tikzpicture&#125;<br>% 结束 tikzpicture 环境，整幅图形绘制完成。<br><br></code></pre></td></tr></table></figure><p>运行效果 <img src="f2.png" alt="regular" /></p><h2 id="例-3">例 3</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python">\begin&#123;tikzpicture&#125;<br>  % 开始一个 TikZ 图环境，pgfplots 的 axis 环境也放在 tikzpicture 里。<br><br>  \begin&#123;axis&#125;[<br>    % 开始 pgfplots 的坐标轴环境，用来自动生成坐标系和函数图像。<br>    axis lines=middle,<br>    % 让坐标轴穿过原点，并且只画两条“中间”的坐标轴（而不是四周的边框）。<br>    % 即 x 轴和 y 轴都从原点向两边延伸，看起来像数学课本上的坐标系。<br>    xlabel=&#123;$t$&#125;,<br>    % 设置横轴的标签（label），显示为数学模式的 t。<br>    ylabel=&#123;$x(t)$&#125;,<br>    % 设置纵轴的标签，显示为数学模式的 x(t)。<br>    xmin=<span class="hljs-number">0</span>, xmax=<span class="hljs-number">6</span>,<br>    % 设置 x 轴显示范围：从 <span class="hljs-number">0</span> 到 <span class="hljs-number">5</span>。<br>    % 图中不会画出超过这个范围之外的内容。<br>    ymin=-<span class="hljs-number">2.2</span>, ymax=<span class="hljs-number">2.8</span>,<br>    % 设置 y 轴显示范围：从 -<span class="hljs-number">2.2</span> 到 <span class="hljs-number">2.8</span>。<br>    % 方便把所有轨迹都放在同一视窗里。<br>  ]<br>    % 以上是 axis 环境的可选参数列表，方括号结束到这里。<br><br>    % x(t) = <span class="hljs-number">2.4</span> e^&#123;-t&#125;<br>    \addplot[blue, thick, domain=<span class="hljs-number">0</span>:<span class="hljs-number">5</span>] &#123;<span class="hljs-number">2.4</span>*exp(-x)&#125;;<br>    % 使用 pgfplots 画第一条函数曲线：<br>    %   关键字 \addplot 表示“添加一条曲线”。<br>    %   [blue, thick, domain=<span class="hljs-number">0</span>:<span class="hljs-number">5</span>] 是画图选项：<br>    %       blue  曲线为蓝色；<br>    %       thick 线条加粗；<br>    %       domain=<span class="hljs-number">0</span>:<span class="hljs-number">5</span> 自变量 x 的取值范围是 <span class="hljs-number">0</span> 到 <span class="hljs-number">5</span>。<br>    %   花括号里的 &#123;<span class="hljs-number">2.4</span>*exp(-x)&#125; 是函数表达式：<br>    %       变量名是 x（pgfplots 约定俗成）；<br>    %       表示 y = <span class="hljs-number">2.4</span> * e^&#123;-x&#125;，即 x(t)=<span class="hljs-number">2.4</span> e^&#123;-t&#125; 这条指数衰减曲线。<br><br>    % x(t) = -<span class="hljs-number">1.6</span> e^&#123;-t&#125;<br>    \addplot[blue, thick, domain=<span class="hljs-number">0</span>:<span class="hljs-number">5</span>] &#123;-<span class="hljs-number">1.6</span>*exp(-x)&#125;;<br>    % 第二条函数曲线：<br>    %   同样是蓝色、加粗、定义域 <span class="hljs-number">0</span>~<span class="hljs-number">5</span>；<br>    %   函数为 y = -<span class="hljs-number">1.6</span> * e^&#123;-x&#125;，即从负初始值 -<span class="hljs-number">1.6</span> 出发的衰减轨迹。<br>    %   两条曲线一起表示不同初始值的解，都随 t 增大而趋向 <span class="hljs-number">0</span>。<br><br>  \end&#123;axis&#125;<br>  % 结束坐标轴环境，坐标系和里面画的函数到此为止。<br><br>\end&#123;tikzpicture&#125;<br>% 结束 tikzpicture 环境，这个图形块就画完了。<br></code></pre></td></tr></table></figure><p>运行效果 <img src="f3.png" alt="regular" /></p><h2 id="例-4">例 4</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs python">\usetikzlibrary&#123;arrows.meta,positioning,shapes.geometric&#125;<br><br>\begin&#123;tikzpicture&#125;[<br>    % 开始TikZ图形环境，方括号内是全局样式设置    <br>    &gt;=Stealth,<br>    % 设置默认箭头类型为Stealth（三角形尖头箭头）    <br>    box/.style=&#123;<br>        % 定义名为<span class="hljs-string">&quot;box&quot;</span>的样式，用于两个蓝色方框        <br>        rectangle,<br>        % 形状为矩形        <br>        rounded corners=15pt,<br>        % 圆角半径为15pt，使矩形四角变圆        <br>        minimum width=5cm,<br>        % 最小宽度<span class="hljs-number">5</span>厘米        <br>        minimum height=<span class="hljs-number">1.8</span>cm,<br>        % 最小高度<span class="hljs-number">1.8</span>厘米        <br>        fill=blue!<span class="hljs-number">60</span>,<br>        % 填充颜色为<span class="hljs-number">60</span>%蓝色（蓝色与白色混合<span class="hljs-number">60</span>:<span class="hljs-number">40</span>）        <br>        draw=blue!<span class="hljs-number">70</span>,<br>        % 边框颜色为<span class="hljs-number">70</span>%蓝色        <br>        line width=2pt,<br>        % 边框线宽2pt        <br>        text=white,<br>        % 文字颜色为白色        <br>        font=\Large\bfseries,<br>        % 字体为Large大小且加粗        <br>        align=center<br>        % 文字居中对齐<br>    &#125;,    <br>    title/.style=&#123;<br>        % 定义名为<span class="hljs-string">&quot;title&quot;</span>的样式，用于红色标题框        <br>        rectangle,<br>        % 形状为矩形        <br>        minimum width=7cm,<br>        % 最小宽度<span class="hljs-number">7</span>厘米        <br>        minimum height=<span class="hljs-number">1.2</span>cm,<br>        % 最小高度<span class="hljs-number">1.2</span>厘米        <br>        fill=red!<span class="hljs-number">80</span>!black,<br>        % 填充颜色：<span class="hljs-number">80</span>%红色+<span class="hljs-number">20</span>%黑色，产生深红色        <br>        text=white,<br>        % 文字颜色为白色        <br>        font=\huge\bfseries<br>        % 字体为huge大小且加粗<br>    &#125;,    <br>    arrow/.style=&#123;<br>        % 定义名为<span class="hljs-string">&quot;arrow&quot;</span>的样式，用于弧形箭头        <br>        line width=4pt,<br>        % 箭头线宽4pt        <br>        blue!<span class="hljs-number">70</span>,<br>        % 箭头颜色为<span class="hljs-number">70</span>%蓝色        <br>        -&gt;,<br>        % 线条末端添加箭头        <br>        &gt;=Stealth<br>        % 箭头样式为Stealth型<br>    &#125;<br>]<br>% 样式定义结束<br><br>    % 标题<br>    \node[title] (title) at (<span class="hljs-number">0</span>, <span class="hljs-number">3.8</span>) &#123;Feedback Loop&#125;;<br>    % 创建一个节点：<br>    % [title]: 应用之前定义的title样式<br>    % (title): 给这个节点命名为title（虽然后面没用到这个名字）<br>    % at (<span class="hljs-number">0</span>, <span class="hljs-number">2.8</span>): 位置在坐标(<span class="hljs-number">0</span>, <span class="hljs-number">2.8</span>)，即x=<span class="hljs-number">0</span>, y=<span class="hljs-number">2.8</span><br>    % &#123;Feedback Loop&#125;: 节点中显示的文字内容<br>    <br>    % 左侧方框<br>    \node[box] (action) at (-<span class="hljs-number">3.2</span>, <span class="hljs-number">0</span>) &#123;Action <span class="hljs-keyword">or</span> Stimulus&#125;;<br>    % 创建左侧蓝色方框：<br>    % [box]: 应用box样式<br>    % (action): 节点命名为action，后面绘制箭头时会用到<br>    % at (-<span class="hljs-number">3.2</span>, <span class="hljs-number">0</span>): 位置在x=-<span class="hljs-number">3.2</span>, y=<span class="hljs-number">0</span>（左侧）<br>    % &#123;Action <span class="hljs-keyword">or</span> Stimulus&#125;: 显示的文字<br>    <br>    % 右侧方框<br>    \node[box] (response) at (<span class="hljs-number">3.2</span>, <span class="hljs-number">0</span>) &#123;Response (Feedback)&#125;;<br>    % 创建右侧蓝色方框：<br>    % [box]: 应用box样式<br>    % (response): 节点命名为response<br>    % at (<span class="hljs-number">3.2</span>, <span class="hljs-number">0</span>): 位置在x=<span class="hljs-number">3.2</span>, y=<span class="hljs-number">0</span>（右侧）<br>    % &#123;Response (Feedback)&#125;: 显示的文字<br>    <br>    % 上方弧形箭头（从左到右）- 从标题下方经过<br>    \draw[arrow] (action.north) to[out=<span class="hljs-number">70</span>, <span class="hljs-keyword">in</span>=<span class="hljs-number">110</span>] (response.north);<br>    % 绘制上方的弧形箭头：<br>    % [arrow]: 应用arrow样式<br>    % (action.north): 起点是action节点的北侧（上方中心点）<br>    % to[out=<span class="hljs-number">70</span>, <span class="hljs-keyword">in</span>=<span class="hljs-number">110</span>]: 使用贝塞尔曲线连接<br>    %   out=<span class="hljs-number">70</span>: 从起点以<span class="hljs-number">70</span>度角度出发（<span class="hljs-number">0</span>度是正右，<span class="hljs-number">90</span>度是正上）<br>    %   <span class="hljs-keyword">in</span>=<span class="hljs-number">110</span>: 以<span class="hljs-number">110</span>度角度进入终点<br>    % (response.north): 终点是response节点的北侧<br>    <br>    % 下方弧形箭头（从右到左）<br>    \draw[arrow] (response.south) to[out=-<span class="hljs-number">110</span>, <span class="hljs-keyword">in</span>=-<span class="hljs-number">70</span>] (action.south);<br>    % 绘制下方的弧形箭头：<br>    % [arrow]: 应用arrow样式<br>    % (response.south): 起点是response节点的南侧（下方中心点）<br>    % to[out=-<span class="hljs-number">110</span>, <span class="hljs-keyword">in</span>=-<span class="hljs-number">70</span>]: 使用贝塞尔曲线<br>    %   out=-<span class="hljs-number">110</span>: 从起点以-<span class="hljs-number">110</span>度（即向左下）出发<br>    %   <span class="hljs-keyword">in</span>=-<span class="hljs-number">70</span>: 以-<span class="hljs-number">70</span>度（即从右下）进入终点<br>    % (action.south): 终点是action节点的南侧<br><br>\end&#123;tikzpicture&#125;<br></code></pre></td></tr></table></figure><p>运行效果 <img src="f4.png" alt="regular" /></p><h2 id="例-5">例 5</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br></pre></td><td class="code"><pre><code class="hljs python">\usetikzlibrary&#123;arrows.meta,positioning,calc,fit&#125;<br>%\usepackage&#123;mathptmx&#125; % Times New Roman 字体<br><br>\begin&#123;tikzpicture&#125;[<br>    % 开始TikZ绘图环境，方括号内定义全局样式    <br>    &gt;=Stealth,<br>    % 设置默认箭头样式为Stealth（三角形箭头）    <br>    thick,<br>    % 设置所有线条为粗线    <br>    % 定义各种节点样式<br>    block/.style=&#123;<br>        % 定义名为<span class="hljs-string">&quot;block&quot;</span>的样式，用于绘制方框（如P、I、D、System）<br>        draw,<br>        % 绘制边框<br>        rectangle,<br>        % 形状为矩形        <br>        minimum height=1cm,<br>        % 最小高度<span class="hljs-number">1</span>厘米        <br>        minimum width=2cm,<br>        % 最小宽度<span class="hljs-number">2</span>厘米        <br>        align=center,<br>        % 文本居中对齐        <br>        line width=<span class="hljs-number">0.8</span>pt<br>        % 边框线宽<span class="hljs-number">0.8</span>pt<br>    &#125;,    <br>    <span class="hljs-built_in">sum</span>/.style=&#123;<br>        % 定义名为<span class="hljs-string">&quot;sum&quot;</span>的样式，用于绘制求和器（圆圈）        <br>        draw,<br>        % 绘制边框        <br>        circle,<br>        % 形状为圆形        <br>        inner sep=0pt,<br>        % 内部间距为<span class="hljs-number">0</span>（文字紧贴边框）        <br>        minimum size=8mm,<br>        % 圆的最小直径<span class="hljs-number">8</span>毫米        <br>        line width=<span class="hljs-number">0.8</span>pt<br>        % 边框线宽<span class="hljs-number">0.8</span>pt<br>    &#125;,    <br>    dashedbox/.style=&#123;<br>        % 定义名为<span class="hljs-string">&quot;dashedbox&quot;</span>的样式，用于绘制虚线框        <br>        draw=cyan!<span class="hljs-number">60</span>,<br>        % 边框颜色为<span class="hljs-number">60</span>%青色        <br>        dashed,<br>        % 边框为虚线        <br>        line width=1pt,<br>        % 虚线线宽1pt        <br>        rounded corners=3pt,<br>        % 圆角半径3pt        <br>        inner sep=8pt<br>        % 内部间距8pt（框与内容的距离）<br>    &#125;,    <br>    label/.style=&#123;<br>        % 定义名为<span class="hljs-string">&quot;label&quot;</span>的样式，用于虚线框上方的标签文字        <br>        font=\small,<br>        % 字体大小为small        <br>        cyan!<span class="hljs-number">70</span>!blue<br>        % 颜色为<span class="hljs-number">70</span>%青色+<span class="hljs-number">30</span>%蓝色的混合色<br>    &#125;<br>]<br>% 全局样式定义结束<br><br>    % 主要节点定义<br>    % 求和器<span class="hljs-number">1</span>（比较器）<br>    \node[<span class="hljs-built_in">sum</span>] (sum1) at (<span class="hljs-number">0</span>,<span class="hljs-number">0</span>) &#123;$\Sigma$&#125;;<br>    % 创建第一个求和器节点：<br>    % [<span class="hljs-built_in">sum</span>]: 应用<span class="hljs-built_in">sum</span>样式<br>    % (sum1): 节点命名为sum1<br>    % at (<span class="hljs-number">0</span>,<span class="hljs-number">0</span>): 位置在坐标原点<br>    % &#123;$\Sigma$&#125;: 显示求和符号Σ<br>    <br>    % 积分环节<br>    \node[block] (integral) at (<span class="hljs-number">4</span>,<span class="hljs-number">0</span>) &#123;$\displaystyle\text&#123;I&#125;\quad K_i\<span class="hljs-built_in">int</span> e(t)dt$&#125;;<br>    % 创建积分环节节点：<br>    % [block]: 应用block样式<br>    % (integral): 命名为integral<br>    % at (<span class="hljs-number">4</span>,<span class="hljs-number">0</span>): 位置在x=<span class="hljs-number">4</span>, y=<span class="hljs-number">0</span><br>    % \displaystyle: 使积分符号以显示模式（更大）显示<br>    % \text&#123;I&#125;: 文本模式显示字母I<br>    % \quad: 添加一个空格<br>    % K_i\<span class="hljs-built_in">int</span> e(t)dt: 积分公式<br>    <br>    % 求和器<span class="hljs-number">2</span><br>    \node[<span class="hljs-built_in">sum</span>] (sum2) at (<span class="hljs-number">7.5</span>,<span class="hljs-number">0</span>) &#123;$\Sigma$&#125;;<br>    % 创建第二个求和器<br>    % at (<span class="hljs-number">7.5</span>,<span class="hljs-number">0</span>): 位置在x=<span class="hljs-number">7.5</span>, y=<span class="hljs-number">0</span><br>    <br>    % 系统<br>    \node[block, minimum width=<span class="hljs-number">2.5</span>cm] (system) at (<span class="hljs-number">11</span>,<span class="hljs-number">0</span>) &#123;System&#125;;<br>    % 创建系统方框：<br>    % minimum width=<span class="hljs-number">2.5</span>cm: 覆盖默认宽度，设为<span class="hljs-number">2.5</span>cm<br>    % (system): 命名为system<br>    % at (<span class="hljs-number">11</span>,<span class="hljs-number">0</span>): 位置在x=<span class="hljs-number">11</span>, y=<span class="hljs-number">0</span><br>    <br>    % 比例环节<br>    \node[block, minimum width=2cm] (prop) at (<span class="hljs-number">4</span>,<span class="hljs-number">2.2</span>) &#123;$\text&#123;P&#125;\quad K_p e(t)$&#125;;<br>    % 创建比例环节（P控制器）：<br>    % at (<span class="hljs-number">4</span>,<span class="hljs-number">2.2</span>): 位置在x=<span class="hljs-number">4</span>, y=<span class="hljs-number">2.2</span>（上方）<br>    % (prop): 命名为prop<br>    <br>    % 微分环节<br>    \node[block, minimum width=2cm] (diff) at (<span class="hljs-number">4</span>,-<span class="hljs-number">2.2</span>) &#123;$\displaystyle\text&#123;D&#125;\quad K_d\frac&#123;de(t)&#125;&#123;dt&#125;$&#125;;<br>    % 创建微分环节（D控制器）：<br>    % at (<span class="hljs-number">4</span>,-<span class="hljs-number">2.2</span>): 位置在x=<span class="hljs-number">4</span>, y=-<span class="hljs-number">2.2</span>（下方）<br>    % (diff): 命名为diff<br>    % \frac&#123;de(t)&#125;&#123;dt&#125;: 微分符号<br>    <br>    % 输入输出节点<br>    \node[left=<span class="hljs-number">1.5</span>cm of sum1] (<span class="hljs-built_in">input</span>) &#123;$r(t)$&#125;;<br>    % 创建输入节点：<br>    % left=<span class="hljs-number">1.5</span>cm of sum1: 在sum1节点左侧<span class="hljs-number">1.5</span>cm处<br>    % (<span class="hljs-built_in">input</span>): 命名为<span class="hljs-built_in">input</span><br>    % &#123;$r(t)$&#125;: 显示输入信号r(t)<br>    <br>    \node[right=<span class="hljs-number">1.5</span>cm of system] (output) &#123;$y(t)$&#125;;<br>    % 创建输出节点：<br>    % right=<span class="hljs-number">1.5</span>cm of system: 在system节点右侧<span class="hljs-number">1.5</span>cm处<br>    % (output): 命名为output<br>    <br>    % 虚线框<span class="hljs-number">1</span>：Comparator<br>    \node[dashedbox, fit=(sum1), label distance=2mm] (comp-box) &#123;&#125;;<br>    % 创建比较器虚线框：<br>    % [dashedbox]: 应用虚线框样式<br>    % fit=(sum1): 自动调整大小以包围sum1节点<br>    % label distance=2mm: 标签距离（未直接使用）<br>    % (comp-box): 命名为comp-box<br>    % &#123;&#125;: 节点内容为空（只显示边框）<br>    <br>    \node[label, above=2mm of comp-box.north] &#123;Comparator&#125;;<br>    % 在虚线框上方创建<span class="hljs-string">&quot;Comparator&quot;</span>文字标签：<br>    % [label]: 应用label样式<br>    % above=2mm of comp-box.north: 在comp-box的北侧（上方）上方2mm处<br>    <br>    % 虚线框<span class="hljs-number">2</span>：Loop Filter<br>    \coordinate (<span class="hljs-built_in">filter</span>-nw) at ([xshift=-8mm, yshift=10mm]prop.north west);<br>    % 定义Loop Filter虚线框的西北角坐标：<br>    % \coordinate: 定义一个坐标点（不可见）<br>    % (<span class="hljs-built_in">filter</span>-nw): 命名为<span class="hljs-built_in">filter</span>-nw（northwest）<br>    % [xshift=-8mm, yshift=10mm]: 相对于prop.north west（比例环节左上角）<br>    %   向左偏移8mm，向上偏移10mm<br>    <br>    \coordinate (<span class="hljs-built_in">filter</span>-se) at ([xshift=8mm, yshift=-10mm]diff.south east);<br>    % 定义Loop Filter虚线框的东南角坐标：<br>    % (<span class="hljs-built_in">filter</span>-se): 命名为<span class="hljs-built_in">filter</span>-se（southeast）<br>    % 相对于diff.south east（微分环节右下角）<br>    %   向右偏移8mm，向下偏移10mm<br>    <br>    \node[dashedbox, fit=&#123;(<span class="hljs-built_in">filter</span>-nw)(<span class="hljs-built_in">filter</span>-se)(sum2)&#125;] (<span class="hljs-built_in">filter</span>-box) &#123;&#125;;<br>    % 创建Loop Filter虚线框：<br>    % fit=&#123;(<span class="hljs-built_in">filter</span>-nw)(<span class="hljs-built_in">filter</span>-se)(sum2)&#125;: 自动调整大小以包围这三个点/节点<br>    % 这样就创建了一个包含P、I、D和sum2的大虚线框<br>    <br>    \node[label, above=2mm of <span class="hljs-built_in">filter</span>-box.north] &#123;Loop Filter&#125;;<br>    % 在虚线框上方创建<span class="hljs-string">&quot;Loop Filter&quot;</span>文字标签<br>    <br>    % 绘制连接线 - 全部横平竖直<br>    % 输入到求和器<span class="hljs-number">1</span><br>    \draw[-&gt;] (<span class="hljs-built_in">input</span>) -- (sum1);<br>    % 从<span class="hljs-built_in">input</span>节点画箭头到sum1节点<br>    % [-&gt;]: 表示线的末端有箭头<br>    % --: 直线连接<br>    <br>    % 求和器<span class="hljs-number">1</span>后的分支点<br>    \coordinate (branch1) at ([xshift=<span class="hljs-number">1.5</span>cm]sum1.east);<br>    % 定义一个分支点坐标：<br>    % (branch1): 命名为branch1<br>    % at ([xshift=<span class="hljs-number">1.5</span>cm]sum1.east): 在sum1的东侧（右侧）向右<span class="hljs-number">1.5</span>cm处<br>    % 这个点用于信号分成三路（P、I、D）<br>    <br>    % 求和器<span class="hljs-number">1</span>到分支点，标注e(t)<br>    \draw[-&gt;] (sum1.east) -- (branch1) node[pos=<span class="hljs-number">0.5</span>, above, font=\small] &#123;$e(t)$&#125;;<br>    % 从sum1的右侧画箭头到分支点：<br>    % node[pos=<span class="hljs-number">0.5</span>, above, font=\small] &#123;$e(t)$&#125;: 在线段中点（pos=<span class="hljs-number">0.5</span>）<br>    %   上方添加文字标签e(t)<br>    <br>    % 分支点到比例环节（先竖直后水平）<br>    \draw (branch1) |- (prop.west);<br>    % 从branch1到prop.west画线：<br>    % |-: 先水平后竖直的连接方式（实际这里是先竖直后水平，因为目标在上方）<br>    <br>    \draw[-&gt;] ([xshift=-<span class="hljs-number">0.3</span>cm]prop.west) -- (prop.west);<br>    % 在比例环节入口处画一小段箭头：<br>    % [xshift=-<span class="hljs-number">0.3</span>cm]prop.west: 从prop左侧向左<span class="hljs-number">0.3</span>cm的位置<br>    % 到prop.west: 箭头指向比例环节<br>    % 这样做是为了让箭头出现在入口处而不是转角处<br>    <br>    % 分支点到积分环节（水平直线）<br>    \draw[-&gt;] (branch1) -- (integral.west);<br>    % 从分支点直接画箭头到积分环节左侧<br>    % 因为在同一水平线上，所以是直线<br>    <br>    % 分支点到微分环节（先竖直后水平）<br>    \draw (branch1) |- (diff.west);<br>    % 从分支点到微分环节，先竖直下降再水平到达<br>    <br>    \draw[-&gt;] ([xshift=-<span class="hljs-number">0.3</span>cm]diff.west) -- (diff.west);<br>    % 在微分环节入口处添加箭头<br>    <br>    % 比例环节到求和器<span class="hljs-number">2</span>（先水平后竖直）<br>    \coordinate (prop-corner) at ([xshift=<span class="hljs-number">2.3</span>cm]prop.east);<br>    % 定义比例环节输出的转角点：<br>    % (prop-corner): 命名为prop-corner<br>    % at ([xshift=<span class="hljs-number">2.3</span>cm]prop.east): 在prop右侧向右<span class="hljs-number">2.3</span>cm处<br>    <br>    \draw (prop.east) -- (prop-corner);<br>    % 从比例环节右侧画线到转角点（水平线）<br>    <br>    \draw[-&gt;] (prop-corner) |- (sum2.north);<br>    % 从转角点画线到sum2的北侧（上方）：<br>    % |-: 先竖直后水平到达（这里是竖直下降）<br>    % 箭头指向sum2的上方入口<br>    <br>    % 积分环节到求和器<span class="hljs-number">2</span>（水平直线）<br>    \draw[-&gt;] (integral.east) -- (sum2.west);<br>    % 从积分环节右侧直接画箭头到sum2左侧<br>    % 在同一水平线上<br>    <br>    % 微分环节到求和器<span class="hljs-number">2</span>（先水平后竖直）<br>    \coordinate (diff-corner) at ([xshift=<span class="hljs-number">2.3</span>cm]diff.east);<br>    % 定义微分环节输出的转角点<br>    <br>    \draw (diff.east) -- (diff-corner);<br>    % 从微分环节右侧画线到转角点（水平线）<br>    <br>    \draw[-&gt;] (diff-corner) |- (sum2.south);<br>    % 从转角点画线到sum2的南侧（下方）<br>    % 竖直上升后到达sum2下方入口<br>    <br>    % 求和器<span class="hljs-number">2</span>到系统，标注u(t)<br>    \draw[-&gt;] (sum2.east) -- (system.west) node[pos=<span class="hljs-number">0.5</span>, above, font=\small] &#123;$u(t)$&#125;;<br>    % 从sum2右侧画箭头到system左侧<br>    % 在中点上方标注u(t)<br>    <br>    % 系统到输出<br>    \draw[-&gt;] (system.east) -- (output);<br>    % 从system右侧画箭头到output节点<br>    <br>    % 反馈线 - 横平竖直<br>    \coordinate (fb-right) at ([xshift=1cm]system.east);<br>    % 定义反馈线的第一个转角点：<br>    % (fb-right): 命名为fb-right<br>    % at ([xshift=1cm]system.east): 在system右侧向右1cm处<br>    <br>    \coordinate (fb-bottom) at (fb-right |- <span class="hljs-number">0</span>,-<span class="hljs-number">4</span>);<br>    % 定义反馈线底部的点：<br>    % (fb-bottom): 命名为fb-bottom<br>    % at (fb-right |- <span class="hljs-number">0</span>,-<span class="hljs-number">4</span>): 使用垂直投影语法<br>    %   x坐标与fb-right相同，y坐标为-<span class="hljs-number">4</span><br>    %   这样确保竖直下降<br>    <br>    \coordinate (fb-left) at (sum1.south |- fb-bottom);<br>    % 定义反馈线左侧的转角点：<br>    % (fb-left): 命名为fb-left<br>    % at (sum1.south |- fb-bottom): <br>    %   x坐标与sum1.south相同，y坐标与fb-bottom相同<br>    %   这样确保水平线对齐<br>    <br>    \draw (output) -- (fb-right);<br>    % 从output画线到第一个转角点（水平线）<br>    <br>    \draw (fb-right) -- (fb-bottom);<br>    % 从第一个转角点画线到底部（竖直线）<br>    <br>    \draw (fb-bottom) -- (fb-left);<br>    % 从底部画线到左侧转角点（水平线）<br>    <br>    \draw[-&gt;] (fb-left) -- (sum1.south);<br>    % 从左侧转角点画箭头到sum1的南侧（下方）<br>    % 竖直上升，箭头指向sum1<br>    <br>    % 求和器的加减号<br>    \node[font=\scriptsize] at ($(sum1.north west)+(<span class="hljs-number">0.15</span>,-<span class="hljs-number">0.15</span>)$) &#123;$+$&#125;;<br>    % 在sum1的西北角内侧位置添加加号：<br>    % [font=\scriptsize]: 字体为scriptsize（很小）<br>    % at ($(sum1.north west)+(<span class="hljs-number">0.15</span>,-<span class="hljs-number">0.15</span>)$): 使用calc库计算坐标<br>    %   $(...)$: calc语法<br>    %   sum1.north west: sum1的西北角（左上角）<br>    %   +(<span class="hljs-number">0.15</span>,-<span class="hljs-number">0.15</span>): 向右<span class="hljs-number">0.15</span>，向下<span class="hljs-number">0.15</span><br>    <br>    \node[font=\scriptsize] at ($(sum1.south west)+(<span class="hljs-number">0.15</span>,<span class="hljs-number">0.15</span>)$) &#123;$-$&#125;;<br>    % 在sum1的西南角内侧位置添加减号<br>    % 向右<span class="hljs-number">0.15</span>，向上<span class="hljs-number">0.15</span><br>    <br>    \node[font=\scriptsize] at ($(sum2.north)+(<span class="hljs-number">0</span>,<span class="hljs-number">0.15</span>)$) &#123;$+$&#125;;<br>    % 在sum2的正上方内侧添加加号<br>    % 向下<span class="hljs-number">0.15</span>（进入圆内）<br>    <br>    \node[font=\scriptsize] at ($(sum2.west)+(<span class="hljs-number">0.2</span>,<span class="hljs-number">0</span>)$) &#123;$+$&#125;;<br>    % 在sum2的正左侧内侧添加加号<br>    % 向右<span class="hljs-number">0.2</span>（进入圆内）<br>    <br>    \node[font=\scriptsize] at ($(sum2.south)+(<span class="hljs-number">0</span>,-<span class="hljs-number">0.15</span>)$) &#123;$+$&#125;;<br>    % 在sum2的正下方内侧添加加号<br>    % 向上<span class="hljs-number">0.15</span>（进入圆内，用负值表示向下移动-<span class="hljs-number">0.15</span>）<br>    <br>    % 底部说明文字 - 居中显示<br>    \coordinate (center) at (<span class="hljs-number">6</span>,<span class="hljs-number">0</span>);  <br>    % 定义图形的中心点坐标：<br>    % (center): 命名为center<br>    % at (<span class="hljs-number">6</span>,<span class="hljs-number">0</span>): 大致在整个图形的水平中央<br>    <br>    \node[below=<span class="hljs-number">4.8</span>cm of center, font=\small] (labels) &#123;<br>        % 创建说明文字节点：<br>        % below=<span class="hljs-number">4.8</span>cm of center: 在center点下方<span class="hljs-number">4.8</span>cm处<br>        % [font=\small]: 字体大小为small<br>        % (labels): 命名为labels<br>        <br>        $r(t) = \text&#123;System Setpoint&#125;$ \qquad<br>        % 第一项说明<br>        % \qquad: 添加较大的水平间距<br>        <br>        $e(t) = \text&#123;Error Signal&#125;$ \qquad<br>        % 第二项说明<br>        <br>        $u(t) = \text&#123;Control Signal&#125;$ \qquad<br>        % 第三项说明<br>        <br>        $y(t) = \text&#123;System Output&#125;$<br>        % 第四项说明<br>    &#125;;<br>    % 所有说明文字在一个节点中，自动居中对齐<br><br>\end&#123;tikzpicture&#125;<br></code></pre></td></tr></table></figure><p>运行效果 <img src="f5.png" alt="regular" /></p><h2 id="例-6">例 6</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><code class="hljs python">\usetikzlibrary&#123;shapes,arrows,positioning,calc&#125;<br>% 加载 TikZ 的几个库：<br>%   shapes     ：提供各种形状（矩形、圆、椭圆等）的高级样式；<br>%   arrows     ：提供箭头样式（latex, stealth 等）；<br>%   positioning：支持相对定位语法，如 right of=...、above of=...；<br>%   calc       ：支持坐标计算，如 ($(A)+(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)$)。<br><br>\tikzset&#123;<br>    block/.style = &#123;draw, fill=white, rectangle, minimum height=3em, minimum width=3em&#125;,<br>    % 定义一个通用样式 block：<br>    %   draw           ：画出边框；<br>    %   fill=white     ：内部填充为白色；<br>    %   rectangle      ：矩形形状；<br>    %   minimum height  ：最小高度 3em；<br>    %   minimum width   ：最小宽度 3em。<br>    % 以后写 [block] 就等价于使用这些属性。<br>    tmp/.style  = &#123;coordinate&#125;, <br>    % 定义 tmp 样式为 coordinate 类型：<br>    %   这种节点本身没有可见形状，只是用来当“坐标点/连接点”。<br>    <span class="hljs-built_in">sum</span>/.style= &#123;draw, fill=white, circle, node distance=1cm&#125;,<br>    % 定义 <span class="hljs-built_in">sum</span> 样式：<br>    %   画边框 draw；<br>    %   填充白色 fill=white；<br>    %   circle：圆形节点；<br>    %   node distance=1cm：默认节点间距 1cm（供 positioning 库用）。<br>    <span class="hljs-built_in">input</span>/.style = &#123;coordinate&#125;,<br>    % <span class="hljs-built_in">input</span> 样式：仅仅是一个坐标点，用来当输入端。<br>    output/.style= &#123;coordinate&#125;,<br>    % output 样式：同上，用来当输出端。<br>    pinstyle/.style = &#123;pin edge=&#123;to-,thin,black&#125;<br>    % pinstyle 样式：用于带 pin 的节点时，pin 连接线使用 “to-” 线型、细线、黑色。<br>    % 本段代码中没真正用到 pinstyle，但预定义了一个方便以后使用的样式。<br>    &#125;<br>&#125;<br><br><br>\begin&#123;tikzpicture&#125;[auto, node distance=2cm,&gt;=latex<span class="hljs-string">&#x27;]</span><br><span class="hljs-string">% 开始 tikzpicture 环境。</span><br><span class="hljs-string">% 选项：</span><br><span class="hljs-string">%   auto             ：自动选择边上标签的方向（上/下/左/右）；</span><br><span class="hljs-string">%   node distance=2cm：默认节点之间的距离为 2cm（给 positioning 库用）；</span><br><span class="hljs-string">%   &gt;=latex&#x27;</span>         ：箭头默认使用 latex<span class="hljs-string">&#x27; 样式（LaTeX 风格的箭头）。</span><br><span class="hljs-string"></span><br><span class="hljs-string">    \node [input, name=rinput] (rinput) &#123;&#125;;</span><br><span class="hljs-string">    % 定义一个 input 类型的节点：</span><br><span class="hljs-string">    %   样式为 [input]（即 coordinate），所以是一个“不可见点”；</span><br><span class="hljs-string">    %   name=rinput（可选）和 (rinput) 都给它取名为 rinput，方便后续引用；</span><br><span class="hljs-string">    %   花括号 &#123;&#125; 中无内容，所以不显示文字。</span><br><span class="hljs-string">    %   这是整个框图最左边的输入坐标。</span><br><span class="hljs-string"></span><br><span class="hljs-string">    \node [sum, right of=rinput] (sum1) &#123;&#125;;</span><br><span class="hljs-string">    % 定义一个 sum 节点（圆形求和点）：</span><br><span class="hljs-string">    %   位置：right of=rinput，表示在 rinput 右侧，距离由 node distance 控制（2cm）；</span><br><span class="hljs-string">    %   名字为 sum1；</span><br><span class="hljs-string">    %   内容为空，所以只是一个空圆圈（可以在上面叠加 +, - 等符号）。</span><br><span class="hljs-string"></span><br><span class="hljs-string">    \node [block, right of=sum1] (controller) &#123;$k_&#123;p\beta&#125;$&#125;;</span><br><span class="hljs-string">    % 定义一个 block 节点（矩形）：</span><br><span class="hljs-string">    %   在 sum1 右侧（2cm）；</span><br><span class="hljs-string">    %   名字 controller；</span><br><span class="hljs-string">    %   内部文字为 $k_&#123;p\beta&#125;$，表示比例环节。</span><br><span class="hljs-string"></span><br><span class="hljs-string">    \node [block, above of=controller,node distance=1.3cm] (up)&#123;$\frac&#123;k_&#123;i\beta&#125;&#125;&#123;s&#125;$&#125;;</span><br><span class="hljs-string">    % 定义一个 block 节点：</span><br><span class="hljs-string">    %   在 controller 正上方 1.3cm 处（覆盖默认 node distance）；</span><br><span class="hljs-string">    %   名字 up；</span><br><span class="hljs-string">    %   内部文字为积分环节：k_&#123;iβ&#125;/s。</span><br><span class="hljs-string"></span><br><span class="hljs-string">    \node [block, below of=controller,node distance=1.3cm] (rate) &#123;$sk_&#123;d\beta&#125;$&#125;;</span><br><span class="hljs-string">    % 定义一个 block 节点：</span><br><span class="hljs-string">    %   在 controller 正下方 1.3cm 处；</span><br><span class="hljs-string">    %   名字 rate；</span><br><span class="hljs-string">    %   内部文字为微分环节：s k_&#123;dβ&#125;。</span><br><span class="hljs-string"></span><br><span class="hljs-string">    \node [sum, right of=controller,node distance=2cm] (sum2) &#123;&#125;;</span><br><span class="hljs-string">    % 在 controller 右侧 2cm 处定义第二个求和节点 sum2（圆）。</span><br><span class="hljs-string"></span><br><span class="hljs-string">    \node [block, above = 2cm of sum2](extra)&#123;$\frac&#123;1&#125;&#123;\alpha_&#123;\beta2&#125;&#125;$&#125;;  %</span><br><span class="hljs-string">    % 在 sum2 上方 2cm 处定义一个额外的 block：</span><br><span class="hljs-string">    %   名字 extra；</span><br><span class="hljs-string">    %   内部为 1/α_&#123;β2&#125;，表示某个额外模块/通道对 sum2 的输入。</span><br><span class="hljs-string"></span><br><span class="hljs-string">    \node [block, right of=sum2,node distance=2cm] (system) </span><br><span class="hljs-string">&#123;$\frac&#123;a_&#123;\beta 2&#125;&#125;&#123;s+a_&#123;\beta 1&#125;&#125;$&#125;;</span><br><span class="hljs-string">    % 在 sum2 右侧 2cm 处定义被控对象模块 system：</span><br><span class="hljs-string">    %   传递函数为 a_&#123;β2&#125;/(s + a_&#123;β1&#125;)。</span><br><span class="hljs-string"></span><br><span class="hljs-string">    \node [output, right of=system, node distance=2cm] (output) &#123;&#125;;</span><br><span class="hljs-string">    % 在 system 右侧 2cm 处定义输出坐标节点 output（不可见坐标点）。</span><br><span class="hljs-string"></span><br><span class="hljs-string">    \node [tmp, below of=controller] (tmp1)&#123;$H(s)$&#125;;</span><br><span class="hljs-string">    % 在 controller 下方（默认节点距离 2cm）定义一个 tmp 节点 tmp1：</span><br><span class="hljs-string">    %   样式是 coordinate（不可见），但这里在花括号里写了 $H(s)$，</span><br><span class="hljs-string">    %   所以会在这个位置显示文字 H(s)；</span><br><span class="hljs-string">    %   通常用来标注反馈路径的传递函数 H(s)。</span><br><span class="hljs-string"></span><br><span class="hljs-string">    \draw [-&gt;] (rinput) -- node&#123;$R(s)$&#125; (sum1);</span><br><span class="hljs-string">    % 从 rinput 到 sum1 画一条带箭头的连线：</span><br><span class="hljs-string">    %   在线的中间加一个 node，内容为 R(s)，表示参考输入信号 R(s)。</span><br><span class="hljs-string"></span><br><span class="hljs-string">    \draw [-&gt;] (sum1) --node[name=z,anchor=north]&#123;$E(s)$&#125; (controller);</span><br><span class="hljs-string">    % 从 sum1 到 controller 画箭头：</span><br><span class="hljs-string">    %   在线段中添加一个 node：</span><br><span class="hljs-string">    %     name=z     ：这个标签节点命名为 z，后面可以拿它当“坐标”使用；</span><br><span class="hljs-string">    %     anchor=north：z 这个 node 的北侧锚点贴在线上（让文字在下面）；</span><br><span class="hljs-string">    %     内容为 E(s)，表示误差信号 E(s)。</span><br><span class="hljs-string"></span><br><span class="hljs-string">    \draw [-&gt;] (controller) -- (sum2);</span><br><span class="hljs-string">    % 从比例通道 controller 输出到 sum2 的主通道箭头。</span><br><span class="hljs-string"></span><br><span class="hljs-string">    \draw [-&gt;] (sum2) -- node&#123;$U(s)$&#125; (system);</span><br><span class="hljs-string">    % 从 sum2 到 system 的箭头：</span><br><span class="hljs-string">    %   在线的中间加文字 U(s)，表示控制信号 U(s)。</span><br><span class="hljs-string"></span><br><span class="hljs-string">    \draw [-&gt;] (system) -- node [name=y] &#123;$Y(s)$&#125;(output);</span><br><span class="hljs-string">    % 从 system 到 output 的箭头：</span><br><span class="hljs-string">    %   在线中间加 node，名字为 y，内容为 Y(s)，表示输出信号；</span><br><span class="hljs-string">    %   之后会用 (y) 作为反馈回路的起点。</span><br><span class="hljs-string"></span><br><span class="hljs-string">    \draw [-&gt;] (z) |- (rate);</span><br><span class="hljs-string">    % 从标签节点 z（即 E(s) 那个标签的坐标）出发：</span><br><span class="hljs-string">    %   使用 |- 路径语法：先竖直再水平拐弯，</span><br><span class="hljs-string">    %   画到 rate（微分通道）；</span><br><span class="hljs-string">    %   表示误差信号 E(s) 同时送入微分支路。</span><br><span class="hljs-string"></span><br><span class="hljs-string">    \draw [-&gt;] (rate) -| (sum2);</span><br><span class="hljs-string">    % 从 rate 输出到 sum2：</span><br><span class="hljs-string">    %   使用 -|：先水平再竖直拐弯，接入 sum2；</span><br><span class="hljs-string">    %   表示微分支路的输出与主通道在 sum2 汇总。</span><br><span class="hljs-string"></span><br><span class="hljs-string">    \draw [-&gt;] (z) |- (up);</span><br><span class="hljs-string">    % 从 E(s) 标签（z）到积分通道 up：</span><br><span class="hljs-string">    %   E(s) 同时送入积分支路。</span><br><span class="hljs-string"></span><br><span class="hljs-string">    \draw [-&gt;] (up) -| (sum2);</span><br><span class="hljs-string">    % 从积分支路 up 输出回到 sum2 相加。</span><br><span class="hljs-string"></span><br><span class="hljs-string">    \draw [-&gt;] (y) |- (tmp1)-| node[pos=0.99] &#123;$-$&#125; (sum1);</span><br><span class="hljs-string">    % 从输出标签 y（即 Y(s) 的位置）出发：</span><br><span class="hljs-string">    %   |- 到 tmp1：先竖直再水平拐弯，达到 H(s) 标注的位置；</span><br><span class="hljs-string">    %   再 -| 到 sum1：从 tmp1 绕回 sum1，下侧形成反馈闭环；</span><br><span class="hljs-string">    %   在这条路径上，用 node[pos=0.99] &#123;$-$&#125; 在接近终点的位置标一个减号“−”，</span><br><span class="hljs-string">    %   表示在 sum1 处是负反馈（反馈信号带负号）。</span><br><span class="hljs-string"></span><br><span class="hljs-string">    \draw [-&gt;] (extra)--(sum2);</span><br><span class="hljs-string">    % 从 extra 模块（1/α_&#123;β2&#125;）输出到 sum2：</span><br><span class="hljs-string">    %   表示一个外部输入 d_&#123;β2&#125; 经过 extra 后也加到 sum2 中。</span><br><span class="hljs-string"></span><br><span class="hljs-string">    \draw [-&gt;] ($(0,1.5cm)+(extra)$)node[above]&#123;$d_&#123;\beta 2&#125;$&#125; -- (extra);</span><br><span class="hljs-string">    % 使用 calc 库的坐标计算：</span><br><span class="hljs-string">    %   $(extra)$ 表示 extra 节点的坐标；</span><br><span class="hljs-string">    %   $(0,1.5cm)+(extra)$ 表示在 extra 上方 1.5cm 的位置；</span><br><span class="hljs-string">    %   从这个上方的点画一条箭头指向 extra。</span><br><span class="hljs-string">    % 在线段起点处放置一个 node[above]&#123;$d_&#123;\beta 2&#125;$&#125;：</span><br><span class="hljs-string">    %   文字 d_&#123;β2&#125; 显示在这条箭的上方，表示外部扰动/输入 d_&#123;β2&#125;。</span><br><span class="hljs-string"></span><br><span class="hljs-string">\end&#123;tikzpicture&#125;</span><br><span class="hljs-string">% 结束整个控制框图的绘制。</span><br></code></pre></td></tr></table></figure><p>运行效果 <img src="f6.png" alt="regular" /></p>]]></content>
    
    
    <categories>
      
      <category>code</category>
      
      <category>LaTex</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LaTex</tag>
      
      <tag>TikZ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pytorch 系列 - 3. MINIST 数据</title>
    <link href="/2025/11/14/code/Pytorch/pytorch_3-MINIST-2025_11_14/"/>
    <url>/2025/11/14/code/Pytorch/pytorch_3-MINIST-2025_11_14/</url>
    
    <content type="html"><![CDATA[<h1 id="pytorch-系列---3.-利用-cnn-搭建-mnist-手写数字识别系统">Pytorch 系列 - 3. 利用 CNN 搭建 MNIST 手写数字识别系统</h1><h2 id="引言">引言</h2><p>手写数字识别是深度学习领域的 “Hello World” 项目，也是计算机视觉入门的最佳实践。本文将详细解析一个完整的MNIST手写数字识别项目，从数据加载、模型构建、训练优化到性能评估，全面掌握CNN图像分类的核心技术。</p><h2 id="目录">目录</h2><ol type="1"><li>MNIST数据集详解</li><li>数据预处理与增强</li><li>CNN网络架构设计</li><li>训练流程与优化策略</li><li>模型评估与可视化</li><li>常见问题与优化建议</li></ol><hr /><h2 id="一mnist数据集详解">一、MNIST数据集详解</h2><h3 id="什么是mnist">1.1 什么是MNIST？</h3><p>MNIST（Modified National Institute of Standards and Technology）是机器学习领域最著名的数据集之一，包含70,000张手写数字图像：</p><p><span class="math display">\[ \varphi = 1+\frac{1} {1+\frac{1} {1+\frac{1} {1+\cdots} } }\]</span></p><ul><li><strong>训练集</strong>：60,000张图像</li><li><strong>测试集</strong>：10,000张图像</li><li><strong>图像尺寸</strong>：28×28像素的灰度图</li><li><strong>类别数量</strong>：10类（数字0-9）</li></ul><figure><img src="MINIST.png" alt="regular" /><figcaption aria-hidden="true">regular</figcaption></figure><h3 id="使用torchvision加载数据">1.2 使用torchvision加载数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> datasets, transforms<br><br><span class="hljs-comment"># 下载并加载MNIST数据集</span><br>mnist_train = datasets.MNIST(<br>    root=<span class="hljs-string">&quot;./dataset&quot;</span>,<br>    train=<span class="hljs-literal">True</span>,<br>    download=<span class="hljs-literal">True</span>,<br>    transform=transforms.ToTensor()<br>)<br></code></pre></td></tr></table></figure><p><strong>关键参数说明</strong>：</p><ul><li><code>root</code>：数据存储路径，会自动创建MNIST子目录</li><li><code>train</code>：True加载训练集，False加载测试集</li><li><code>download</code>：首次运行时自动从网络下载</li><li><code>transform</code>：数据转换操作，这里将PIL图像转为Tensor</li></ul><p><strong>数据存储结构</strong>： <figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nix">.<span class="hljs-operator">/</span>dataset<span class="hljs-symbol">/</span><br>└── MNIST<span class="hljs-symbol">/</span><br>    ├── raw<span class="hljs-symbol">/</span>          <span class="hljs-comment"># 原始.gz压缩文件</span><br>    └── processed<span class="hljs-symbol">/</span>    <span class="hljs-comment"># 处理后的.pt缓存文件</span><br></code></pre></td></tr></table></figure></p><h3 id="dataloader高效的数据加载器">1.3 DataLoader：高效的数据加载器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> DataLoader<br><br>train_loader = DataLoader(<br>    dataset=train_dataset,<br>    batch_size=<span class="hljs-number">64</span>,<br>    shuffle=<span class="hljs-literal">True</span>,<br>    num_workers=<span class="hljs-number">0</span><br>)<br></code></pre></td></tr></table></figure><p><strong>DataLoader的作用</strong>：</p><ol type="1"><li><strong>批处理</strong>（Batching）：将样本组织成批次，提高GPU利用率</li><li><strong>打乱</strong>（Shuffling）：随机化训练顺序，避免模型记忆样本顺序</li><li><strong>并行加载</strong>（Multi-processing）：通过num_workers加速数据读取</li></ol><p><strong>最佳实践</strong>： - 训练集：<code>shuffle=True</code>，打破样本相关性 - 测试集：<code>shuffle=False</code>，保持评估一致性 - <code>batch_size</code>：根据显存调整，常用32/64/128 - <code>num_workers</code>：Windows建议0，Linux/Mac可设为4-8</p><hr /><h2 id="二数据预处理与标准化">二、数据预处理与标准化</h2><h3 id="为什么需要数据预处理">2.1 为什么需要数据预处理？</h3><p>原始图像像素值范围是[0, 255]，直接输入神经网络会导致：</p><ol type="1"><li><strong>梯度爆炸/消失</strong>：数值过大导致梯度不稳定</li><li><strong>收敛缓慢</strong>：不同特征量级差异大，优化困难</li><li><strong>激活函数饱和</strong>：超出激活函数有效区间</li></ol><h3 id="标准化流程">2.2 标准化流程</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">transform = transforms.Compose([<br>    transforms.ToTensor(),                              <span class="hljs-comment"># 步骤1</span><br>    transforms.Normalize(mean=(<span class="hljs-number">0.1307</span>,), std=(<span class="hljs-number">0.3081</span>,)) <span class="hljs-comment"># 步骤2</span><br>])<br></code></pre></td></tr></table></figure><p><strong>步骤1：ToTensor()</strong> - 将PIL图像/NumPy数组转为PyTorch张量 - 形状变换：[H, W, C] → [C, H, W] - 像素归一化：[0, 255] → [0, 1]</p><p><strong>步骤2：Normalize()</strong> - 公式：<code>output = (input - mean) / std</code> - MNIST的全局统计值： - 均值（mean）= 0.1307 - 标准差（std）= 0.3081 - 结果：数据分布近似标准正态分布N(0, 1)</p><h3 id="标准化的数学原理">2.3 标准化的数学原理</h3><p>对于每个像素值 <span class="math inline">\(x\)</span>，标准化操作为：</p><p><span class="math display">\[x_{normalized} = \frac{x - \mu}{\sigma}\]</span></p><p>其中 <span class="math inline">\(\mu\)</span> 是均值，<span class="math inline">\(\sigma\)</span> 是标准差。标准化后的数据具有： - 均值为0 - 标准差为1 - 消除量纲影响</p><p><strong>为什么使用0.1307和0.3081？</strong></p><p>这两个值是通过计算整个MNIST训练集的全局均值和标准差得到的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 计算MNIST训练集的全局统计值</span><br>mean = train_data.mean() / <span class="hljs-number">255.0</span>  <span class="hljs-comment"># ≈ 0.1307</span><br>std = train_data.std() / <span class="hljs-number">255.0</span>    <span class="hljs-comment"># ≈ 0.3081</span><br></code></pre></td></tr></table></figure><hr /><h2 id="三cnn网络架构设计">三、CNN网络架构设计</h2><h3 id="卷积神经网络基础">3.1 卷积神经网络基础</h3><p>卷积神经网络（CNN）是专门处理图像数据的深度学习架构，主要由以下组件构成：</p><ol type="1"><li><strong>卷积层</strong>（Convolutional Layer）：特征提取</li><li><strong>激活函数</strong>（Activation）：引入非线性</li><li><strong>池化层</strong>（Pooling Layer）：降维与特征选择</li><li><strong>全连接层</strong>（Fully Connected Layer）：分类决策</li></ol><h3 id="模型架构详解">3.2 模型架构详解</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MNIST_CNN</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(MNIST_CNN, <span class="hljs-variable language_">self</span>).__init__()<br>        <br>        <span class="hljs-comment"># 第一卷积模块</span><br>        <span class="hljs-variable language_">self</span>.conv1 = nn.Sequential(<br>            nn.Conv2d(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, kernel_size=<span class="hljs-number">5</span>),<br>            nn.ReLU(),<br>            nn.MaxPool2d(kernel_size=<span class="hljs-number">2</span>)<br>        )<br>        <br>        <span class="hljs-comment"># 第二卷积模块</span><br>        <span class="hljs-variable language_">self</span>.conv2 = nn.Sequential(<br>            nn.Conv2d(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, kernel_size=<span class="hljs-number">5</span>),<br>            nn.ReLU(),<br>            nn.MaxPool2d(kernel_size=<span class="hljs-number">2</span>)<br>        )<br>        <br>        <span class="hljs-comment"># 全连接模块</span><br>        <span class="hljs-variable language_">self</span>.fc = nn.Sequential(<br>            nn.Flatten(),<br>            nn.Linear(<span class="hljs-number">320</span>, <span class="hljs-number">50</span>),<br>            nn.Linear(<span class="hljs-number">50</span>, <span class="hljs-number">10</span>)<br>        )<br></code></pre></td></tr></table></figure><h3 id="特征图尺寸计算">3.3 特征图尺寸计算</h3><p><strong>输入层</strong>：<code>[batch_size, 1, 28, 28]</code></p><p><strong>第一卷积模块</strong>： - Conv2d(1→10, 5×5)：<code>[B, 1, 28, 28]</code> → <code>[B, 10, 24, 24]</code> - 计算公式：<span class="math inline">\(H_{out} = H_{in} - kernel\_size + 1 = 28 - 5 + 1 = 24\)</span> - MaxPool2d(2×2)：<code>[B, 10, 24, 24]</code> → <code>[B, 10, 12, 12]</code> - 每个维度缩小一半：<span class="math inline">\(24 \div 2 = 12\)</span></p><p><strong>第二卷积模块</strong>： - Conv2d(10→20, 5×5)：<code>[B, 10, 12, 12]</code> → <code>[B, 20, 8, 8]</code> - <span class="math inline">\(H_{out} = 12 - 5 + 1 = 8\)</span> - MaxPool2d(2×2)：<code>[B, 20, 8, 8]</code> → <code>[B, 20, 4, 4]</code> - <span class="math inline">\(8 \div 2 = 4\)</span></p><p><strong>全连接层</strong>： - Flatten：<code>[B, 20, 4, 4]</code> → <code>[B, 320]</code> - <span class="math inline">\(20 \times 4 \times 4 = 320\)</span> - Linear(320→50)：<code>[B, 320]</code> → <code>[B, 50]</code> - Linear(50→10)：<code>[B, 50]</code> → <code>[B, 10]</code></p><p><strong>输出层</strong>：<code>[batch_size, 10]</code>，10个logits对应10个类别</p><h3 id="关键层详解">3.4 关键层详解</h3><h4 id="卷积层conv2d">卷积层（Conv2d）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">nn.Conv2d(in_channels, out_channels, kernel_size)<br></code></pre></td></tr></table></figure><p><strong>作用</strong>：通过卷积核滑动提取局部特征</p><p><strong>参数</strong>： - <code>in_channels</code>：输入通道数（灰度图=1，RGB=3） - <code>out_channels</code>：输出通道数（特征图数量） - <code>kernel_size</code>：卷积核大小（常用3×3, 5×5）</p><p><strong>特点</strong>： - 局部连接：只关注局部区域 - 权重共享：同一卷积核扫描整个图像 - 参数量：<span class="math inline">\(kernel\_size^2 \times in\_channels \times out\_channels\)</span></p><h4 id="激活函数relu">激活函数（ReLU）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">nn.ReLU()<br></code></pre></td></tr></table></figure><p><strong>公式</strong>：<span class="math inline">\(ReLU(x) = max(0, x)\)</span></p><p><strong>优点</strong>： - 计算简单，训练速度快 - 缓解梯度消失问题 - 引入非线性，增强模型表达能力</p><h4 id="池化层maxpool2d">池化层（MaxPool2d）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">nn.MaxPool2d(kernel_size=<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p><strong>作用</strong>： - 降低特征图空间维度 - 减少参数量和计算量 - 提供平移不变性</p><p><strong>MaxPooling vs AvgPooling</strong>： - MaxPooling：取区域最大值，保留显著特征 - AvgPooling：取区域平均值，保留整体信息</p><hr /><h2 id="四训练流程与优化策略">四、训练流程与优化策略</h2><h3 id="完整训练流程">4.1 完整训练流程</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">train</span>(<span class="hljs-params">model, train_loader, optimizer, epoch</span>):<br>    model.train()  <span class="hljs-comment"># 设置为训练模式</span><br>    <br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(epoch):<br>        <span class="hljs-keyword">for</span> batch_idx, data <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(train_loader):<br>            <span class="hljs-comment"># 1. 数据加载</span><br>            inputs, labels = data[<span class="hljs-number">0</span>].to(device), data[<span class="hljs-number">1</span>].to(device)<br>            <br>            <span class="hljs-comment"># 2. 清零梯度</span><br>            optimizer.zero_grad()<br>            <br>            <span class="hljs-comment"># 3. 前向传播</span><br>            outputs = model(inputs)<br>            <br>            <span class="hljs-comment"># 4. 计算损失</span><br>            loss = criterion(outputs, labels)<br>            <br>            <span class="hljs-comment"># 5. 反向传播</span><br>            loss.backward()<br>            <br>            <span class="hljs-comment"># 6. 参数更新</span><br>            optimizer.step()<br></code></pre></td></tr></table></figure><h3 id="训练循环关键步骤">4.2 训练循环关键步骤</h3><h4 id="步骤1数据加载">步骤1：数据加载</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">inputs, labels = data[<span class="hljs-number">0</span>].to(device), data[<span class="hljs-number">1</span>].to(device)<br></code></pre></td></tr></table></figure><ul><li><code>data</code>是DataLoader返回的元组：(图像, 标签)</li><li><code>.to(device)</code>：将数据移动到GPU/CPU</li></ul><h4 id="步骤2清零梯度">步骤2：清零梯度</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">optimizer.zero_grad()<br></code></pre></td></tr></table></figure><p><strong>为什么需要？</strong></p><p>PyTorch默认会累积梯度，如果不清零： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 第一次backward</span><br>loss1.backward()  <span class="hljs-comment"># grad = grad1</span><br><br><span class="hljs-comment"># 第二次backward（未清零）</span><br>loss2.backward()  <span class="hljs-comment"># grad = grad1 + grad2  ❌错误！</span><br></code></pre></td></tr></table></figure></p><p>正确做法： <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">optimizer.zero_grad()  <span class="hljs-comment"># grad = 0</span><br>loss.backward()        <span class="hljs-comment"># grad = grad_new ✓</span><br></code></pre></td></tr></table></figure></p><h4 id="步骤3-4前向传播与损失计算">步骤3-4：前向传播与损失计算</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">outputs = model(inputs)         <span class="hljs-comment"># 前向传播</span><br>loss = criterion(outputs, labels)  <span class="hljs-comment"># 计算损失</span><br></code></pre></td></tr></table></figure><p><strong>CrossEntropyLoss详解</strong>：</p><p><span class="math display">\[Loss = -\sum_{i=1}^{C} y_i \log(\hat{y}_i)\]</span></p><p>其中： - <span class="math inline">\(y_i\)</span>：真实标签的one-hot编码 - <span class="math inline">\(\hat{y}_i\)</span>：经过softmax的预测概率</p><p><strong>内部实现</strong>： 1. 对logits应用softmax：<span class="math inline">\(\hat{y}_i = \frac{e^{z_i}}{\sum_{j=1}^{C} e^{z_j}}\)</span> 2. 计算负对数似然损失</p><h4 id="步骤5-6反向传播与参数更新">步骤5-6：反向传播与参数更新</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">loss.backward()    <span class="hljs-comment"># 反向传播：计算梯度</span><br>optimizer.step()   <span class="hljs-comment"># 参数更新：应用梯度</span><br></code></pre></td></tr></table></figure><p><strong>反向传播原理</strong>：</p><p>通过链式法则计算损失对每个参数的偏导数：</p><p><span class="math display">\[\frac{\partial L}{\partial w} = \frac{\partial L}{\partial y} \cdot \frac{\partial y}{\partial w}\]</span></p><p><strong>参数更新（SGD）</strong>：</p><p><span class="math display">\[w_{new} = w_{old} - \eta \cdot \frac{\partial L}{\partial w}\]</span></p><p>其中 <span class="math inline">\(\eta\)</span> 是学习率（learning rate）</p><h3 id="优化器选择">4.3 优化器选择</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">optimizer = optim.SGD(<br>    model.parameters(),<br>    lr=<span class="hljs-number">0.01</span>,<br>    momentum=<span class="hljs-number">0.9</span><br>)<br></code></pre></td></tr></table></figure><h4 id="sgd-with-momentum">SGD with Momentum</h4><p><strong>标准SGD</strong>： <span class="math display">\[w_{t+1} = w_t - \eta \cdot g_t\]</span></p><p><strong>带动量的SGD</strong>： <span class="math display">\[v_{t+1} = \beta \cdot v_t + g_t\]</span> <span class="math display">\[w_{t+1} = w_t - \eta \cdot v_{t+1}\]</span></p><p><strong>优点</strong>： - 加速收敛：借助历史梯度的“惯性” - 减少震荡：平滑梯度更新方向 - 跳出局部最优：动量帮助越过小的“山谷”</p><h4 id="其他常用优化器">其他常用优化器</h4><table><thead><tr class="header"><th>优化器</th><th>特点</th><th>适用场景</th></tr></thead><tbody><tr class="odd"><td>SGD</td><td>简单稳定</td><td>计算机视觉任务</td></tr><tr class="even"><td>Adam</td><td>自适应学习率</td><td>大多数深度学习任务</td></tr><tr class="odd"><td>AdamW</td><td>Adam + 权重衰减</td><td>Transformer模型</td></tr><tr class="even"><td>RMSprop</td><td>自适应学习率</td><td>RNN任务</td></tr></tbody></table><h3 id="学习率调度">4.4 学习率调度</h3><p>固定学习率可能导致： - 初期：学习率过小，收敛慢 - 后期：学习率过大，无法收敛</p><p><strong>常用策略</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1. 阶梯式衰减</span><br>scheduler = optim.lr_scheduler.StepLR(optimizer, step_size=<span class="hljs-number">30</span>, gamma=<span class="hljs-number">0.1</span>)<br><br><span class="hljs-comment"># 2. 余弦退火</span><br>scheduler = optim.lr_scheduler.CosineAnnealingLR(optimizer, T_max=<span class="hljs-number">100</span>)<br><br><span class="hljs-comment"># 3. 自适应调整</span><br>scheduler = optim.lr_scheduler.ReduceLROnPlateau(optimizer, patience=<span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><hr /><h2 id="五模型评估与可视化">五、模型评估与可视化</h2><h3 id="评估指标体系">5.1 评估指标体系</h3><h4 id="准确率accuracy">准确率（Accuracy）</h4><p><span class="math display">\[Accuracy = \frac{正确预测数}{总样本数}\]</span></p><p><strong>优点</strong>：直观易懂 <strong>缺点</strong>：类别不平衡时会误导</p><h4 id="精确率precision">精确率（Precision）</h4><p><span class="math display">\[Precision = \frac{TP}{TP + FP}\]</span></p><p><strong>含义</strong>：预测为正例中，真正为正例的比例</p><h4 id="召回率recall">召回率（Recall）</h4><p><span class="math display">\[Recall = \frac{TP}{TP + FN}\]</span></p><p><strong>含义</strong>：真实正例中，被正确预测的比例</p><h4 id="f1分数">F1分数</h4><p><span class="math display">\[F1 = 2 \cdot \frac{Precision \times Recall}{Precision + Recall}\]</span></p><p><strong>含义</strong>：精确率和召回率的调和平均</p><h3 id="使用sklearn生成分类报告">5.2 使用sklearn生成分类报告</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> classification_report<br><br><span class="hljs-comment"># 收集预测结果</span><br>y_trues, y_preds = [], []<br>model.<span class="hljs-built_in">eval</span>()<br><span class="hljs-keyword">with</span> torch.no_grad():<br>    <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> test_loader:<br>        x = x.to(device)<br>        logits = model(x)<br>        preds = logits.argmax(dim=<span class="hljs-number">1</span>).cpu()<br>        y_preds.extend(preds.numpy())<br>        y_trues.extend(y.numpy())<br><br><span class="hljs-comment"># 生成报告</span><br><span class="hljs-built_in">print</span>(classification_report(y_trues, y_preds, target_names=classes))<br></code></pre></td></tr></table></figure><p><strong>输出示例</strong>： <figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs crystal">              precision    recall  f1-score   support<br><br>           <span class="hljs-number">0</span>       <span class="hljs-number">0.98</span>      <span class="hljs-number">0.99</span>      <span class="hljs-number">0.99</span>       <span class="hljs-number">980</span><br>           <span class="hljs-number">1</span>       <span class="hljs-number">0.99</span>      <span class="hljs-number">0.99</span>      <span class="hljs-number">0.99</span>      <span class="hljs-number">1135</span><br>           <span class="hljs-number">2</span>       <span class="hljs-number">0.98</span>      <span class="hljs-number">0.97</span>      <span class="hljs-number">0.98</span>      <span class="hljs-number">1032</span><br>           ...<br>    accuracy                           <span class="hljs-number">0.98</span>     <span class="hljs-number">10000</span><br>   <span class="hljs-function"><span class="hljs-keyword">macro</span> <span class="hljs-title">avg</span></span>       <span class="hljs-number">0.98</span>      <span class="hljs-number">0.98</span>      <span class="hljs-number">0.98</span>     <span class="hljs-number">10000</span><br>weighted avg       <span class="hljs-number">0.98</span>      <span class="hljs-number">0.98</span>      <span class="hljs-number">0.98</span>     <span class="hljs-number">10000</span><br></code></pre></td></tr></table></figure></p><h3 id="混淆矩阵可视化">5.3 混淆矩阵可视化</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> confusion_matrix, ConfusionMatrixDisplay<br><br><span class="hljs-comment"># 计算混淆矩阵</span><br>cm = confusion_matrix(y_trues, y_preds)<br><br><span class="hljs-comment"># 可视化</span><br>disp = ConfusionMatrixDisplay(confusion_matrix=cm, display_labels=classes)<br>disp.plot(cmap=plt.cm.Blues)<br>plt.title(<span class="hljs-string">&quot;Confusion Matrix&quot;</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><p><strong>混淆矩阵解读</strong>：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">            预测<br>         <span class="hljs-number"> 0 </span> <span class="hljs-number"> 1 </span> <span class="hljs-number"> 2 </span>  ...<br>真 <span class="hljs-number"> 0 </span>  [950 <span class="hljs-number"> 0 </span> <span class="hljs-number"> 2 </span> ...]<br>实 <span class="hljs-number"> 1 </span>  [<span class="hljs-number"> 0 </span><span class="hljs-number"> 980 </span><span class="hljs-number"> 1 </span> ...]<br>   <span class="hljs-number"> 2 </span>  [<span class="hljs-number"> 3 </span> <span class="hljs-number"> 1 </span><span class="hljs-number"> 970 </span>...]<br>    ...<br></code></pre></td></tr></table></figure><ul><li>对角线：正确预测数量</li><li>非对角线：误分类情况</li><li>行和：每个类别的真实数量</li><li>列和：每个类别的预测数量</li></ul><p><strong>常见误分类分析</strong>： - 数字1和7容易混淆 - 数字4和9容易混淆 - 数字3和8容易混淆</p><h3 id="模型预测流程">5.4 模型预测流程</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">model.<span class="hljs-built_in">eval</span>()  <span class="hljs-comment"># 评估模式</span><br><span class="hljs-keyword">with</span> torch.no_grad():  <span class="hljs-comment"># 不计算梯度</span><br>    outputs = model(inputs)<br>    preds = outputs.argmax(dim=<span class="hljs-number">1</span>)  <span class="hljs-comment"># 取最大概率的类别</span><br></code></pre></td></tr></table></figure><p><strong>为什么需要model.eval()？</strong></p><p>训练模式和评估模式的区别：</p><table><thead><tr class="header"><th>层类型</th><th>训练模式</th><th>评估模式</th></tr></thead><tbody><tr class="odd"><td>Dropout</td><td>随机丢弃神经元</td><td>保留所有神经元</td></tr><tr class="even"><td>BatchNorm</td><td>使用批次统计</td><td>使用全局统计</td></tr><tr class="odd"><td>梯度计算</td><td>开启</td><td>关闭（配合no_grad）</td></tr></tbody></table><hr /><h2 id="六常见问题与优化建议">六、常见问题与优化建议</h2><h3 id="代码中的潜在问题">6.1 代码中的潜在问题</h3><h4 id="问题1全连接层缺少激活函数">问题1：全连接层缺少激活函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 当前代码</span><br><span class="hljs-variable language_">self</span>.fc = nn.Sequential(<br>    nn.Flatten(),<br>    nn.Linear(<span class="hljs-number">320</span>, <span class="hljs-number">50</span>),<br>    nn.Linear(<span class="hljs-number">50</span>, <span class="hljs-number">10</span>)  <span class="hljs-comment"># ❌ 直接输出，缺少激活</span><br>)<br><br><span class="hljs-comment"># 改进版本</span><br><span class="hljs-variable language_">self</span>.fc = nn.Sequential(<br>    nn.Flatten(),<br>    nn.Linear(<span class="hljs-number">320</span>, <span class="hljs-number">50</span>),<br>    nn.ReLU(),          <span class="hljs-comment"># ✓ 添加激活函数</span><br>    nn.Dropout(<span class="hljs-number">0.5</span>),    <span class="hljs-comment"># ✓ 添加Dropout防止过拟合</span><br>    nn.Linear(<span class="hljs-number">50</span>, <span class="hljs-number">10</span>)<br>)<br></code></pre></td></tr></table></figure><h4 id="问题2未创建checkpoints目录">问题2：未创建checkpoints目录</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 训练前添加</span><br><span class="hljs-keyword">import</span> os<br>os.makedirs(<span class="hljs-string">&#x27;./checkpoints&#x27;</span>, exist_ok=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><h4 id="问题3固定学习率">问题3：固定学习率</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 添加学习率调度器</span><br>scheduler = optim.lr_scheduler.StepLR(optimizer, step_size=<span class="hljs-number">30</span>, gamma=<span class="hljs-number">0.1</span>)<br><br><span class="hljs-comment"># 训练循环中</span><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br>    train_one_epoch()<br>    scheduler.step()  <span class="hljs-comment"># 更新学习率</span><br></code></pre></td></tr></table></figure><h3 id="性能优化策略">6.2 性能优化策略</h3><h4 id="数据增强">1. 数据增强</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">transform_train = transforms.Compose([<br>    transforms.RandomRotation(<span class="hljs-number">10</span>),           <span class="hljs-comment"># 随机旋转±10度</span><br>    transforms.RandomAffine(<span class="hljs-number">0</span>, translate=(<span class="hljs-number">0.1</span>, <span class="hljs-number">0.1</span>)),  <span class="hljs-comment"># 随机平移</span><br>    transforms.ToTensor(),<br>    transforms.Normalize((<span class="hljs-number">0.1307</span>,), (<span class="hljs-number">0.3081</span>,))<br>])<br></code></pre></td></tr></table></figure><p><strong>效果</strong>：增加训练样本多样性，提升泛化能力</p><h4 id="批标准化batch-normalization">2. 批标准化（Batch Normalization）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-variable language_">self</span>.conv1 = nn.Sequential(<br>    nn.Conv2d(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, kernel_size=<span class="hljs-number">5</span>),<br>    nn.BatchNorm2d(<span class="hljs-number">10</span>),  <span class="hljs-comment"># 添加BN层</span><br>    nn.ReLU(),<br>    nn.MaxPool2d(kernel_size=<span class="hljs-number">2</span>)<br>)<br></code></pre></td></tr></table></figure><p><strong>优点</strong>： - 加速训练 - 允许更大学习率 - 减少对初始化的依赖</p><h4 id="残差连接resnet思想">3. 残差连接（ResNet思想）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ResBlock</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, channels</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        <span class="hljs-variable language_">self</span>.conv = nn.Sequential(<br>            nn.Conv2d(channels, channels, <span class="hljs-number">3</span>, padding=<span class="hljs-number">1</span>),<br>            nn.BatchNorm2d(channels),<br>            nn.ReLU(),<br>            nn.Conv2d(channels, channels, <span class="hljs-number">3</span>, padding=<span class="hljs-number">1</span>),<br>            nn.BatchNorm2d(channels)<br>        )<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        <span class="hljs-keyword">return</span> F.relu(<span class="hljs-variable language_">self</span>.conv(x) + x)  <span class="hljs-comment"># 残差连接</span><br></code></pre></td></tr></table></figure><h4 id="混合精度训练">4. 混合精度训练</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torch.cuda.amp <span class="hljs-keyword">import</span> autocast, GradScaler<br><br>scaler = GradScaler()<br><br><span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> train_loader:<br>    optimizer.zero_grad()<br>    <br>    <span class="hljs-keyword">with</span> autocast():  <span class="hljs-comment"># 自动混合精度</span><br>        outputs = model(inputs)<br>        loss = criterion(outputs, labels)<br>    <br>    scaler.scale(loss).backward()<br>    scaler.step(optimizer)<br>    scaler.update()<br></code></pre></td></tr></table></figure><p><strong>效果</strong>：显存占用减少50%，训练速度提升2-3倍</p><h3 id="超参数调优建议">6.3 超参数调优建议</h3><table><thead><tr class="header"><th>超参数</th><th>推荐范围</th><th>调优策略</th></tr></thead><tbody><tr class="odd"><td>学习率</td><td>1e-4 ~ 1e-1</td><td>网格搜索/学习率查找器</td></tr><tr class="even"><td>batch_size</td><td>32 ~ 256</td><td>根据显存调整</td></tr><tr class="odd"><td>卷积核大小</td><td>3×3, 5×5</td><td>小卷积核更常用</td></tr><tr class="even"><td>Dropout率</td><td>0.3 ~ 0.5</td><td>防止过拟合</td></tr></tbody></table><h3 id="调试技巧">6.4 调试技巧</h3><h4 id="检查数据维度">检查数据维度</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Input shape: <span class="hljs-subst">&#123;inputs.shape&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Output shape: <span class="hljs-subst">&#123;outputs.shape&#125;</span>&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Label shape: <span class="hljs-subst">&#123;labels.shape&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h4 id="可视化特征图">可视化特征图</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">visualize_feature_maps</span>(<span class="hljs-params">model, image</span>):<br>    activation = &#123;&#125;<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hook</span>(<span class="hljs-params">name</span>):<br>        <span class="hljs-keyword">def</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">module, <span class="hljs-built_in">input</span>, output</span>):<br>            activation[name] = output<br>        <span class="hljs-keyword">return</span> fn<br>    <br>    model.conv1.register_forward_hook(hook(<span class="hljs-string">&#x27;conv1&#x27;</span>))<br>    <br>    <span class="hljs-keyword">with</span> torch.no_grad():<br>        model(image)<br>    <br>    feat = activation[<span class="hljs-string">&#x27;conv1&#x27;</span>].squeeze()<br>    <br>    fig, axes = plt.subplots(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>, figsize=(<span class="hljs-number">12</span>, <span class="hljs-number">5</span>))<br>    <span class="hljs-keyword">for</span> i, ax <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(axes.flat):<br>        ax.imshow(feat[i].cpu(), cmap=<span class="hljs-string">&#x27;viridis&#x27;</span>)<br>        ax.axis(<span class="hljs-string">&#x27;off&#x27;</span>)<br>    plt.show()<br></code></pre></td></tr></table></figure><h4 id="梯度检查">梯度检查</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 检查梯度是否正常</span><br><span class="hljs-keyword">for</span> name, param <span class="hljs-keyword">in</span> model.named_parameters():<br>    <span class="hljs-keyword">if</span> param.grad <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;name&#125;</span>: grad_norm = <span class="hljs-subst">&#123;param.grad.norm():<span class="hljs-number">.4</span>f&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><hr /><h2 id="七进阶扩展">七、进阶扩展</h2><h3 id="模型压缩">7.1 模型压缩</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 知识蒸馏</span><br>teacher_model = MNIST_CNN_Large()  <span class="hljs-comment"># 大模型</span><br>student_model = MNIST_CNN_Small()  <span class="hljs-comment"># 小模型</span><br><br><span class="hljs-comment"># 蒸馏损失</span><br>distillation_loss = F.kl_div(<br>    F.log_softmax(student_output / T, dim=<span class="hljs-number">1</span>),<br>    F.softmax(teacher_output / T, dim=<span class="hljs-number">1</span>),<br>    reduction=<span class="hljs-string">&#x27;batchmean&#x27;</span><br>) * (T * T)<br></code></pre></td></tr></table></figure><h3 id="迁移学习">7.2 迁移学习</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 加载预训练模型</span><br>pretrained_model = torch.load(<span class="hljs-string">&#x27;mnist_best.pth&#x27;</span>)<br><br><span class="hljs-comment"># 冻结前面的层</span><br><span class="hljs-keyword">for</span> param <span class="hljs-keyword">in</span> model.conv1.parameters():<br>    param.requires_grad = <span class="hljs-literal">False</span><br><br><span class="hljs-comment"># 只训练分类器</span><br>optimizer = optim.Adam(model.fc.parameters(), lr=<span class="hljs-number">0.001</span>)<br></code></pre></td></tr></table></figure><h3 id="模型集成">7.3 模型集成</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 投票集成</span><br>models = [model1, model2, model3]<br><br>predictions = []<br><span class="hljs-keyword">for</span> model <span class="hljs-keyword">in</span> models:<br>    model.<span class="hljs-built_in">eval</span>()<br>    <span class="hljs-keyword">with</span> torch.no_grad():<br>        pred = model(inputs).argmax(dim=<span class="hljs-number">1</span>)<br>        predictions.append(pred)<br><br><span class="hljs-comment"># 多数投票</span><br>final_pred = torch.mode(torch.stack(predictions), dim=<span class="hljs-number">0</span>)[<span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><hr /><h2 id="八总结">八、总结</h2><p>本文详细介绍了使用PyTorch构建MNIST手写数字识别系统的完整流程，涵盖了：</p><p><strong>核心技术点</strong>： - 数据加载与预处理 - CNN网络架构设计 - 训练流程与优化 - 模型评估与可视化</p><p><strong>关键要点</strong>： 1. 数据标准化是提升模型性能的基础 2. CNN通过卷积和池化提取图像特征 3. 合理的优化器和学习率调度至关重要 4. 多维度评估指标全面了解模型性能</p><p><strong>优化方向</strong>： - 数据增强提升泛化能力 - Batch Normalization加速训练 - Dropout防止过拟合 - 混合精度训练提升效率</p><p><strong>实践建议</strong>： - 从简单模型开始，逐步增加复杂度 - 重视数据质量和预处理 - 定期保存模型和可视化训练过程 - 使用TensorBoard监控训练指标</p><hr /><h2 id="参考资源">参考资源</h2><h3 id="官方文档">官方文档</h3><ul><li><a href="https://pytorch.org/docs/">PyTorch官方文档</a></li><li><a href="https://pytorch.org/vision/stable/index.html">torchvision文档</a></li><li><a href="http://yann.lecun.com/exdb/mnist/">MNIST数据集</a></li></ul><h3 id="进阶阅读">进阶阅读</h3><ul><li>《深度学习》（Ian Goodfellow）</li><li>《动手学深度学习》（李沐）</li><li><a href="http://cs231n.stanford.edu/">CS231n: Convolutional Neural Networks</a></li></ul><h3 id="代码仓库">代码仓库</h3><ul><li><a href="https://github.com/pytorch/examples">PyTorch Examples</a></li><li><a href="https://paperswithcode.com/dataset/mnist">Papers with Code - MNIST</a></li></ul><hr /><h2 id="附录完整代码清单">附录：完整代码清单</h2><h3 id="a.-改进版模型">A. 改进版模型</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ImprovedMNIST_CNN</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(ImprovedMNIST_CNN, <span class="hljs-variable language_">self</span>).__init__()<br>        <br>        <span class="hljs-variable language_">self</span>.conv1 = nn.Sequential(<br>            nn.Conv2d(<span class="hljs-number">1</span>, <span class="hljs-number">32</span>, kernel_size=<span class="hljs-number">3</span>, padding=<span class="hljs-number">1</span>),<br>            nn.BatchNorm2d(<span class="hljs-number">32</span>),<br>            nn.ReLU(),<br>            nn.Conv2d(<span class="hljs-number">32</span>, <span class="hljs-number">32</span>, kernel_size=<span class="hljs-number">3</span>, padding=<span class="hljs-number">1</span>),<br>            nn.BatchNorm2d(<span class="hljs-number">32</span>),<br>            nn.ReLU(),<br>            nn.MaxPool2d(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>),<br>            nn.Dropout2d(<span class="hljs-number">0.25</span>)<br>        )<br>        <br>        <span class="hljs-variable language_">self</span>.conv2 = nn.Sequential(<br>            nn.Conv2d(<span class="hljs-number">32</span>, <span class="hljs-number">64</span>, kernel_size=<span class="hljs-number">3</span>, padding=<span class="hljs-number">1</span>),<br>            nn.BatchNorm2d(<span class="hljs-number">64</span>),<br>            nn.ReLU(),<br>            nn.Conv2d(<span class="hljs-number">64</span>, <span class="hljs-number">64</span>, kernel_size=<span class="hljs-number">3</span>, padding=<span class="hljs-number">1</span>),<br>            nn.BatchNorm2d(<span class="hljs-number">64</span>),<br>            nn.ReLU(),<br>            nn.MaxPool2d(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>),<br>            nn.Dropout2d(<span class="hljs-number">0.25</span>)<br>        )<br>        <br>        <span class="hljs-variable language_">self</span>.fc = nn.Sequential(<br>            nn.Flatten(),<br>            nn.Linear(<span class="hljs-number">64</span> * <span class="hljs-number">7</span> * <span class="hljs-number">7</span>, <span class="hljs-number">256</span>),<br>            nn.BatchNorm1d(<span class="hljs-number">256</span>),<br>            nn.ReLU(),<br>            nn.Dropout(<span class="hljs-number">0.5</span>),<br>            nn.Linear(<span class="hljs-number">256</span>, <span class="hljs-number">10</span>)<br>        )<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        x = <span class="hljs-variable language_">self</span>.conv1(x)<br>        x = <span class="hljs-variable language_">self</span>.conv2(x)<br>        x = <span class="hljs-variable language_">self</span>.fc(x)<br>        <span class="hljs-keyword">return</span> x<br></code></pre></td></tr></table></figure><h3 id="b.-完整训练脚本">B. 完整训练脚本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">train_improved</span>(<span class="hljs-params">model, train_loader, val_loader, epochs=<span class="hljs-number">50</span></span>):<br>    device = torch.device(<span class="hljs-string">&#x27;cuda&#x27;</span> <span class="hljs-keyword">if</span> torch.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;cpu&#x27;</span>)<br>    model = model.to(device)<br>    <br>    criterion = nn.CrossEntropyLoss()<br>    optimizer = optim.Adam(model.parameters(), lr=<span class="hljs-number">0.001</span>)<br>    scheduler = optim.lr_scheduler.ReduceLROnPlateau(<br>        optimizer, mode=<span class="hljs-string">&#x27;min&#x27;</span>, patience=<span class="hljs-number">5</span>, factor=<span class="hljs-number">0.5</span><br>    )<br>    <br>    best_acc = <span class="hljs-number">0.0</span><br>    history = &#123;<span class="hljs-string">&#x27;train_loss&#x27;</span>: [], <span class="hljs-string">&#x27;val_loss&#x27;</span>: [], <span class="hljs-string">&#x27;val_acc&#x27;</span>: []&#125;<br>    <br>    <span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(epochs):<br>        <span class="hljs-comment"># 训练阶段</span><br>        model.train()<br>        train_loss = <span class="hljs-number">0.0</span><br>        <br>        <span class="hljs-keyword">for</span> inputs, labels <span class="hljs-keyword">in</span> train_loader:<br>            inputs, labels = inputs.to(device), labels.to(device)<br>            <br>            optimizer.zero_grad()<br>            outputs = model(inputs)<br>            loss = criterion(outputs, labels)<br>            loss.backward()<br>            optimizer.step()<br>            <br>            train_loss += loss.item()<br>        <br>        <span class="hljs-comment"># 验证阶段</span><br>        model.<span class="hljs-built_in">eval</span>()<br>        val_loss = <span class="hljs-number">0.0</span><br>        correct = <span class="hljs-number">0</span><br>        total = <span class="hljs-number">0</span><br>        <br>        <span class="hljs-keyword">with</span> torch.no_grad():<br>            <span class="hljs-keyword">for</span> inputs, labels <span class="hljs-keyword">in</span> val_loader:<br>                inputs, labels = inputs.to(device), labels.to(device)<br>                outputs = model(inputs)<br>                loss = criterion(outputs, labels)<br>                <br>                val_loss += loss.item()<br>                _, predicted = outputs.<span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>)<br>                total += labels.size(<span class="hljs-number">0</span>)<br>                correct += predicted.eq(labels).<span class="hljs-built_in">sum</span>().item()<br>        <br>        <span class="hljs-comment"># 记录指标</span><br>        train_loss /= <span class="hljs-built_in">len</span>(train_loader)<br>        val_loss /= <span class="hljs-built_in">len</span>(val_loader)<br>        val_acc = <span class="hljs-number">100.</span> * correct / total<br>        <br>        history[<span class="hljs-string">&#x27;train_loss&#x27;</span>].append(train_loss)<br>        history[<span class="hljs-string">&#x27;val_loss&#x27;</span>].append(val_loss)<br>        history[<span class="hljs-string">&#x27;val_acc&#x27;</span>].append(val_acc)<br>        <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Epoch <span class="hljs-subst">&#123;epoch+<span class="hljs-number">1</span>&#125;</span>/<span class="hljs-subst">&#123;epochs&#125;</span>:&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;  Train Loss: <span class="hljs-subst">&#123;train_loss:<span class="hljs-number">.4</span>f&#125;</span>&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;  Val Loss: <span class="hljs-subst">&#123;val_loss:<span class="hljs-number">.4</span>f&#125;</span>, Val Acc: <span class="hljs-subst">&#123;val_acc:<span class="hljs-number">.2</span>f&#125;</span>%&#x27;</span>)<br>        <br>        <span class="hljs-comment"># 学习率调整</span><br>        scheduler.step(val_loss)<br>        <br>        <span class="hljs-comment"># 保存最佳模型</span><br>        <span class="hljs-keyword">if</span> val_acc &gt; best_acc:<br>            best_acc = val_acc<br>            torch.save(model.state_dict(), <span class="hljs-string">&#x27;best_model.pth&#x27;</span>)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;  Best model saved! (Acc: <span class="hljs-subst">&#123;best_acc:<span class="hljs-number">.2</span>f&#125;</span>%)&#x27;</span>)<br>    <br>    <span class="hljs-keyword">return</span> history<br></code></pre></td></tr></table></figure><h3 id="c.-可视化工具">C. 可视化工具</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">plot_training_history</span>(<span class="hljs-params">history</span>):<br>    fig, (ax1, ax2) = plt.subplots(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, figsize=(<span class="hljs-number">12</span>, <span class="hljs-number">4</span>))<br>    <br>    <span class="hljs-comment"># 损失曲线</span><br>    ax1.plot(history[<span class="hljs-string">&#x27;train_loss&#x27;</span>], label=<span class="hljs-string">&#x27;Train Loss&#x27;</span>)<br>    ax1.plot(history[<span class="hljs-string">&#x27;val_loss&#x27;</span>], label=<span class="hljs-string">&#x27;Val Loss&#x27;</span>)<br>    ax1.set_xlabel(<span class="hljs-string">&#x27;Epoch&#x27;</span>)<br>    ax1.set_ylabel(<span class="hljs-string">&#x27;Loss&#x27;</span>)<br>    ax1.set_title(<span class="hljs-string">&#x27;Training and Validation Loss&#x27;</span>)<br>    ax1.legend()<br>    ax1.grid(<span class="hljs-literal">True</span>)<br>    <br>    <span class="hljs-comment"># 准确率曲线</span><br>    ax2.plot(history[<span class="hljs-string">&#x27;val_acc&#x27;</span>], label=<span class="hljs-string">&#x27;Val Accuracy&#x27;</span>, color=<span class="hljs-string">&#x27;green&#x27;</span>)<br>    ax2.set_xlabel(<span class="hljs-string">&#x27;Epoch&#x27;</span>)<br>    ax2.set_ylabel(<span class="hljs-string">&#x27;Accuracy (%)&#x27;</span>)<br>    ax2.set_title(<span class="hljs-string">&#x27;Validation Accuracy&#x27;</span>)<br>    ax2.legend()<br>    ax2.grid(<span class="hljs-literal">True</span>)<br>    <br>    plt.tight_layout()<br>    plt.show()<br></code></pre></td></tr></table></figure><hr /><p><strong>作者</strong>：[您的名字]<br /><strong>日期</strong>：2024年<br /><strong>版本</strong>：1.0</p><blockquote><p>本文所有代码均已在PyTorch 2.0+环境下测试通过。如有问题欢迎交流讨论！</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>code</category>
      
      <category>Pytorch</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Pytorch</tag>
      
      <tag>CNN</tag>
      
      <tag>MINIST</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pytorch 系列 - 2. 梯度下降</title>
    <link href="/2025/11/13/code/Pytorch/pytorch_2-GD-2025_11_13/"/>
    <url>/2025/11/13/code/Pytorch/pytorch_2-GD-2025_11_13/</url>
    
    <content type="html"><![CDATA[<p>asd</p>]]></content>
    
    
    <categories>
      
      <category>code</category>
      
      <category>Pytorch</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Pytorch</tag>
      
      <tag>Gradient Descent</tag>
      
      <tag>autograd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pytorch 系列 - 1. 曲线拟合</title>
    <link href="/2025/11/10/code/Pytorch/pytorch_1-regression-2025_11_10/"/>
    <url>/2025/11/10/code/Pytorch/pytorch_1-regression-2025_11_10/</url>
    
    <content type="html"><![CDATA[<h2 id="曲线拟合问题">1. 曲线拟合问题</h2><p>考虑以下曲线拟合问题</p><ul><li>给定一组数据（满足某种 <strong>未知映射</strong>，可能还会附加一些噪声）</li><li>利用 <code>pytorch</code> 搭建神经网络，基于给定数据，尝试重构 <strong>未知映射</strong></li><li>利用 <code>pytorch</code> 进行<strong>神经网络参数学习</strong>，将迭代过程中每次曲线拟合效果动态的展示出来（与原始给定数据一起展示） <!-- - 迭代过程（每10次）中的神经网络模型结构和参数都保存下来。- 迭代结束后，加载任意一个保存的模型文件，展示拟合效果（与原始给定数据一起展示） --></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> torch.optim <span class="hljs-keyword">as</span> optim<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-comment"># ===================== 1. 生成数据 =====================</span><br>torch.manual_seed(<span class="hljs-number">0</span>)<br>np.random.seed(<span class="hljs-number">0</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">true_func</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1.5</span> * x**<span class="hljs-number">2</span> - <span class="hljs-number">2</span> * x + <span class="hljs-number">1</span><br><br>n_samples = <span class="hljs-number">80</span><br>x = np.linspace(-<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, n_samples)<br>y = true_func(x) + np.random.normal(scale=<span class="hljs-number">1.0</span>, size=n_samples)  <span class="hljs-comment"># 加噪声</span><br><br>x_train = torch.from_numpy(x).<span class="hljs-built_in">float</span>().view(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)  <span class="hljs-comment"># [N, 1]</span><br>y_train = torch.from_numpy(y).<span class="hljs-built_in">float</span>().view(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)  <span class="hljs-comment"># [N, 1]</span><br><br><span class="hljs-comment"># ===================== 2. 定义网络 =====================</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Net</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        <span class="hljs-variable language_">self</span>.net = nn.Sequential(<br>            nn.Linear(<span class="hljs-number">1</span>, <span class="hljs-number">64</span>),<br>            nn.Tanh(),<br>            nn.Linear(<span class="hljs-number">64</span>, <span class="hljs-number">64</span>),<br>            nn.Tanh(),<br>            nn.Linear(<span class="hljs-number">64</span>, <span class="hljs-number">1</span>),<br>        )<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.net(x)<br><br>model = Net()<br>criterion = nn.MSELoss()<br>optimizer = optim.Adam(model.parameters(), lr=<span class="hljs-number">0.01</span>)<br><br><span class="hljs-comment"># ===================== 3. 训练设置 =====================</span><br>epochs = <span class="hljs-number">400</span><br>plot_interval = <span class="hljs-number">20</span>   <span class="hljs-comment"># 每隔多少次画一次</span><br>save_interval = <span class="hljs-number">10</span>   <span class="hljs-comment"># 每隔多少次保存一次模型</span><br><br>ckpt_dir = <span class="hljs-string">&quot;checkpoints&quot;</span><br>os.makedirs(ckpt_dir, exist_ok=<span class="hljs-literal">True</span>)<br><br><span class="hljs-comment"># ===================== 4. 动态可视化训练过程 =====================</span><br>plt.ion()  <span class="hljs-comment"># 打开交互模式</span><br>fig, ax = plt.subplots()<br><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, epochs + <span class="hljs-number">1</span>):<br>    <span class="hljs-comment"># 0. 既不会做前向计算，也不会更新参数，把模型切换到“training mode”</span><br>    model.train()<br><br>    <span class="hljs-comment"># 1. 清空之前的梯度</span><br>    optimizer.zero_grad()<br><br>    <span class="hljs-comment"># 2. 真正的“算输出”</span><br>    y_pred = model(x_train)<br>    <br>    <span class="hljs-comment"># 3. 指定优化目标 loss</span><br>    loss = criterion(y_pred, y_train)<br>    <br>    <span class="hljs-comment"># 4. 真正的“更新参数”</span><br>    loss.backward()  <span class="hljs-comment"># 反向传播：计算每个参数的【梯度】</span><br>    optimizer.step() <span class="hljs-comment"># 用【梯度】更新参数</span><br><br>    <span class="hljs-comment"># ---- 定期画图，展示拟合效果 ----</span><br>    <span class="hljs-keyword">if</span> epoch % plot_interval == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> epoch == <span class="hljs-number">1</span>:<br>        model.<span class="hljs-built_in">eval</span>()<br>        <span class="hljs-keyword">with</span> torch.no_grad():<br>            x_plot = np.linspace(-<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">200</span>)<br>            x_plot_tensor = torch.from_numpy(x_plot).<span class="hljs-built_in">float</span>().view(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>            y_plot_pred = model(x_plot_tensor).numpy()<br>            y_true = true_func(x_plot)<br><br>        ax.clear()<br>        ax.scatter(x, y, s=<span class="hljs-number">15</span>, label=<span class="hljs-string">&quot;Noisy data&quot;</span>)  <span class="hljs-comment"># 原始散点</span><br>        ax.plot(x_plot, y_true, linestyle=<span class="hljs-string">&quot;--&quot;</span>, label=<span class="hljs-string">&quot;True function&quot;</span>)  <span class="hljs-comment"># 真实曲线</span><br>        ax.plot(<br>            x_plot,<br>            y_plot_pred,<br>            label=<span class="hljs-string">f&quot;NN prediction (epoch=<span class="hljs-subst">&#123;epoch&#125;</span>, loss=<span class="hljs-subst">&#123;loss.item():<span class="hljs-number">.2</span>f&#125;</span>)&quot;</span><br>        )<br>        ax.set_xlabel(<span class="hljs-string">&quot;x&quot;</span>)<br>        ax.set_ylabel(<span class="hljs-string">&quot;y&quot;</span>)<br>        ax.set_title(<span class="hljs-string">&quot;Fitting $y = 1.5x^2 - 2x + 1$ with a Neural Network&quot;</span>)<br>        ax.legend()<br>        plt.pause(<span class="hljs-number">0.5</span>)   <span class="hljs-comment"># 短暂停顿实现动画效果</span><br><br>plt.ioff()<br>plt.show()<br></code></pre></td></tr></table></figure><h2 id="pytorch-保存与加载神经网络模型">2. pytorch 保存与加载神经网络模型</h2><h3 id="两种保存神经网络模型的方式">2.1 两种保存神经网络模型的方式</h3><ul><li>保存完整模型（不推荐）：<code>model</code><ul><li><code>torch.save(model, "path/filename.pth")</code></li><li>保存模型的所有信息，包括结构和参数。</li><li>这种方式文件较大，不建议在生产环境中使用。</li></ul></li><li>保存模型参数（推荐）：<code>model.state_dict()</code><ul><li><code>torch.save(model.state_dict(), "path/filename.pth")</code></li><li>只保存模型的参数（权重和偏置），而不保存模型的结构。</li><li>这种方式更轻量级，适用于部署场景。</li><li>加载模型时，需要先定义模型结构，然后加载参数到模型中。</li></ul></li><li>两种模式保存的文件类型都是 <code>.pth</code><ul><li>什么是 <code>.pth</code>？<ul><li><code>.pth</code> 文件本质上就是 <code>torch.save</code> 存的二进制文件，通常作为 <code>模型/参数/checkpoint</code> 的容器。</li><li>常见神经网络模型存储文件格式的还有 <code>.pt</code>、<code>.pth.tar</code>，本质一样。</li><li>存储原理：<code>torch.save()</code> = <code>Python 的 pickle</code> + <code>PyTorch 的 tensor</code></li><li>由于是二进制文件，只能用 <code>PyTorch</code>正确读取，不是人类可读文本。</li></ul></li><li><code>.pth</code> 里可以保存什么？<ul><li>任何可以被 <code>pickle</code> 序列化的 <code>Python 对象</code></li><li>模型参数（推荐）</li><li>整个模型对象（不太推荐，只做演示）</li><li>训练 checkpoint（强烈推荐） 可以包含<ol type="1"><li>模型参数</li><li>优化器参数（动量等）</li><li>当前 epoch、学习率、损失</li><li>想记录的其他信息（超参数设置、随机种子等）</li></ol>下面是一个示例（写在循环里面，每次迭代都保存以下信息） <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">torch.save(<br>&#123;<br>    <span class="hljs-string">&quot;epoch&quot;</span>: epoch,<br>    <span class="hljs-string">&quot;model_state_dict&quot;</span>: model.state_dict(),<br>    <span class="hljs-string">&quot;optimizer_state_dict&quot;</span>: optimizer.state_dict(),<br>    <span class="hljs-string">&quot;loss&quot;</span>: loss_value,<br>    <span class="hljs-string">&quot;extra_info&quot;</span>: <span class="hljs-string">&quot;anything you want&quot;</span>,<br>&#125;, <br><span class="hljs-string">&quot;ckpt_epoch_100.pth&quot;</span><br>)<br></code></pre></td></tr></table></figure></li></ul></li><li><code>.pth</code> 是如何保存数据的？<ul><li><code>torch.save(obj, path/filename.pth)</code> 会把 obj 通过 <code>Python 的 pickle</code> 序列化；</li><li>对于 <code>tensor</code>，<code>PyTorch</code> 会把真实数值存成高效的二进制块（包含 <code>dtype</code>、<code>shape</code> 等元数据）</li><li>所有这些被写入一个二进制文件，就是 <code>.pth</code> 文件</li><li><code>.pth</code> 文件 不能用记事本直接看；会是乱码</li><li><code>torch.load()</code> 本质是反序列化，有安全风险：不要随便加载来路不明的 <code>.pth</code>（因为 <code>pickle</code> 理论上可执行任意代码）</li></ul></li></ul></li></ul><h3 id="两种加载神经网络模型的方式">2.2 两种加载神经网络模型的方式</h3><ul><li><p>如果保存 <code>model</code> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">torch.save(model, <span class="hljs-string">&quot;path/filename.pth&quot;</span>)<br></code></pre></td></tr></table></figure> 就用 <code>torch.load()</code> 加载 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1. 加载 pth 文件</span><br>model = torch.load(<span class="hljs-string">&quot;path/filename.pth&quot;</span>)<br>model.<span class="hljs-built_in">eval</span>()<br><br><span class="hljs-comment"># 2. 准备与之前一致的数据，用于展示（x -&gt; y）</span><br>np.random.seed(<span class="hljs-number">0</span>)<br>n_samples = <span class="hljs-number">80</span><br>x = np.linspace(-<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, n_samples)<br>y = true_func(x) + np.random.normal(scale=<span class="hljs-number">3.0</span>, size=n_samples)<br><br><span class="hljs-comment"># 3. 神经网络计算 (x_tensor -&gt; y_pred)</span><br><span class="hljs-keyword">with</span> torch.no_grad():<br>    x_plot = np.linspace(-<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">200</span>)<br>    x_tensor = torch.from_numpy(x_plot).<span class="hljs-built_in">float</span>().view(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>    y_pred = model(x_tensor).numpy()<br></code></pre></td></tr></table></figure></p></li><li><p>如果保存 <code>model.state_dict()</code> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">torch.save(model.state_dict(), <span class="hljs-string">&quot;path/filename.pth&quot;</span>)<br></code></pre></td></tr></table></figure> 就用 <code>model.load_state_dict()</code> 加载 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 0. 与训练时保持一致的网络定义</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Net</span>(torch.nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        <span class="hljs-variable language_">self</span>.net = torch.nn.Sequential(<br>            torch.nn.Linear(<span class="hljs-number">1</span>, <span class="hljs-number">64</span>),<br>            torch.nn.Tanh(),<br>            torch.nn.Linear(<span class="hljs-number">64</span>, <span class="hljs-number">64</span>),<br>            torch.nn.Tanh(),<br>            torch.nn.Linear(<span class="hljs-number">64</span>, <span class="hljs-number">1</span>),<br>        )<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.net(x)<br><br><span class="hljs-comment"># 1. 选择要加载的 pth 文件</span><br>checkpoint = torch.load(<span class="hljs-string">&quot;path/filename&quot;</span>)<br><br><span class="hljs-comment"># 2. 重建同结构网络 &amp; 加载参数</span><br>model = Net()<br>model.load_state_dict(checkpoint[<span class="hljs-string">&quot;model_state_dict&quot;</span>])<br>model.<span class="hljs-built_in">eval</span>()<br><br><span class="hljs-comment"># 3. 准备与之前一致的数据，用于展示（x -&gt; y）</span><br>np.random.seed(<span class="hljs-number">0</span>)<br>n_samples = <span class="hljs-number">80</span><br>x = np.linspace(-<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, n_samples)<br>y = true_func(x) + np.random.normal(scale=<span class="hljs-number">3.0</span>, size=n_samples)<br><br><span class="hljs-comment"># 4. 神经网络计算 (x_tensor -&gt; y_pred)</span><br><span class="hljs-keyword">with</span> torch.no_grad():<br>    x_plot = np.linspace(-<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">200</span>)<br>    x_tensor = torch.from_numpy(x_plot).<span class="hljs-built_in">float</span>().view(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>    y_pred = model(x_tensor).numpy()<br></code></pre></td></tr></table></figure> 参数名示例：<code>net.0.weight</code>, <code>net.0.bias</code></p></li><li><p>如果保存 <code>checkpoint</code> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">torch.save(<br>  &#123;<br>      <span class="hljs-string">&quot;epoch&quot;</span>: epoch,<br>      <span class="hljs-string">&quot;model_state_dict&quot;</span>: model.state_dict(),<br>      <span class="hljs-string">&quot;optimizer_state_dict&quot;</span>: optimizer.state_dict(),<br>      <span class="hljs-string">&quot;loss&quot;</span>: loss,<br>  &#125;, <br>  <span class="hljs-string">&quot;ckpt_epoch_200.pth&quot;</span><br>)<br></code></pre></td></tr></table></figure> 就这样加载 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python">ckpt = torch.load(<span class="hljs-string">&quot;ckpt_epoch_200.pth&quot;</span>, map_location=<span class="hljs-string">&quot;cpu&quot;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(ckpt))       <span class="hljs-comment"># dict</span><br><span class="hljs-built_in">print</span>(ckpt.keys())      <span class="hljs-comment"># dict_keys([&#x27;epoch&#x27;, &#x27;model_state_dict&#x27;, &#x27;optimizer_state_dict&#x27;, &#x27;loss&#x27;])</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;epoch:&quot;</span>, ckpt[<span class="hljs-string">&quot;epoch&quot;</span>])<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;loss:&quot;</span>, ckpt[<span class="hljs-string">&quot;loss&quot;</span>])<br><br><span class="hljs-comment"># 查看模型参数 keys</span><br><span class="hljs-keyword">for</span> name, param <span class="hljs-keyword">in</span> ckpt[<span class="hljs-string">&quot;model_state_dict&quot;</span>].items():<br>    <span class="hljs-built_in">print</span>(name, param.shape)<br>    <span class="hljs-keyword">break</span><br><br></code></pre></td></tr></table></figure></p></li></ul><h3 id="pytorch-的保存与加载案例">3. pytorch 的保存与加载案例</h3><p>保存</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> torch.optim <span class="hljs-keyword">as</span> optim<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-comment"># ===================== 1. 生成数据 =====================</span><br>torch.manual_seed(<span class="hljs-number">0</span>)<br>np.random.seed(<span class="hljs-number">0</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">true_func</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1.5</span> * x**<span class="hljs-number">2</span> - <span class="hljs-number">2</span> * x + <span class="hljs-number">1</span><br><br>n_samples = <span class="hljs-number">80</span><br>x = np.linspace(-<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, n_samples)<br>y = true_func(x) + np.random.normal(scale=<span class="hljs-number">3.0</span>, size=n_samples)  <span class="hljs-comment"># 加噪声</span><br><br>x_train = torch.from_numpy(x).<span class="hljs-built_in">float</span>().view(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)  <span class="hljs-comment"># [N, 1]</span><br>y_train = torch.from_numpy(y).<span class="hljs-built_in">float</span>().view(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)  <span class="hljs-comment"># [N, 1]</span><br><br><span class="hljs-comment"># ===================== 2. 定义网络 =====================</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Net</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        <span class="hljs-variable language_">self</span>.net = nn.Sequential(<br>            nn.Linear(<span class="hljs-number">1</span>, <span class="hljs-number">64</span>),<br>            nn.Tanh(),<br>            nn.Linear(<span class="hljs-number">64</span>, <span class="hljs-number">64</span>),<br>            nn.Tanh(),<br>            nn.Linear(<span class="hljs-number">64</span>, <span class="hljs-number">1</span>),<br>        )<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.net(x)<br><br>model = Net()<br>criterion = nn.MSELoss()<br>optimizer = optim.Adam(model.parameters(), lr=<span class="hljs-number">0.01</span>)<br><br><span class="hljs-comment"># ===================== 3. 训练设置 =====================</span><br>epochs = <span class="hljs-number">400</span><br>plot_interval = <span class="hljs-number">20</span>   <span class="hljs-comment"># 每隔多少次画一次</span><br>save_interval = <span class="hljs-number">10</span>   <span class="hljs-comment"># 每隔多少次保存一次模型</span><br><br>ckpt_dir = <span class="hljs-string">&quot;checkpoints&quot;</span><br>os.makedirs(ckpt_dir, exist_ok=<span class="hljs-literal">True</span>)<br><br><span class="hljs-comment"># ===================== 4. 动态可视化训练过程 =====================</span><br>plt.ion()  <span class="hljs-comment"># 打开交互模式</span><br>fig, ax = plt.subplots()<br><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, epochs + <span class="hljs-number">1</span>):<br>    model.train()<br>    optimizer.zero_grad()<br><br>    y_pred = model(x_train)<br>    loss = criterion(y_pred, y_train)<br>    loss.backward()<br>    optimizer.step()<br><br>    <span class="hljs-comment"># ---- (1) 定期保存模型（结构+参数 / 推荐写法）----</span><br>    <span class="hljs-keyword">if</span> epoch % save_interval == <span class="hljs-number">0</span>:<br>        <span class="hljs-comment"># 保存 model.state_dict()</span><br>        torch.save(<br>            &#123;<br>                <span class="hljs-string">&quot;epoch&quot;</span>: epoch,<br>                <span class="hljs-string">&quot;model_state_dict&quot;</span>: model.state_dict(),<br>            &#125;,<br>            os.path.join(ckpt_dir, <span class="hljs-string">f&quot;ckpt_epoch_<span class="hljs-subst">&#123;epoch&#125;</span>.pth&quot;</span>),<br>        )<br><br>        <span class="hljs-comment"># 保存 model</span><br>        torch.save(<br>            model,<br>            os.path.join(ckpt_dir, <span class="hljs-string">f&quot;model_full_epoch_<span class="hljs-subst">&#123;epoch&#125;</span>.pth&quot;</span>)<br>        )<br><br>    <span class="hljs-comment"># ---- (2) 定期画图，展示拟合效果 ----</span><br>    <span class="hljs-keyword">if</span> epoch % plot_interval == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> epoch == <span class="hljs-number">1</span>:<br>        model.<span class="hljs-built_in">eval</span>()<br>        <span class="hljs-keyword">with</span> torch.no_grad():<br>            x_plot = np.linspace(-<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">200</span>)<br>            x_plot_tensor = torch.from_numpy(x_plot).<span class="hljs-built_in">float</span>().view(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>            y_plot_pred = model(x_plot_tensor).numpy()<br>            y_true = true_func(x_plot)<br><br>        ax.clear()<br>        ax.scatter(x, y, s=<span class="hljs-number">15</span>, label=<span class="hljs-string">&quot;Noisy data&quot;</span>)  <span class="hljs-comment"># 原始散点</span><br>        ax.plot(x_plot, y_true, linestyle=<span class="hljs-string">&quot;--&quot;</span>, label=<span class="hljs-string">&quot;True function&quot;</span>)  <span class="hljs-comment"># 真实曲线</span><br>        ax.plot(<br>            x_plot,<br>            y_plot_pred,<br>            label=<span class="hljs-string">f&quot;NN prediction (epoch=<span class="hljs-subst">&#123;epoch&#125;</span>, loss=<span class="hljs-subst">&#123;loss.item():<span class="hljs-number">.2</span>f&#125;</span>)&quot;</span><br>        )<br>        ax.set_xlabel(<span class="hljs-string">&quot;x&quot;</span>)<br>        ax.set_ylabel(<span class="hljs-string">&quot;y&quot;</span>)<br>        ax.set_title(<span class="hljs-string">&quot;Fitting $y = 1.5x^2 - 2x + 1$ with a Neural Network&quot;</span>)<br>        ax.legend()<br>        plt.pause(<span class="hljs-number">0.01</span>)   <span class="hljs-comment"># 短暂停顿实现动画效果</span><br><br>plt.ioff()<br>plt.show()<br></code></pre></td></tr></table></figure><p>加载 <code>model.state_dict()</code> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-comment"># 与训练时保持一致的网络定义</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Net</span>(torch.nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        <span class="hljs-variable language_">self</span>.net = torch.nn.Sequential(<br>            torch.nn.Linear(<span class="hljs-number">1</span>, <span class="hljs-number">64</span>),<br>            torch.nn.Tanh(),<br>            torch.nn.Linear(<span class="hljs-number">64</span>, <span class="hljs-number">64</span>),<br>            torch.nn.Tanh(),<br>            torch.nn.Linear(<span class="hljs-number">64</span>, <span class="hljs-number">1</span>),<br>        )<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.net(x)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">true_func</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1.5</span> * x**<span class="hljs-number">2</span> - <span class="hljs-number">2</span> * x + <span class="hljs-number">1</span><br><br><span class="hljs-comment"># 1. 选择要加载的 epoch</span><br>ckpt_dir = <span class="hljs-string">&quot;checkpoints&quot;</span><br>target_epoch = <span class="hljs-number">200</span>  <span class="hljs-comment"># 任意你训练时保存过的，比如 10, 50, 100, 200, ...</span><br><br>ckpt_path = os.path.join(ckpt_dir, <span class="hljs-string">f&quot;ckpt_epoch_<span class="hljs-subst">&#123;target_epoch&#125;</span>.pth&quot;</span>)<br>checkpoint = torch.load(ckpt_path)<br><br><span class="hljs-comment"># 2. 重建同结构网络 &amp; 加载参数</span><br>model = Net()<br>model.load_state_dict(checkpoint[<span class="hljs-string">&quot;model_state_dict&quot;</span>])<br>model.<span class="hljs-built_in">eval</span>()<br><br><span class="hljs-comment"># 3. 准备与之前一致的数据（用于展示）</span><br>np.random.seed(<span class="hljs-number">0</span>)<br>n_samples = <span class="hljs-number">80</span><br>x = np.linspace(-<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, n_samples)<br>y = true_func(x) + np.random.normal(scale=<span class="hljs-number">3.0</span>, size=n_samples)<br><br><span class="hljs-comment"># 4. 画出该 epoch 的拟合效果</span><br><span class="hljs-keyword">with</span> torch.no_grad():<br>    x_plot = np.linspace(-<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">200</span>)<br>    x_tensor = torch.from_numpy(x_plot).<span class="hljs-built_in">float</span>().view(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>    y_pred = model(x_tensor).numpy()<br><br>y_true = true_func(x_plot)<br><br>plt.scatter(x, y, s=<span class="hljs-number">15</span>, label=<span class="hljs-string">&quot;Noisy data&quot;</span>)<br>plt.plot(x_plot, y_true, <span class="hljs-string">&quot;--&quot;</span>, label=<span class="hljs-string">&quot;True function&quot;</span>)<br>plt.plot(x_plot, y_pred, label=<span class="hljs-string">f&quot;Loaded model (epoch=<span class="hljs-subst">&#123;target_epoch&#125;</span>)&quot;</span>)<br>plt.xlabel(<span class="hljs-string">&quot;x&quot;</span>)<br>plt.ylabel(<span class="hljs-string">&quot;y&quot;</span>)<br>plt.legend()<br>plt.title(<span class="hljs-string">&quot;Fit of Loaded Checkpoint Model&quot;</span>)<br>plt.show()<br></code></pre></td></tr></table></figure></p><p>加载 <code>model</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">true_func</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1.5</span> * x**<span class="hljs-number">2</span> - <span class="hljs-number">2</span> * x + <span class="hljs-number">1</span><br><br>ckpt_dir = <span class="hljs-string">&quot;checkpoints&quot;</span><br>target_epoch = <span class="hljs-number">200</span><br>model = torch.load(os.path.join(ckpt_dir, <span class="hljs-string">f&quot;model_full_epoch_<span class="hljs-subst">&#123;target_epoch&#125;</span>.pth&quot;</span>))<br>model.<span class="hljs-built_in">eval</span>()<br><br>np.random.seed(<span class="hljs-number">0</span>)<br>n_samples = <span class="hljs-number">80</span><br>x = np.linspace(-<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, n_samples)<br>y = true_func(x) + np.random.normal(scale=<span class="hljs-number">3.0</span>, size=n_samples)<br><br><span class="hljs-keyword">with</span> torch.no_grad():<br>    x_plot = np.linspace(-<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">200</span>)<br>    x_tensor = torch.from_numpy(x_plot).<span class="hljs-built_in">float</span>().view(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>    y_pred = model(x_tensor).numpy()<br>y_true = true_func(x_plot)<br><br>plt.scatter(x, y, s=<span class="hljs-number">15</span>, label=<span class="hljs-string">&quot;Noisy data&quot;</span>)<br>plt.plot(x_plot, y_true, <span class="hljs-string">&quot;--&quot;</span>, label=<span class="hljs-string">&quot;True function&quot;</span>)<br>plt.plot(x_plot, y_pred, label=<span class="hljs-string">f&quot;Loaded full model (epoch=<span class="hljs-subst">&#123;target_epoch&#125;</span>)&quot;</span>)<br>plt.legend()<br>plt.xlabel(<span class="hljs-string">&quot;x&quot;</span>)<br>plt.ylabel(<span class="hljs-string">&quot;y&quot;</span>)<br>plt.title(<span class="hljs-string">&quot;Fit of Loaded Full Model&quot;</span>)<br>plt.show()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>code</category>
      
      <category>Pytorch</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Pytorch</tag>
      
      <tag>regression</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GPU 系列 - 1. GPU 的两种同步方式</title>
    <link href="/2025/11/10/code/GPU/gpu_pytorch_1/"/>
    <url>/2025/11/10/code/GPU/gpu_pytorch_1/</url>
    
    <content type="html"><![CDATA[<h1 id="gpu-系列-pytorch---1.-gpu-的两种同步方式">GPU 系列 (Pytorch) - 1. GPU 的两种同步方式</h1><h2 id="pytorch-不同版本的安装">0. pytorch 不同版本的安装</h2><p>在开始说明 pytorch 不同版本的安装</p><p>在 pytorch 的官网查看安装指导 - GPU 安装 <img src="pytorch-install-gpu.png" alt="regular" /> - CPU 安装 <img src="pytorch-install-cpu.png" alt="regular" /></p><p>关于 GPU 的常见误区</p><ul><li>❌“有 GPU 就一定更快”：小任务/小 batch/频繁传输时未必。</li><li>❌“提速只能靠换卡”：数据加载、批量、传输模式、算子融合，往往是更便宜的提升空间。 <!-- - ❌“混合精度会降低精度”：合理使用（保持标量损失 FP32、关键归一化 FP32）通常不影响精度甚至更稳定。 --></li></ul><p>接下来通过几个例子初步认识一下 GPU 的运行机制</p><h2 id="gpu-的预热现象">1. GPU 的预热现象</h2><p><strong>例1</strong> 进行两次 GPU 乘法计算，分别查看耗时（注意，其实这里统计的时间，不是 GPU 计算乘法真正耗时） <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch, time<br><br>N = <span class="hljs-number">4000</span><br><br><span class="hljs-comment"># case1：GPU 乘法计算</span><br>a1 = torch.randn(N, N, device=<span class="hljs-string">&quot;cuda&quot;</span>)<br>b1 = torch.randn(N, N, device=<span class="hljs-string">&quot;cuda&quot;</span>)<br>t0 = time.perf_counter()<br>c1 = a1 @ b1              <span class="hljs-comment"># GPU：第 1 次执行乘法</span><br>t1 = time.perf_counter()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;[GPU] 耗时: <span class="hljs-subst">&#123;t1 - t0:<span class="hljs-number">.6</span>f&#125;</span>s&quot;</span>)<br><br><span class="hljs-comment"># case2：GPU 乘法计算</span><br>a2 = torch.randn(N, N, device=<span class="hljs-string">&quot;cuda&quot;</span>)<br>b2 = torch.randn(N, N, device=<span class="hljs-string">&quot;cuda&quot;</span>)<br>t0 = time.perf_counter()<br>c2 = a2 @ b2              <span class="hljs-comment"># GPU：第 2 次执行乘法</span><br>t1 = time.perf_counter()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;[GPU] 耗时: <span class="hljs-subst">&#123;t1 - t0:<span class="hljs-number">.6</span>f&#125;</span>s&quot;</span>)<br></code></pre></td></tr></table></figure> 执行得到以下结果： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[GPU] 耗时: 0.077134s<br>[GPU] 耗时: 0.001915s<br></code></pre></td></tr></table></figure> 可以看到，第一次耗时明显比第二次耗时更长，这是因为</p><ul><li><p>第 1 次计算是“冷启动”</p></li><li><p>第 2 次计算是“热身后”</p></li><li><p><strong>第 1 次 GPU 计算耗时 &gt;&gt; 第 2 次 GPU 计算耗时</strong></p></li></ul><h2 id="gpu-的预热耗时">2. GPU 的预热耗时</h2><p><strong>例2</strong> 进行两次 GPU 乘法计算，分别查看耗时（注意，其实这里统计的时间，不是 GPU 计算乘法真正耗时） <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch, time<br><br>N = <span class="hljs-number">4</span><br><br><span class="hljs-comment"># case1：GPU 乘法计算</span><br>a1 = torch.randn(N, N, device=<span class="hljs-string">&quot;cuda&quot;</span>)<br>b1 = torch.randn(N, N, device=<span class="hljs-string">&quot;cuda&quot;</span>)<br>t0 = time.perf_counter()<br>c1 = a1 @ b1              <span class="hljs-comment"># GPU：第 1 次执行乘法</span><br>t1 = time.perf_counter()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;[GPU] 耗时: <span class="hljs-subst">&#123;t1 - t0:<span class="hljs-number">.6</span>f&#125;</span>s&quot;</span>)<br><br><span class="hljs-comment"># case2：GPU 乘法计算</span><br>a2 = torch.randn(N, N, device=<span class="hljs-string">&quot;cuda&quot;</span>)<br>b2 = torch.randn(N, N, device=<span class="hljs-string">&quot;cuda&quot;</span>)<br>t0 = time.perf_counter()<br>c2 = a2 @ b2              <span class="hljs-comment"># GPU：第 2 次执行乘法</span><br>t1 = time.perf_counter()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;[GPU] 耗时: <span class="hljs-subst">&#123;t1 - t0:<span class="hljs-number">.6</span>f&#125;</span>s&quot;</span>)<br></code></pre></td></tr></table></figure> 执行得到以下结果： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">[GPU] 耗时: 0.078570s<br>[GPU] 耗时: 0.000069s<br></code></pre></td></tr></table></figure> 可以看到，计算量从 <span class="math inline">\(N=4000\)</span> 到 <span class="math inline">\(N=4\)</span>， - 第 1 次计算耗时从 0.077134s 到 0.078570s (几乎没变) - 第 2 次计算耗时从 0.001915s 到 0.000069s (显著减少) 这是因为 - 第 1 次计算时，GPU 还没有预热，需要花一些时间来初始化 - 第 2 次计算时，GPU 已经预热，所以耗时更短 - 对于 <span class="math inline">\(N=4\)</span> 和 <span class="math inline">\(N=4000\)</span>，可知 - <strong>每次 GPU 预热耗时大致一样</strong> - <strong>GPU 预热后，计算量越大 GPU 计算耗时也越大</strong></p><h2 id="gpu-的异步工作方式">3. GPU 的异步工作方式</h2><p><strong>例3</strong> 使用 CPU 和 GPU 进行乘法计算，分别查看耗时（注意，其实这里统计 GPU 工作时间有两种方式，第二种更科学） <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch, time<br><br>N = <span class="hljs-number">4000</span><br><br><span class="hljs-comment"># Case1: CPU 第一次计算</span><br>a1 = torch.randn(N, N)<br>b1 = torch.randn(N, N)<br>t0 = time.perf_counter()<br>c1 = a1 @ b1         <span class="hljs-comment"># CPU：调用会一直等到乘法真正算完才返回</span><br>t1 = time.perf_counter()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;[CPU] 耗时: <span class="hljs-subst">&#123;t1 - t0:<span class="hljs-number">.6</span>f&#125;</span>s&quot;</span>)<br><br><span class="hljs-comment"># Case2: CPU 第二次计算</span><br>a2 = torch.randn(N, N)<br>b2 = torch.randn(N, N)<br>t0 = time.perf_counter()<br>c2 = a2 @ b2         <span class="hljs-comment"># CPU：调用会一直等到乘法真正算完才返回</span><br>t1 = time.perf_counter()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;[CPU] 耗时: <span class="hljs-subst">&#123;t1 - t0:<span class="hljs-number">.6</span>f&#125;</span>s&quot;</span>)<br><br><span class="hljs-comment"># Case3: GPU（预热计时）</span><br>a3 = torch.randn(N, N, device=<span class="hljs-string">&quot;cuda&quot;</span>)<br>b3 = torch.randn(N, N, device=<span class="hljs-string">&quot;cuda&quot;</span>)<br>t0 = time.perf_counter()<br>c3 = a3 @ b3                  <span class="hljs-comment"># GPU：只是把任务放进队列,立即返回</span><br>t1 = time.perf_counter()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;[GPU] 耗时: <span class="hljs-subst">&#123;t1 - t0:<span class="hljs-number">.6</span>f&#125;</span>s&quot;</span>)<br><br><span class="hljs-comment"># case4：GPU（错误计时示范）</span><br>a4 = torch.randn(N, N, device=<span class="hljs-string">&quot;cuda&quot;</span>)<br>b4 = torch.randn(N, N, device=<span class="hljs-string">&quot;cuda&quot;</span>)<br>t0 = time.perf_counter()<br>c4 = a4 @ b4                  <span class="hljs-comment"># GPU：只是把任务放进队列,立即返回</span><br>t1 = time.perf_counter()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;[GPU] 耗时: <span class="hljs-subst">&#123;t1 - t0:<span class="hljs-number">.6</span>f&#125;</span>s&quot;</span>)<br><br><span class="hljs-comment"># case5：GPU（正确计时示范）</span><br>a5 = torch.randn(N, N, device=<span class="hljs-string">&quot;cuda&quot;</span>)<br>b5 = torch.randn(N, N, device=<span class="hljs-string">&quot;cuda&quot;</span>)<br>t0 = time.perf_counter()<br>c5 = a5 @ b5              <span class="hljs-comment"># GPU：只是把任务放进队列,立即返回</span><br>torch.cuda.synchronize()  <span class="hljs-comment"># 【强制同步】等待GPU完成!</span><br>t1 = time.perf_counter()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;[GPU] 耗时: <span class="hljs-subst">&#123;t1 - t0:<span class="hljs-number">.6</span>f&#125;</span>s&quot;</span>)<br></code></pre></td></tr></table></figure></p><p><span class="math inline">\(N = 4000\)</span>，执行得到以下结果： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">[CPU] 耗时: 0.149812s<br>[CPU] 耗时: 0.119700s<br>[GPU] 耗时: 0.077278s<br>[GPU] 耗时: 0.001844s<br>[GPU] 耗时: 0.027026s<br></code></pre></td></tr></table></figure> <span class="math inline">\(N = 4\)</span>，执行得到以下结果： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">[CPU] 耗时: 0.000254s<br>[CPU] 耗时: 0.000051s<br>[GPU] 耗时: 0.079781s<br>[GPU] 耗时: 0.000082s<br>[GPU] 耗时: 0.000241s<br></code></pre></td></tr></table></figure> 可以看出： - case 1 vs 2：CPU不存在预热，CPU每次运行耗时一样 - case 3 vs 4 vs 5：GPU存在预热，GPU第一次运行耗时较长，后续运行耗时较短 - case 4：GPU异步执行模式（错误计时），耗时较短是因为 GPU 只是把任务放进队列，立即返回，没有等待计算完成 - case 5：GPU异步执行模式（正确计时），耗时较长是因为 GPU 只是把任务放进队列，立即返回，没有等待计算完成，需要【强制同步】等待 GPU 完成计算 - Case 1 vs 5 (<span class="math inline">\(N = 4\)</span>)：GPU 比 CPU 略快，加速效果不明显 - Case 1 vs 5 (<span class="math inline">\(N = 4000\)</span>)：GPU 比 CPU 快很多，加速明显，说明 GPU 更适合大规模计算</p><p>Case 1 vs 4 vs 5 对应的运行机制如下</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">┌─────────────────────────────────────────────────────────────────────┐</span><br><span class="hljs-comment">│                  CPU 同步执行模式 (正确计时)                          │</span><br><span class="hljs-comment">└─────────────────────────────────────────────────────────────────────┘</span><br><br><span class="hljs-comment">Python主线程:  ───┬─────────────────────────────────────┬─────────</span>&gt;<br>               <span class="hljs-comment">t0 │                                     │ t1</span><br>                  <span class="hljs-comment">│       c_cpu = a_cpu @ b_cpu         │</span><br>                  <span class="hljs-comment">▼                                     ▼</span><br><span class="hljs-comment">CPU计算:</span>           <span class="hljs-title">[</span><span class="hljs-comment">████████████████████████████████████</span><span class="hljs-title">]</span><br>                   <span class="hljs-comment">│←    4000×4000 矩阵乘法，阻塞等待    →│</span><br>                   <span class="hljs-comment">│                                    │</span><br>                   <span class="hljs-comment">└─────── 实际计算时间  ≈  t1</span><span class="hljs-literal">-</span><span class="hljs-comment">t0   ────┘</span><br><br><span class="hljs-comment">特点: 计算 c_cpu = a_cpu @ b_cpu</span>  <br>      <span class="hljs-comment">会【阻塞】等待计算完成才返回</span><br>      <span class="hljs-comment">✓ t1</span><span class="hljs-literal">-</span><span class="hljs-comment">t0 准确反映了真实计算时间</span><br><br><br><span class="hljs-comment">┌─────────────────────────────────────────────────────────────────────┐</span><br><span class="hljs-comment">│                     GPU 异步执行模式 (错误计时)                       │</span><br><span class="hljs-comment">└─────────────────────────────────────────────────────────────────────┘</span><br><br><span class="hljs-comment">Python主线程:  ───┬─────────┬────────────────────────────────────</span>&gt;<br>               <span class="hljs-comment">t0 │←</span><span class="hljs-literal">-------</span><span class="hljs-comment">→│ t1 (仅是提交时间)</span><br>                  <span class="hljs-comment">│ ← 只是把任务放进队列</span><span class="hljs-string">,</span><span class="hljs-comment">立即返回</span><br>                  <span class="hljs-comment">│         │← 返回结束</span><br>                  <span class="hljs-comment">│         │</span><br>                  <span class="hljs-comment">│         │</span><br>               <span class="hljs-comment">t0 │←</span><span class="hljs-literal">-------</span><span class="hljs-comment">→│ t1</span>  <br><span class="hljs-comment">GPU后台异步执行:</span>              <span class="hljs-title">[</span><span class="hljs-comment">█████████████████████████</span><span class="hljs-title">]</span><br>                             <span class="hljs-comment">│←</span><span class="hljs-literal">--</span> <span class="hljs-comment">4000×4000 矩阵乘法</span> <span class="hljs-literal">--</span><span class="hljs-comment">→│</span><br>                             <span class="hljs-comment">|</span><span class="hljs-literal">------------------------</span><span class="hljs-comment">→│</span><br>                                 <span class="hljs-comment">(Python继续运行!)</span><br><br><span class="hljs-comment">特点: c = a @ b  只是【发射】kernel</span><span class="hljs-string">,</span><span class="hljs-comment">不等待完成</span><br>      <span class="hljs-comment">✗ t1</span><span class="hljs-literal">-</span><span class="hljs-comment">t0 只测量了提交时间 (~0</span><span class="hljs-string">.</span><span class="hljs-comment">0001s)</span><br>      <span class="hljs-comment">✗ 真实计算时间被隐藏在后台</span><br><br><br><span class="hljs-comment">┌─────────────────────────────────────────────────────────────────────┐</span><br><span class="hljs-comment">│                     正确的GPU计时方法                                │</span><br><span class="hljs-comment">└─────────────────────────────────────────────────────────────────────┘</span><br><br><span class="hljs-comment">Python主线程:  ───┬─────┬────────────────────────────┬─────────</span>&gt;<br>               <span class="hljs-comment">t0│     │</span>                   <span class="hljs-title">[</span><span class="hljs-comment">███████</span><span class="hljs-title">]</span><span class="hljs-comment">│t1</span><br>                 <span class="hljs-comment">│     │</span>       <span class="hljs-title">[</span><span class="hljs-comment">███████</span><span class="hljs-title">]</span>            <span class="hljs-comment">│</span><br>                 <span class="hljs-comment">│     │</span>           <span class="hljs-title">[</span><span class="hljs-comment">███████</span><span class="hljs-title">]</span>        <span class="hljs-comment">│</span><br>                 <span class="hljs-comment">│←</span><span class="hljs-literal">---</span><span class="hljs-comment">→|</span>              <span class="hljs-title">[</span><span class="hljs-comment">███████</span><span class="hljs-title">]</span>     <span class="hljs-comment">│</span><br>                 <span class="hljs-comment">▼                                  ▼</span><br><span class="hljs-comment">GPU队列:</span>       <span class="hljs-title">[</span><span class="hljs-comment">提交</span><span class="hljs-title">]</span> <span class="hljs-comment">→</span> <span class="hljs-title">[</span><span class="hljs-comment">████████████████████</span><span class="hljs-title">]</span>    <span class="hljs-title">[</span><span class="hljs-comment">同步点</span><span class="hljs-title">]</span><br>                       <span class="hljs-comment">│←</span><span class="hljs-literal">-----</span> <span class="hljs-comment">GPU计算</span> <span class="hljs-literal">-----</span><span class="hljs-comment">→│      │</span>       <br>                                             <span class="hljs-comment">│←</span><span class="hljs-literal">----</span><span class="hljs-comment">→|</span><br>                                                    <span class="hljs-comment">▲</span><br>                          <span class="hljs-comment">torch</span><span class="hljs-string">.</span><span class="hljs-comment">cuda</span><span class="hljs-string">.</span><span class="hljs-comment">synchronize() →|</span> <br>                                      <span class="hljs-comment">强制等待GPU完成!</span><br><br><br></code></pre></td></tr></table></figure><h2 id="gpu-两种同步方式">4. GPU 两种同步方式</h2><p><strong>例4</strong> 考虑以下两种 GPU 同步方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch, time<br><br>N = <span class="hljs-number">4000</span><br><br><span class="hljs-comment"># GPU 预热</span><br>a0 = torch.randn(N, N, device=<span class="hljs-string">&quot;cuda&quot;</span>)<br>b0 = torch.randn(N, N, device=<span class="hljs-string">&quot;cuda&quot;</span>)<br>t0 = time.perf_counter()<br>c0 = a0 @ b0              <span class="hljs-comment"># 提交 “a @ b” </span><br>torch.cuda.synchronize()  <span class="hljs-comment"># 【强制同步】等待GPU完成!</span><br>t1 = time.perf_counter()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;[GPU] 预热耗时: <span class="hljs-subst">&#123;t1 - t0:<span class="hljs-number">.6</span>f&#125;</span>s&quot;</span>)<br><br><span class="hljs-comment"># case 1: GPU 同步方式 1</span><br>a1 = torch.randn(N, N, device=<span class="hljs-string">&quot;cuda&quot;</span>)<br>b1 = torch.randn(N, N, device=<span class="hljs-string">&quot;cuda&quot;</span>)<br>t0 = time.perf_counter()<br>c1 = a1 @ b1              <span class="hljs-comment"># 提交 “a @ b” </span><br>torch.cuda.synchronize()  <span class="hljs-comment"># 【强制同步】等待GPU完成!</span><br>t1 = time.perf_counter()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;[GPU] 同步1耗时: <span class="hljs-subst">&#123;t1 - t0:<span class="hljs-number">.6</span>f&#125;</span>s&quot;</span>)<br><br><br><span class="hljs-comment"># case 2: GPU 同步方式 2</span><br><span class="hljs-comment"># 在 GPU 内创建两个大矩阵</span><br>a = torch.randn(N, N, device=<span class="hljs-string">&quot;cuda&quot;</span>)<br>b = torch.randn(N, N, device=<span class="hljs-string">&quot;cuda&quot;</span>)<br><span class="hljs-comment"># 创建两个 CUDA 事件（Event）:在 GPU 时间线上插两个“标记点”</span><br>start = torch.cuda.Event(enable_timing=<span class="hljs-literal">True</span>) <br>end = torch.cuda.Event(enable_timing=<span class="hljs-literal">True</span>) <br><br>start.record()    <span class="hljs-comment"># 开始标记</span><br>c = a @ b         <span class="hljs-comment"># 提交 “a @ b” （不会立即执行完）</span><br>end.record()      <span class="hljs-comment"># 结束标记</span><br>end.synchronize() <span class="hljs-comment"># 到这里为止，计时结束</span><br>T = start.elapsed_time(end) <span class="hljs-comment"># 统计从 start.record() 到 end.synchronize() 之间的耗时</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;[GPU] 同步2耗时: <span class="hljs-subst">&#123;T/<span class="hljs-number">1000</span>:<span class="hljs-number">.6</span>f&#125;</span>s&quot;</span>) <span class="hljs-comment"># T/1000：把毫秒变成秒</span><br></code></pre></td></tr></table></figure><p>执行后结果 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[GPU] 预热耗时: 0.083418s<br>[GPU] 同步1耗时: 0.013568s<br>[GPU] 同步2耗时: 0.005645s<br></code></pre></td></tr></table></figure> 可以看出 - 已经排除了预热的耗时 - 第一种同步方式耗时更长：等「这个 device 上所有的所有任务」完成，所以这种计时还是有误差的 - 第二种同步方式时间更短：等「这个 event 之前的任务」完成，所以这种计时更加精准 - 这两种同步方式，都包含了执行【乘法任务】的时间（这区别于<strong>例1</strong>，因为<strong>例1</strong>没有同步，只是在统计提交任务的时间）</p><p>两种同步方式的机制如下图所示</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs inform7">┌─────────────────────────────────────────────────────────────────────┐<br>│                        GPU 的同步方式 1                              │<br>└─────────────────────────────────────────────────────────────────────┘<br><br>Python主线程:  ───┬─────┬────────────────────────────┬─────────&gt;<br>               t0│     │                   <span class="hljs-comment">[███████]</span>│t1<br>                 │     │       <span class="hljs-comment">[███████]</span>            │<br>                 │     │           <span class="hljs-comment">[███████]</span>        │<br>                 │←---→|              <span class="hljs-comment">[███████]</span>     │<br>                 ▼                                  ▼<br>GPU队列:       <span class="hljs-comment">[提交]</span> → <span class="hljs-comment">[████████████████████]</span>    <span class="hljs-comment">[同步点]</span><br>                       │←----- GPU计算 -----→│      │       <br>                                             │←----→|<br>                                                    ▲<br>                          torch.cuda.synchronize() →| <br>                                      强制等待GPU完成!<br><br>┌─────────────────────────────────────────────────────────────────────┐<br>│                        GPU 的同步方式 2                              │<br>└─────────────────────────────────────────────────────────────────────┘<br><br>Python主线程:  ───┬─────┬──────────────────────────┬─────────&gt;<br>               t0│     │                           │t1<br>                 │     │                           │<br>                 │     │        end.record()→<span class="hljs-comment">[████]</span>│<br>                 │←---→|                     │     │<br>                 ▼                           │     ▼<br>GPU队列:       <span class="hljs-comment">[提交]</span> → <span class="hljs-comment">[████████████████████]</span>    <br>                       │←----- GPU计算 -----→│             <br>                                                   ▲<br>                                               <span class="hljs-comment">[同步点]</span><br>                                end.synchronize() →| <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>code</category>
      
      <category>GPU</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Pytorch</tag>
      
      <tag>GPU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git 系列 - 5. Git 分支协作案例</title>
    <link href="/2025/02/25/code/Git/git_5-branch_demo-2025-02-25/"/>
    <url>/2025/02/25/code/Git/git_5-branch_demo-2025-02-25/</url>
    
    <content type="html"><![CDATA[<h2 id="github-建立仓库-git_test会产生默认分支-main同时确保a和b都有-github-仓库的权限">1. Github 建立仓库 <code>git_test</code>（会产生默认分支 <code>main</code>），同时确保A和B都有 Github 仓库的权限</h2><h2 id="a-和-b-两个人分别在本地建立文件夹-git_test">2. A 和 B 两个人分别在本地建立文件夹 <code>git_test</code></h2><h2 id="a-进入本地文件夹-git_test">3. A 进入本地文件夹 <code>git_test</code></h2><ul><li>初始化A的本地仓库（会产生默认分支 <code>master</code>），</li><li>修改 <code>master</code> 分支为 <code>main</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git init<br>git branch -m master main<br></code></pre></td></tr></table></figure><h2 id="a-在本地仓库创建文件并同步至-github">4. A 在本地仓库创建文件并同步至 Github</h2><ul><li><p>新建文件 test.txt，并添加内容 <code>main 的第一次修改</code></p></li><li><p>并提交至本地仓库的 main 分支 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add .<br>git commit -m <span class="hljs-string">&quot;main 的第一次修改&quot;</span><br></code></pre></td></tr></table></figure></p></li><li><p>然后同步至 Github 仓库的 main 分支 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote add origin git@github.com:yylustb/git_test.git<br>git push -u origin main<br></code></pre></td></tr></table></figure> 接下来检查github，可以看到 Github 仓库的 main 分支已经同步成功</p></li></ul><h2 id="b-初次链接-github-仓库并初次同步">5. B 初次链接 Github 仓库，并初次同步</h2><ul><li>初始化 git 仓库（会产生默认分支 <code>master</code>），</li><li>修改 <code>master</code> 分支为 <code>main</code></li><li>链接Github 仓库</li><li>从 Github 仓库同步至本地仓库的 main 分支 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git init<br>git branch -m master main<br>git remote add origin git@github.com:yylustb/git_test.git<br>git pull origin main<br></code></pre></td></tr></table></figure> 接下来检查B的本地仓库，可以看到 Github 仓库的 main 分支已经同步成功</li></ul><h2 id="在三个仓库githuba本地和b本地添加fth分支并将-a-和-b-的-fth-分支与-github-的-fth-分支同步">6. 在三个仓库（Github，A本地，和B本地）添加fth分支，并将 A 和 B 的 fth 分支与 Github 的 fth 分支同步</h2><ul><li>在 <code>Github</code> 添加 fth 分支 (网页操作)</li><li>在 <code>A本地</code> 添加 fth 分支 (命令行操作) <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch fth<br>git checkout fth<br>git pull origin fth<br></code></pre></td></tr></table></figure></li><li>在 <code>B本地</code> 添加 fth 分支 (命令行操作) <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git branch fth<br>git checkout fth<br>git pull origin fth<br></code></pre></td></tr></table></figure></li></ul><h2 id="接下来a在本地仓库的main分支进行工作b在本地的fth分支进行工作a每次工作完要同步到github的mainb每次工作完要同步到github的fth">7. 接下来，A在本地仓库的main分支进行工作，B在本地的fth分支进行工作（A每次工作完要同步到Github的main，B每次工作完要同步到Github的fth）</h2><h3 id="a在本地仓库的main分支进行工作">7.1 A在本地仓库的main分支进行工作</h3><p>A 切换回 main 分支，修改test.txt文件，添加内容 <code>main 的第二次修改</code>，提交至本地仓库的 main 分支，并同步至 Github 仓库的 main 分支 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add .<br>git commit -m <span class="hljs-string">&quot;main 的第二次修改&quot;</span><br>git push -u origin main<br></code></pre></td></tr></table></figure></p><p>A 继续修改test.txt文件，添加内容 <code>main 的第三次修改</code>，提交至本地仓库的 main 分支，并同步至 Github 仓库的 main 分支 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add .<br>git commit -m <span class="hljs-string">&quot;main 的第三次修改&quot;</span><br>git push <br></code></pre></td></tr></table></figure></p><p>可以看到，本地仓库和Github仓库的main分支都已经同步成功（都包含main的三次修改记录）</p><h3 id="b在本地的fth分支进行工作">7.2 B在本地的fth分支进行工作</h3><p>B 切换回 fth 分支，修改test.txt文件，添加内容 <code>fth 的第一次修改</code>，提交至本地仓库的 fth 分支，并同步至 Github 仓库的 main 分支 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add .<br>git commit -m <span class="hljs-string">&quot;fth 的第一次修改&quot;</span><br>git push -u origin fth<br></code></pre></td></tr></table></figure></p><p>B 继续修改 test.txt 文件，添加内容 <code>fth 的第二次修改</code>，提交至本地仓库的 fth 分支，并同步至 Github 仓库的 fth 分支 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit -am <span class="hljs-string">&quot;main 的第二次修改&quot;</span><br>git push <br></code></pre></td></tr></table></figure></p><p>B 新建 paper/paper.txt 文件，添加内容 <code>111 \n 222 \n 333 \n</code>，提交至本地仓库的 fth 分支，并同步至 Github 仓库的 fth 分支 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add .<br>git commit -m <span class="hljs-string">&quot;main 的第三次修改&quot;</span><br>git push <br></code></pre></td></tr></table></figure></p><h2 id="接下来a-在本地仓库的-main-分支进行工作b-在本地的-fth-分支进行工作a-每次工作前和工作后同步到-github-的所有分支-a-每次工作前和工作后同步到-github-的所有分支">8. 接下来，A 在本地仓库的 main 分支进行工作，B 在本地的 fth 分支进行工作（A 每次工作前和工作后同步到 Github 的所有分支, A 每次工作前和工作后同步到 Github 的所有分支）</h2><h3 id="对于-a-每次工作的要求先处理冲突">8.1 对于 A 每次工作的要求（先处理冲突）</h3><p>A 工作前，在 main 分支和 fth 分支分别同步 Github 仓库的 main 分支和 fth 分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git switch main<br>git pull <br>git switch fth<br>git pull origin fth<br></code></pre></td></tr></table></figure><p>然后再本地，进行 main 和 fth 的 merge <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git switch main<br>git merge fth<br></code></pre></td></tr></table></figure></p><p>如没有冲突，继续工作。如有冲突，解决冲突。例如如下冲突（就在 test.txt 文档中）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">main 的第一次修改<br><br>&lt;&lt;&lt;&lt;&lt;&lt;&lt; <span class="hljs-string">HEAD</span><br><span class="hljs-string">main 的第二次修改</span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><br><span class="hljs-string">main 的第三次修改：asdasdasdasdas</span><br><span class="hljs-string">=======</span><br><span class="hljs-string"></span><br><span class="hljs-string">fth 的第一次修改</span><br><span class="hljs-string"></span><br><span class="hljs-string"></span><br><span class="hljs-string">fth 的第二次修改：acsc</span><br><span class="hljs-string">&gt;&gt;&gt;&gt;&gt;&gt;&gt; fth</span><br><span class="hljs-string"></span><br></code></pre></td></tr></table></figure><p>在 test.txt 这个文档中，手动选择保留哪一部分，处理完冲突后删除 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</code>, <code>=======</code>, <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt; fth</code> 这三行，最后保存 test.txt 文档。</p><p>处理完冲突后，提交到本地仓库的 main 分支，同时将 main 分支 merge 到 fth 分支。 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add.<br>git commit -am <span class="hljs-string">&quot;main 和 fth 的 merge&quot;</span><br>git switch fth<br>git merge main<br></code></pre></td></tr></table></figure></p><p>至此，main 和 fth 的冲突在本地解决完毕，接下来，需要A将本地的没有冲突的 main 分支和 fth 分支推送到 github</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git switch main<br>git push<br>git switch fth<br>git push origin fth<br></code></pre></td></tr></table></figure><h3 id="a-处理完冲突后的工作">8.2 A 处理完冲突后的工作</h3><p>接下来，A 在本地的 main 分支进行工作</p><p>修改 paper/paper.txt</p><p>修改后提交到本地，同步至github</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add.<br>git commit -am <span class="hljs-string">&quot;main 对 paper.txt 的修改&quot;</span><br>git push<br></code></pre></td></tr></table></figure><h3 id="对于-b-每次工作的要求先处理冲突">8.3 对于 B 每次工作的要求（先处理冲突）</h3><p>B 工作前，在 main 分支和 fth 分支分别同步 Github 仓库的 main 分支和 fth 分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git switch main<br>git pull <br>git switch fth<br>git pull origin fth<br></code></pre></td></tr></table></figure><p>然后在本地，进行 main 和 fth 互相之间的 merge <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git switch main<br>git merge fth<br>git switch fth<br>git merge main<br></code></pre></td></tr></table></figure></p><p>如没有冲突，继续工作。如有冲突，解决冲突 (仿照 8.1 中A的做法)。</p><h3 id="section">8.4</h3><p>接下来，B 在本地的 fth 分支进行工作，</p><p>工作结束后，提交本地的 fth 分支到本地仓库、且同步至 Github 仓库的 fth 分支</p><p>如果B没改动main分支，不需要对main分支进行任何操作，如果B改动了main分支，需要将改动同步到Github的main分支</p>]]></content>
    
    
    <categories>
      
      <category>code</category>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git 系列 - 4. Git 分支管理</title>
    <link href="/2025/02/24/code/Git/git_4-branch-2025-02-24/"/>
    <url>/2025/02/24/code/Git/git_4-branch-2025-02-24/</url>
    
    <content type="html"><![CDATA[<p>下面是关于 Git 分支（branch）的常见基本操作及其示例，供你参考和使用：</p><ol type="1"><li><p><strong>查看分支列表</strong></p><ul><li>查看本地分支：<br /><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git branch</span><br></code></pre></td></tr></table></figure></li><li>查看远程分支：<br /><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">git branch -<span class="hljs-attribute">r</span><br></code></pre></td></tr></table></figure></li><li>查看所有分支（本地 + 远程）：<br /><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">git branch -<span class="hljs-selector-tag">a</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>创建新分支</strong></p><ul><li>只创建分支，不切换到该分支：<br /><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">git branch <span class="hljs-tag">&lt;<span class="hljs-name">新分支名</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li>创建并切换到新分支（常用）：<br /><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gherkin"><span class="hljs-comment"># 旧写法</span><br>git checkout -b <span class="hljs-variable">&lt;新分支名&gt;</span><br><br><span class="hljs-comment"># 或者 Git 2.23+ 推荐用法</span><br>git switch -c <span class="hljs-variable">&lt;新分支名&gt;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>切换分支</strong></p><ul><li>切换到已有分支：<br /><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gherkin"><span class="hljs-comment"># 旧写法</span><br>git checkout <span class="hljs-variable">&lt;分支名&gt;</span><br><br><span class="hljs-comment"># Git 2.23+ 推荐用法</span><br>git switch <span class="hljs-variable">&lt;分支名&gt;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>重命名分支</strong></p><ul><li>重命名当前所在分支：<br /><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">git branch -m <span class="hljs-tag">&lt;<span class="hljs-name">新分支名</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li>重命名指定分支（需先切换到其他分支）：<br /><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">git branch -m <span class="hljs-tag">&lt;<span class="hljs-name">旧分支名</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">新分支名</span>&gt;</span><br></code></pre></td></tr></table></figure> 注意: <code>git branch -m</code> 和 <code>git branch -M</code>的区别：</li></ul><table><thead><tr class="header"><th>命令</th><th>是否允许覆盖已有分支</th><th>作用</th></tr></thead><tbody><tr class="odd"><td><code>git branch -m</code></td><td>❌ 不允许</td><td>安全重命名，不覆盖已有分支 (如果 <code>新分支名</code> 已经存在，则报错)</td></tr><tr class="even"><td><code>git branch -M</code></td><td>✅ 允许</td><td>强制重命名，覆盖已有分支 (如果 <code>新分支名</code> 已经存在，会强制覆盖，即删除 <code>新分支名</code> 并重命名)</td></tr></tbody></table></li><li><p><strong>合并分支</strong><br />下面示例演示使用 <code>git merge</code> 将其它分支上的工作合并到当前分支：</p><ol type="1"><li>先切换到目标分支（例如 <code>main</code> 分支）：<br /><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">git <span class="hljs-selector-tag">switch</span> <span class="hljs-selector-tag">main</span><br></code></pre></td></tr></table></figure></li><li>将另外一个分支（例如 <code>feature</code>）的改动合并到当前分支：<br /><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">git merge <span class="hljs-built_in">feature</span><br></code></pre></td></tr></table></figure></li><li>如果合并过程中有冲突，需要手动解决冲突后再提交。</li></ol><p>另外，<code>git rebase</code> 也可以用于合并分支 让 <code>feature</code> 变基到 <code>main</code>** <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">git switch feature<br>git rebase main<br></code></pre></td></tr></table></figure> 上面指令作用：</p><ul><li><code>feature</code> 分支的 <code>新提交</code> (不同于 <code>main</code> 的提交) 会被取出，然后依次 “重放” 到 <code>main</code> 最新提交之后。</li><li><code>feature</code> 分支现在看起来像是从 <code>main</code> 最新提交直接创建的，历史是线性的。</li></ul><p>如果 feature 和 main 都修改了相同的代码，可能会发生冲突，解决办法：</p><ol type="1"><li>手动编辑冲突的文件，解决冲突。</li><li>添加解决后的文件： <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">git add file.txt<br>git rebase --<span class="hljs-built_in">continue</span><br></code></pre></td></tr></table></figure></li><li>如果多个提交发生冲突，重复上述步骤，直到 <code>rebase</code> 完成。</li></ol><p>如果 <code>rebase</code> 过程中出现问题，你可以<strong>放弃 <code>rebase</code>，恢复原状态</strong>： <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git rebase --abort<br></code></pre></td></tr></table></figure> 这会让 <code>feature</code> 分支回到 <code>rebase</code> 之前的状态，避免修改提交历史。</p><p><strong><code>git rebase</code> 和 <code>git merge</code> 二者区别：</strong></p><ol type="1"><li><code>git rebase</code> 和 <code>git merge</code> 对两个分支的影响：</li></ol><table><thead><tr class="header"><th>操作</th><th>对 <code>main</code> 的影响</th><th>对 <code>feature</code> 的影响</th></tr></thead><tbody><tr class="odd"><td><code>git rebase main</code></td><td><strong>不变</strong></td><td>变基到 <code>main</code> 最新提交，提交 ID 可能会改变</td></tr><tr class="even"><td><code>git merge main</code></td><td>产生一个合并提交 <code>M</code></td><td><strong>不变</strong></td></tr></tbody></table><ol start="2" type="1"><li><code>git rebase</code> 和 <code>git merge</code> 对提交历史的影响：</li></ol><table><thead><tr class="header"><th></th><th><code>merge</code></th><th><code>rebase</code></th></tr></thead><tbody><tr class="odd"><td>提交历史</td><td>保留分支合并历史（会产生合并提交）</td><td>提交历史保持线性</td></tr><tr class="even"><td>是否创建新提交</td><td>产生一个新的合并提交</td><td>重新应用原始提交，可能修改提交哈希</td></tr><tr class="odd"><td>适用场景</td><td>团队协作，保留完整历史</td><td>个人开发，保持整洁的历史</td></tr><tr class="even"><td>是否会修改提交历史</td><td>❌ 不会</td><td>✅ 会修改提交历史</td></tr></tbody></table></li><li><p><strong>删除本地分支</strong></p><ul><li>安全删除，若本地分支改动未合并到其他分支，Git 会警告：<br /><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">git branch -d <span class="hljs-tag">&lt;<span class="hljs-name">分支名</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li>强制删除，不管是否合并：<br /><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">git branch -D <span class="hljs-tag">&lt;<span class="hljs-name">分支名</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>推送本地分支到远程</strong></p><ul><li>如果远程不存在同名分支，需要指定要推送到的远程仓库并创建对应分支：<br /><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> &lt;分支名&gt;<br></code></pre></td></tr></table></figure></li><li>若希望本地分支和远程分支保持相同名称，可加上 <code>-u</code>（设置跟踪关系），下次只需 <code>git push</code>：<br /><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> -u <span class="hljs-built_in">origin</span> &lt;分支名&gt;<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>从远程拉取分支</strong></p><ul><li>获取最新的远程信息：<br /><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git fetch</span><br></code></pre></td></tr></table></figure></li><li>检出（创建并切换到）远程分支到本地：<br /><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">git checkout -b <span class="hljs-tag">&lt;<span class="hljs-name">本地分支名</span>&gt;</span> origin/<span class="hljs-tag">&lt;<span class="hljs-name">远程分支名</span>&gt;</span><br></code></pre></td></tr></table></figure> 或使用 Git 2.23+ 的写法： <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">git switch -c <span class="hljs-tag">&lt;<span class="hljs-name">本地分支名</span>&gt;</span> origin/<span class="hljs-tag">&lt;<span class="hljs-name">远程分支名</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>查看分支合并图/历史记录</strong></p><ul><li>可以使用 <code>git log --graph --oneline --decorate</code> 来查看分支的历史演进关系，直观地了解分支如何合并和分叉。</li></ul></li></ol><hr /><p>以上是 Git 分支的基本操作流程及常见用法。根据团队协作和项目规范的不同，你可能需要结合 Pull Request 流程、代码审阅等来进行分支管理。合理地使用分支能让开发流程更有条理、降低冲突并提升协作效率。</p>]]></content>
    
    
    <categories>
      
      <category>code</category>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git 系列 - 3. Texstudio 同步 Git</title>
    <link href="/2025/02/23/code/Git/git_3-textstudio-2025-02-23/"/>
    <url>/2025/02/23/code/Git/git_3-textstudio-2025-02-23/</url>
    
    <content type="html"><![CDATA[<h3 id="原理">原理</h3><p>Texstudio 编译 A/main.tex，本质上是 cmd 进入路径 A，然后执行 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pdflatex main.tex<br></code></pre></td></tr></table></figure> 因为推送本地仓库到 github 需要在 cmd 执行 git 指令 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add .                     <br>git commit -m <span class="hljs-string">&quot;First Submit&quot;</span>  <br>git branch -M main            <br>git push -u origin main       <br></code></pre></td></tr></table></figure> 所以如果可以利用texstudio在tex文件路径执行上述指令，即可实现仅通过texstudio推送tex文件至github</p><h3 id="texstudio-配置">TexStudio 配置</h3><p>texstudio 中如下配置</p><figure><img src="git_texstudio.png" alt="regular" /><figcaption aria-hidden="true">regular</figcaption></figure><p>Tools -&gt; User -&gt; Git command 等价于在命令行<mark>当前目录</mark>下执行 Git command</p><h3 id="如何实现">如何实现</h3><p>第一次推送需要命令行，后续推送仅需texstudio</p><p>第一次推送： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">git init<br>git remote add origin github_SSH_address<br>git add .                     <span class="hljs-comment"># 每次推送执行</span><br>git commit -m <span class="hljs-string">&quot;First Submit&quot;</span>  <span class="hljs-comment"># 每次推送执行</span><br>git branch -M main            <span class="hljs-comment"># 首次推送执行 </span><br>git push -u origin main       <span class="hljs-comment"># 首次推送执行</span><br></code></pre></td></tr></table></figure> 后续推送/拉取： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add .                     <span class="hljs-comment"># 每次推送执行</span><br>git commit -m <span class="hljs-string">&quot;First Submit&quot;</span>  <span class="hljs-comment"># 每次推送执行</span><br>git push                      <span class="hljs-comment"># 每次推送执行</span><br>git pull                      <span class="hljs-comment"># 每次拉取执行</span><br></code></pre></td></tr></table></figure></p><p>注意：上面两行命令等价于下面一行命令 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit -am <span class="hljs-string">&quot;First Submit&quot;</span>  <span class="hljs-comment"># 每次推送执行</span><br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>code</category>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>Texstudio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git 系列 - 2. Matlab 同步 Git</title>
    <link href="/2025/02/22/code/Git/git_2-matlab-2025-02-22/"/>
    <url>/2025/02/22/code/Git/git_2-matlab-2025-02-22/</url>
    
    <content type="html"><![CDATA[<h2 id="安装必要软件">1.安装必要软件</h2><p>一行代码搭建机器人开发环境(ROS/ROS2/ROSDEP)</p><p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Powershell"><span class="hljs-built_in">wget</span> http://fishros.com/install <span class="hljs-literal">-O</span> fishros &amp;&amp; . fishros<br></code></pre></td></tr></table></figure></p><p>选项： - [1] 安装 noetic(ros1) - [3] 安装 rosdep</p>]]></content>
    
    
    <categories>
      
      <category>code</category>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git 系列 - 1. 安装 Git 与配置 Github</title>
    <link href="/2025/02/21/code/Git/git_1-install-2025-02-21/"/>
    <url>/2025/02/21/code/Git/git_1-install-2025-02-21/</url>
    
    <content type="html"><![CDATA[<h2 id="安装git">1. 安装git</h2><p>这里没什么好说的，官网下载，默认安装。</p><h2 id="配置-git-用户信息">2. 配置 git 用户信息</h2><h3 id="配置-git-用户信息-1">2.1 配置 Git 用户信息</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Powershell">git config <span class="hljs-literal">--global</span> user.name <span class="hljs-string">&quot;GitHub用户名&quot;</span> <span class="hljs-comment"># 不需要引号</span><br>git config <span class="hljs-literal">--global</span> user.email <span class="hljs-string">&quot;GitHub邮箱&quot;</span>  <span class="hljs-comment"># 不需要引号</span><br></code></pre></td></tr></table></figure><h3 id="设置-ssh-key">2.2 设置 SSH Key</h3><ul><li><p>生成 <code>SSH Key</code> <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Powershell">ssh<span class="hljs-literal">-keygen</span> <span class="hljs-literal">-t</span> rsa <span class="hljs-literal">-b</span> <span class="hljs-number">4096</span> <span class="hljs-literal">-C</span> <span class="hljs-string">&quot;GitHub邮箱&quot;</span> <span class="hljs-comment"># 不需要引号</span><br></code></pre></td></tr></table></figure></p><ul><li><code>-t rsa</code>：使用 RSA 加密算法</li><li><code>-b 4096</code>：密钥长度为 4096 位（更安全）</li><li><code>-C "GitHub邮箱"</code>：标识 SSH Key，方便管理</li></ul></li><li><p>接下来 terminal 提示： <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Powershell">Enter file <span class="hljs-keyword">in</span> which to save the key (/home/user/.ssh/id_rsa):<br></code></pre></td></tr></table></figure> 直接按回车即可（使用默认路径 <code>~/.ssh/id_rsa</code>）</p></li><li><p>接下来 terminal 提示输入密码： <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Powershell">Enter passphrase (empty <span class="hljs-keyword">for</span> no passphrase):<br>Enter same passphrase again:<br></code></pre></td></tr></table></figure> 两次回车即可（默认不输入密码），否则每次推送 Git 都需要输入密码</p></li><li><p>生成的 <code>SSH密钥</code> 存放在 <code>~/.ssh/id_rsa.pub</code></p></li></ul><h3 id="将-ssh密钥-添加到-github-账户的-ssh-keys-中">2.3 将 <code>SSH密钥</code> 添加到 GitHub 账户的 SSH Keys 中</h3><ul><li>复制 SSH Key <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Powershell"><span class="hljs-built_in">cat</span> ~/.ssh/id_rsa.pub<br></code></pre></td></tr></table></figure></li><li>添加到 GitHub<ul><li>登录 GitHub 账户</li><li>点击右上头像 -&gt; Settings（设置）</li><li>左侧选择 SSH and GPG keys（SSH 和 GPG 密钥）</li><li>点击 New SSH key（新建 SSH 密钥）<ul><li>Title: 可以自定义</li><li>Key: 粘贴复制的 SSH Key</li></ul></li><li>点击 Add SSH key</li></ul></li></ul><h3 id="测试-ssh-连接">2.3 测试 SSH 连接</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Powershell">ssh <span class="hljs-literal">-T</span> git@github.com<br></code></pre></td></tr></table></figure><p>如果配置成功，会显示： <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Powershell">Hi &lt;GitHub用户名&gt;! You<span class="hljs-string">&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span><br><span class="hljs-string"></span><br></code></pre></td></tr></table></figure></p><h2 id="修改文件提交到本地仓库">3. 修改文件，提交到本地仓库</h2><p>进入 <code>path/to/your/workspace/XXX</code> 文件夹，修改其中的文件 AAA.xx，然后执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git status<br></code></pre></td></tr></table></figure><p>执行后，会显示 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">Changes not stated <span class="hljs-keyword">for</span> commit:<br>  (use <span class="hljs-string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)<br>  (use <span class="hljs-string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="hljs-keyword">in</span> working directory)<br>        modified:   AAA.xx<br></code></pre></td></tr></table></figure> 表明： - AAA.xx 文件被修改 - 该文件的修改没有被添加到暂存区</p><p>接下来，执行以下命令： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add AAA.xx <span class="hljs-comment"># 将 AAA.xx 文件添加到暂存区</span><br></code></pre></td></tr></table></figure></p><p>再次执行以下命令 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git commit -m <span class="hljs-string">&quot;第一次修改&quot;</span> <span class="hljs-comment"># 将暂存区的文件提交到本地仓库，并添加提交备注信息</span><br></code></pre></td></tr></table></figure></p><h2 id="本地仓库关联配置远程仓库新建远程仓库后第一次推送">4. 本地仓库关联配置远程仓库（新建远程仓库后第一次推送）</h2><p>首先，在 GitHub 上新建一个仓库 (<mark>Github 仓库新建后的默认分支是 main</mark>)</p><p>本地仓库中文件每次修改后，如需推送，需要按顺序执行以下 Git 操作 <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Powershell"><span class="hljs-comment"># 1 切换到仓库根目录</span><br><span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;本地仓库路径&quot;</span><br><span class="hljs-comment"># 2 初始化 Git 仓库</span><br>git init<br><span class="hljs-comment"># 3 添加所有文件到暂存区</span><br>git add .<br><span class="hljs-comment"># 4 提交文件</span><br>git commit <span class="hljs-literal">-m</span> <span class="hljs-string">&quot;Initial commit&quot;</span> <br><span class="hljs-comment"># 5 origin = SSH，并且添加 origin（以后命令行可以用 origin 代表远程仓库）</span><br>git remote add origin SSH地址<br><span class="hljs-comment"># 6 强制重命名本地仓库的当前分支为 main</span><br>git branch <span class="hljs-literal">-M</span> main<br><span class="hljs-comment"># 7 第一次推送：将本地的 main 分支推送到 GitHub</span><br>git push <span class="hljs-literal">-u</span> origin main<br></code></pre></td></tr></table></figure> 注意： - Git 仓库默认的主分支是 <code>master</code>，但 GitHub 仓库采用 <code>main</code> 作为默认分支，所以用命令 <code>git branch -M main</code> 将本地分支当前分支 <code>master</code> 改为 <code>main</code>。 - 第一次推送执行 <code>git push -u origin main</code> ，<code>-u</code> 选项将本地的 main 分支与远程的 origin/main 关联起来，使得后续推送和拉取更方便。 - 如果不使用 <code>-u</code> 选项，后续推送时需要使用 <code>git push origin main</code>。 - 使用了 <code>-u</code> 选项后，后续推送时可以直接使用 <code>git push</code>。 - <code>-u</code> 的全写是 <code>--set-upstream</code>。</p><p>执行完上述指令后，打开 GitHub 仓库, 会看到本地仓库已经推送.</p><h2 id="推送本地仓库到远程仓库非第一次推送">5. 推送本地仓库到远程仓库（非第一次推送）</h2><p>执行以下指令，推送本地仓库到远程仓库 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git push<br></code></pre></td></tr></table></figure> 执行以下指令，远程仓库拉取到本地仓库 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git pull<br></code></pre></td></tr></table></figure></p><h2 id="总结">总结</h2><ul><li>SSH 密钥配置，不需要每次验证</li><li>从远程仓库 clone 到本地：<ul><li><code>git clone 远程仓库地址</code></li></ul></li><li>本地仓库与远程仓库的关联配置（首次推送）：<ul><li><code>git add .</code> # 提交到暂存区</li><li><code>git commit -m "提交备注信息"</code> # 提交到本地仓库</li><li><code>git remote add origin 远程仓库地址</code> # 将本地仓库与远程仓库关联</li><li><code>git remote -v</code> # 查看远程仓库的信息</li><li><code>git branch -M main</code></li><li><code>git push -u origin main</code> # 将本地的当前分支与远程的 origin/main 关联并推送</li></ul></li><li>本地仓库提交到远程仓库的流程（非首次推送）：<ul><li><code>git add .</code> # 提交到暂存区</li><li><code>git commit -m "提交备注信息"</code> # 提交到本地仓库</li><li><code>git push</code> # 提交到远程仓库</li></ul></li><li>上面两条指令可以简化为下面一条指令<ul><li><code>git commit -am "提交备注信息"</code> # 提交到本地仓库</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>code</category>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python 系列 - 1. 命令行解析器 argparse</title>
    <link href="/2025/02/13/code/Python/python_1-argparse-2025_02_13/"/>
    <url>/2025/02/13/code/Python/python_1-argparse-2025_02_13/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是-argparse">1.什么是 argparse</h2><p><code>argparse</code> 是一个强大的命令行参数解析工具，用于构建命令行脚本或程序时，可以非常方便地对传入的参数进行解释和处理。</p><p>在编写命令行工具或脚本时，往往需要接收来自命令行的参数或选项，以实现配置。</p><p><code>argparse</code> 则能让你以更高层次、更结构化的方式来定义程序期望的参数形式，以及如何处理这些参数，从而自动生成帮助信息、错误信息等。</p><h2 id="基本用法">2.基本用法</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> argparse<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">main</span>():<br>    <span class="hljs-string">&#x27;&#x27;&#x27;第一步：创建一个解析器对象，可以给出程序的简单描述&#x27;&#x27;&#x27;</span><br>    parser = argparse.ArgumentParser(description=<span class="hljs-string">&quot;这是一个示例命令行工具&quot;</span>)<br><br>    <span class="hljs-string">&#x27;&#x27;&#x27;第二步：添加命令行参数和选项&#x27;&#x27;&#x27;</span><br>    <span class="hljs-comment"># 添加必选参数: 在命令中不需要特意写 -x 或者 --xx ，是脚本必须要获取的数据。</span><br>    parser.add_argument(<span class="hljs-string">&quot;filename&quot;</span>, <span class="hljs-built_in">help</span>=<span class="hljs-string">&quot;输入文件的路径&quot;</span>)<br>    <span class="hljs-comment"># 添加可选参数1：一般以短选项（如 -v）或长选项（如 --verbose）的形式出现。</span><br>    parser.add_argument(<span class="hljs-string">&quot;-v&quot;</span>, <span class="hljs-string">&quot;--verbose&quot;</span>, <br>                        action=<span class="hljs-string">&quot;store_true&quot;</span>, <br>                        <span class="hljs-built_in">help</span>=<span class="hljs-string">&quot;是否输出详细信息（布尔开关）&quot;</span><br>                        )<br>    <span class="hljs-comment"># 添加可选参数2：一般以短选项（如 -v）或长选项（如 --verbose）的形式出现。</span><br>    parser.add_argument(<span class="hljs-string">&quot;-n&quot;</span>, <span class="hljs-string">&quot;--number&quot;</span>,<br>                        <span class="hljs-built_in">type</span>=<span class="hljs-built_in">int</span>,<br>                        default=<span class="hljs-number">1</span>,<br>                        <span class="hljs-built_in">help</span>=<span class="hljs-string">&quot;重复操作次数，默认为 1&quot;</span><br>                        )<br>    <span class="hljs-comment"># 添加可选参数3：接收某个范围或集合中的值</span><br>    parser.add_argument(<span class="hljs-string">&quot;--mode&quot;</span>, <br>                        choices=[<span class="hljs-string">&quot;train&quot;</span>, <span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;eval&quot;</span>], <br>                        <span class="hljs-built_in">help</span>=<span class="hljs-string">&quot;模式选择&quot;</span><br>                        )<br>    <span class="hljs-comment"># 添加可选参数4：指定参数的别名</span><br>    parser.add_argument(<span class="hljs-string">&quot;-m&quot;</span>, <span class="hljs-string">&quot;--mode&quot;</span>, <br>                        choices=[<span class="hljs-string">&quot;train&quot;</span>, <span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;eval&quot;</span>]<br>                        )<br><br><br><br><br>    <span class="hljs-string">&#x27;&#x27;&#x27;第三步：解析命令行参数&#x27;&#x27;&#x27;</span><br>    <span class="hljs-comment"># args 就是一个包含解析后参数的命名空间对象, 属性名即为参数名。</span><br>    args = parser.parse_args()<br>    <span class="hljs-comment"># 通过 args.filename 访问参数 filename</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;文件名：&quot;</span>, args.filename)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;是否详细输出：&quot;</span>, args.verbose)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;操作次数：&quot;</span>, args.number)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    main()<br></code></pre></td></tr></table></figure><ul><li>必选参数：<ul><li><code>help="输入文件的路径"</code>: 在 <code>--help</code> 命令中显示的参数说明</li><li>当执行脚本时，需要紧随其后提供必选参数 filename，否则会报错。例如（下面指令中的 <code>input.txt</code> 就是参数 “filename”） <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python script.py input.txt<br></code></pre></td></tr></table></figure></li></ul></li><li>可选参数1：<ul><li><code>-v</code> 和 <code>--verbose</code>: 代表同一个可选参数，用户可以使用任一形式。</li><li><code>action="store_true"</code>: 当这个选项被使用时，将在解析结果中把 <code>verbose</code> 设置为 <code>True</code>（不使用则为 <code>False</code>）。</li><li><code>help="是否输出详细信息（布尔开关）"</code>: help 中的内容会在 <code>--help</code> 命令中显示。</li></ul></li><li>可选参数2：<ul><li><code>type=int</code>：将输入值转换为整数类型（如果传入值无法转换会报错）。</li><li><code>default=1</code>：当用户没有提供该参数时，使用默认值 1。</li></ul></li></ul><p>定义完上面的代码文件后，在命令行的执行如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 带所有参数</span><br>python script.py myfile.txt -v -n 3<br><span class="hljs-comment"># 或者：python script.py myfile.txt --verbose --number 3</span><br><br><span class="hljs-comment"># 不带可选参数</span><br>python script.py myfile.txt<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>code</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>argparse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LaTex 系列 - 3. LaTex 项目文件包含问题</title>
    <link href="/2025/02/03/code/Latex/latex_3-input-2025-02-03/"/>
    <url>/2025/02/03/code/Latex/latex_3-input-2025-02-03/</url>
    
    <content type="html"><![CDATA[<p>在 LaTeX 复杂项目中，出现文件包含情况，例如 main.tex 文档包含多个章节，我们可以不同章节设置单独 tex 文档 (例如 chap_1.tex)，那么在 main.tex 文档中使用如下命令进行文件包含：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\input</span>&#123;chap<span class="hljs-built_in">_</span>1.tex&#125;<br></code></pre></td></tr></table></figure><p>然后每次修改 <code>chap_1.tex</code> 文档，都需要重新编译 <code>main.tex</code> 文档，这样会比较麻烦。</p><p>为了解决这个问题，我们可以通过以下设置，简化操作 (即修改 <code>chap_1.tex</code> 后，点击编译按钮，实现编译 <code>main.tex</code>)：</p><ul><li>确保当前打开的文件是 main.tex</li><li><code>Options</code> -&gt; <code>Root Document</code></li><li>然后选择以下两个选项均可（可能只会有第二个选项）<ul><li><code>Explicit: main.tex</code></li><li><code>Set Current Document As Explicit Root</code> 做好上面设置后，<code>main.tex</code> 就被设置为项目的 <code>根文件</code>，每次修改 <code>chap_1.tex</code> 后，点击编译按钮，就会自动编译 <code>main.tex</code> 文档。</li></ul></li></ul><figure><img src="2025-02-03-latex_input.png" alt="regular" /><figcaption aria-hidden="true">regular</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>code</category>
      
      <category>LaTex</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LaTex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LaTex 系列 - 2. LaTex 编译器设置</title>
    <link href="/2025/02/02/code/Latex/latex_2-compile-2025-02-02/"/>
    <url>/2025/02/02/code/Latex/latex_2-compile-2025-02-02/</url>
    
    <content type="html"><![CDATA[<p>不同的 LaTeX 项目需要不同的编译器，例如 (英文需要 pdflatex, 中文需要 xelatex). 以下是两种设置方案</p><h2 id="方案1手动切换编译器">方案1：手动切换编译器</h2><p>Options -&gt; Configure TeXstudio -&gt; Build -&gt; Meta Commands -&gt; Default Compiler: 选择 pdflatex 或者 xelatex</p><p>Options -&gt; Configure TeXstudio -&gt; Build -&gt; Meta Commands -&gt; Default Bibliography Tool: 选择 Bibtex 或者 Biber</p><h2 id="方案2文件自动选择编译器">方案2：文件自动选择编译器</h2><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-meta">% !TeX program = xelatex</span><br><span class="hljs-meta">% !TeX TS-program = xelatex</span><br><span class="hljs-meta">% !TeX bibtexProgram = biber</span><br></code></pre></td></tr></table></figure><ul><li>第一行: 指定当前 .tex 文件的 主编译器 为 XeLaTeX, 等效于手动执行： <code>xelatex mydocument.tex</code> (针对 VS Code/TeXstudio)</li><li>第二行: 指定当前 .tex 文件的 主编译器 为 XeLaTeX, 等效于手动执行： <code>xelatex mydocument.tex</code> (针对 TeXShop、TeXworks、TeXmaker)</li><li>第三行: 指定当前.tex 文件的 文献管理工具 为 Biber, 等效于手动执行： <code>biber mydocument.bcf</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>code</category>
      
      <category>LaTex</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LaTex</tag>
      
      <tag>pdflatex</tag>
      
      <tag>xulatex</tag>
      
      <tag>lualatex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LaTex 系列 - 1. LaTex 编译器介绍</title>
    <link href="/2025/02/01/code/Latex/latex_1-intro-2025-02-01/"/>
    <url>/2025/02/01/code/Latex/latex_1-intro-2025-02-01/</url>
    
    <content type="html"><![CDATA[<p>在 LaTeX 生态中，latex、pdflatex、xelatex 和 lualatex 是不同的编译引擎，各自有不同的特点和适用场景。</p><h2 id="latex">1. latex</h2><ul><li>最古老的 LaTeX 编译器，输出的是 DVI 文件，不是 PDF 文件</li><li>需要使用 dvips 或 dvipdf 等工具将 DVI 文件转换为 PDF 文件（<code>latex → DVI → PS → PDF</code>）。</li><li>不支持直接插入 PNG、JPEG、PDF 等图片格式，只支持 EPS 格式。</li><li>不支持直接插入中文，需要使用 xeCJK 或 CJK 宏包。</li></ul><h2 id="pdflatex">2. pdflatex</h2><ul><li>直接生成 PDF 文件（不需要使用 dvips 或 dvipdf 等转换工具）。</li><li>支持直接插入 PNG、JPEG、PDF 等图片格式（但不支持 EPS 格式）。</li><li>不支持 Unicode，默认采用 8-bit 编码（如 latin1、utf8 需用 inputenc 宏包）</li><li>对中文支持较差，需要 CJK 宏包（或 ctex 宏包）。</li><li>适合英文和西方语言文档（默认 8-bit 编码）</li><li>如果一定要用 pdflatex 处理中文，需要 <figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\usepackage</span>[CJKutf8]&#123;CJK&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="xelatex">3. xelatex</h2><ul><li>直接生成 <code>PDF</code> 文件（不需要使用 <code>dvips</code> 或 <code>dvipdf</code> 等转换工具）。</li><li>支持 <code>Unicode</code>，默认采用 <code>UTF-8</code> 编码，适用于多语言文档（包括中文）</li><li>支持 <code>OpenType/TrueType</code>（OTF/TTF）字体，可以直接使用系统字体（如宋体、楷体、黑体、SimSun、SimHei 等）</li><li>支持 <code>fontspec</code> 宏包，使字体管理更灵活。</li><li>支持直接插入 PNG、JPEG、PDF 等图片格式（但不支持 EPS 格式）。</li><li><code>CTeX</code> 默认推荐 <code>xelatex</code></li></ul><h2 id="lualatex推荐用于高级应用如-lua-代码交互">4. lualatex（推荐用于高级应用，如 Lua 代码交互）</h2><ul><li>支持 Unicode 和 OpenType 字体。</li><li>支持 fontspec 宏包（字体管理）。</li><li>支持 luacode 宏包，可以在 LaTeX 代码中直接写 Lua 代码，例如： <figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-keyword">\usepackage</span>&#123;luacode&#125;<br><span class="hljs-keyword">\begin</span>&#123;luacode&#125;<br>tex.print(&quot;你好，LuaLaTeX！&quot;)<br><span class="hljs-keyword">\end</span>&#123;luacode&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="总结">5. 总结</h2><table><thead><tr class="header"><th style="text-align: center;">编译器</th><th style="text-align: left;">是否支持 Unicode</th><th style="text-align: left;">直接输出 PDF</th><th style="text-align: left;">适用于中文</th><th style="text-align: center;">图片支持</th><th style="text-align: center;">推荐用途</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><code>latex</code></td><td style="text-align: left;">❌ 否</td><td style="text-align: left;">❌ 需转换</td><td style="text-align: left;">❌ 需 CJK</td><td style="text-align: center;">仅支持 EPS</td><td style="text-align: center;">过时，基本不用</td></tr><tr class="even"><td style="text-align: center;"><code>pdflatex</code></td><td style="text-align: left;">❌ 否</td><td style="text-align: left;">✅ 是</td><td style="text-align: left;">⚠️ 需 CJK</td><td style="text-align: center;">PNG、JPEG、PDF</td><td style="text-align: center;">适用于英文或简单中文</td></tr><tr class="odd"><td style="text-align: center;"><code>xelatex</code></td><td style="text-align: left;">✅ 是</td><td style="text-align: left;">✅ 是</td><td style="text-align: left;">✅ 推荐</td><td style="text-align: center;">PNG、JPEG、PDF</td><td style="text-align: center;">推荐中文文档、支持系统字体</td></tr><tr class="even"><td style="text-align: center;"><code>lualatex</code></td><td style="text-align: left;">✅ 是</td><td style="text-align: left;">✅ 是</td><td style="text-align: left;">✅ 推荐</td><td style="text-align: center;">PNG、JPEG、PDF</td><td style="text-align: center;">高级排版、动态 Lua 代码</td></tr></tbody></table><h2 id="小贴士">小贴士</h2><ul><li><p><mark><strong>Unicode 是字符集，定义了世界上所有语言的字符</strong></mark>例如</p><ul><li><code>A</code> → <code>U+0041</code></li><li><code>你</code> → <code>U+4F60</code></li><li><code>😊</code> → <code>U+1F60A</code></li></ul></li><li><p>但Unicode 只规定了字符编号（码点），并没有规定如何存储这些字符。</p></li><li><p>计算机只能存储 二进制数据（0 和 1），所以我们需要 字符编码（Character Encoding）把 Unicode 转换成二进制。</p></li><li><p><mark><strong>UTF-8 是 Unicode 的一种编码方式</strong></mark>，是一种 可变长度的 Unicode 编码</p><ul><li>1 个字节（8-bit） 表示 ASCII 字符（兼容英语）。</li><li>2~4 个字节 表示其他 Unicode 字符（如中文、Emoji）。</li><li><code>A</code> → <code>U+0041</code> → <code>0x41</code>（1 字节）</li><li><code>你</code> → <code>U+4F60</code> → <code>0xE4BDA0</code>（3 字节）</li><li><code>😊</code> → <code>U+1F60A</code> → <code>0xF09F988A</code>（4 字节）</li></ul></li><li><p><mark>8-bit 编码 主要指 每个字符占 1 个字节（8 位） 的旧式编码</mark>，常见的包括</p><ul><li>ASCII：标准 ASCII 只使用 7-bit（128 个字符），由于 7-bit 只能表示 128 个字符，后来扩展到 8-bit（256 个字符）</li><li>ISO-8859-1：用于西欧语言，支持法语、德语、西班牙语等， 但不支持中文</li><li>GB2312 (6,763个汉字) / GBK(21,003个汉字) / GB18030（Unicode所有汉字）</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>code</category>
      
      <category>LaTex</category>
      
    </categories>
    
    
    <tags>
      
      <tag>LaTex</tag>
      
      <tag>pdflatex</tag>
      
      <tag>xulatex</tag>
      
      <tag>lualatex</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu系列 - 2. bash shell, terminal 和 ~/.bashrc</title>
    <link href="/2025/01/02/os/Ubuntu/ubuntu_2-shell-2025_01_02/"/>
    <url>/2025/01/02/os/Ubuntu/ubuntu_2-shell-2025_01_02/</url>
    
    <content type="html"><![CDATA[<h2 id="ubuntu-目录结构">1. Ubuntu 目录结构</h2><h3 id="用户主目录-homeusername">1.1 用户主目录 <code>~</code> = <code>/home/username/</code></h3><p>在 ubuntu 系统中，波浪线 <code>~</code> 在命令行环境下是 “用户主目录”（Home Directory）的缩写或别名。</p><p>例如 <code>~/.bashrc</code>: - <code>~</code> 代表的就是当前用户的主目录（<code>/home/username/</code>） - <code>~/.bashrc</code> 实际上就是 <code>/home/username/.bashrc</code></p><h2 id="shell-和-terminal">2. shell 和 terminal</h2><h3 id="shell-是什么">2.1 Shell 是什么</h3><p>Shell 是一种软件层，用来接收用户输入的命令，然后将这些命令传递给操作系统内核去执行。也可以理解为人与操作系统之间的“翻译”或“交互接口”。 ### 2.2 Shell 的种类 - bash Shell: Ubuntu 默认的 Shell - zsh Shell - fish Shell - csh/tcsh Shell</p><p>每种 Shell 都有自己的语法特性、配置文件和内置工具，但它们的基本功能相似：<strong>运行命令、编写脚本、管理进程和环境变量</strong>等。</p><h3 id="常用的-shell-配置文件">2.3 常用的 Shell 配置文件</h3><ul><li><code>~/.bashrc</code>: bash Shell 的配置文件</li><li><code>~/.zshrc</code>: zsh Shell 的配置文件</li><li><code>~/.config/fish/config.fish</code>: fish Shell 的配置文件</li></ul><h3 id="shell-的工作流程">2.4 Shell 的工作流程</h3><ul><li>读取用户输入的命令</li><li>解释和解析命令，交给操作系统</li><li>显示执行结果</li></ul><h3 id="常用的-shell-命令">2.5 常用的 Shell 命令</h3><ul><li><code>echo</code>: 打印文本或变量的值</li><li><code>cd</code>: 改变当前目录</li><li><code>ls</code>: 列出当前目录中的文件和文件夹</li></ul><h3 id="常用的-shell-快捷键">2.6 常用的 Shell 快捷键</h3><ul><li><code>Ctrl + L</code>: 清屏</li><li><code>Ctrl + C</code>: 中断当前命令</li><li><code>Ctrl + D</code>: 退出当前 Shell</li></ul><h3 id="什么是-terminal">2.7 什么是 terminal</h3><ul><li>“终端” 指的是实际的<strong>硬件设备</strong>（如显示器/键盘），通过串口或其他方式连到主机。</li><li>Ubuntu 的 terminal 是一个 “终端” 的<strong>软件模拟器</strong></li></ul><h3 id="terminal-和-shell-的关系">2.8 terminal 和 shell 的关系</h3><ul><li>terminal: 是一个 “文本交互界面”, 提供了一个文本窗口，允许用户在其中输入命令、接收输出</li><li>shell: 是一个命令行解释器，它接收用户在 terminal 内输入的命令，并将其传递给操作系统内核去执行。</li><li>Terminal：<mark>相当于“聊天窗口”</mark></li><li>Shell：<mark>相当于“对话的另一端的人”（或自动回复程序）</mark></li></ul><h3 id="例子">2.9 例子</h3><ul><li>在 Ubuntu 的 terminal 里输入一条命令： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> -l<br></code></pre></td></tr></table></figure></li><li>Terminal 会把这条文本交给正在运行的 Shell（一般是 Bash）</li><li>Bash 解析这条命令，调用相应的系统调用或程序来列出目录下的文件和文件夹</li><li>然后 Bash 把执行结果返回给 Terminal，Terminal 再把结果显示给用户</li></ul><h2 id="配置脚本文件-.bashrc">3. 配置脚本文件 <code>~/.bashrc</code></h2><h3 id="terminalshell-启动流程">3.1 terminal/shell 启动流程</h3><p>在 <code>Ubuntu</code> 系统中，点开 <code>terminal</code> 图标，新开一个 <code>terminal</code> 窗口时，会发生以下事情：</p><ul><li>启动一个终端模拟器 <code>terminal</code>，它会创建一个<strong>非登录、交互式</strong>的 <code>Bash Shell</code>。</li><li><code>Bash Shell</code> 尝试查找并读取 <code>/etc/bash.bashrc</code>（系统全局的 bashrc，可选）</li><li><code>Bash Shell</code> 尝试查找并读取当前用户的 <code>~/.bashrc</code>（用户自定义的 bashrc）</li><li><code>Bash Shell</code> 环境初始化完成，用户在就可以正常使用终端了。</li></ul><h3 id="bashrc-的功能">3.2 <code>~/.bashrc</code> 的功能</h3><ul><li><p>初始化 Shell</p></li><li><p>定义/修改 <code>PATH</code> 等<strong>环境变量</strong> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> PATH=<span class="hljs-string">&quot;<span class="hljs-variable">$HOME</span>/bin:<span class="hljs-variable">$PATH</span>&quot;</span><br><span class="hljs-built_in">export</span> EDITOR=vim<br></code></pre></td></tr></table></figure></p></li><li><p>为常用命令设置别名（alias），简化输入，例如 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">alias</span> ll=<span class="hljs-string">&#x27;ls -l&#x27;</span><br><span class="hljs-built_in">alias</span> gs=<span class="hljs-string">&#x27;git status&#x27;</span><br></code></pre></td></tr></table></figure></p></li><li><p>让 <code>~/.bashrc</code> 的修改立即生效（以下两个指令等价）： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ~/.bashrc<br>. ~/.bashrc<br></code></pre></td></tr></table></figure></p></li><li><p>配置命令提示符（PS1）：命令行中看到的提示符样式，就是由 PS1 的配置决定的 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">PS1=<span class="hljs-string">&quot;\u@\h:\w\$ &quot;</span><br></code></pre></td></tr></table></figure></p><ul><li><code>PS1</code>: Bash 中用于定义主提示符（Primary Prompt）的变量</li><li><code>\u</code>：当前用户名（user name）</li><li><code>\h</code>：当前主机名（host name）中的前半部分（不含域名）</li><li><code>\w</code>：当前工作目录（working directory），会以相对路径显示，如果是 home 目录则显示 ~</li><li><code>\$</code>：如果是普通用户则显示 <code>$</code>，如果是 <code>root</code> 用户（即超级用户）则显示 <code>#</code></li><li>最后的空格: 是为了让命令提示符后留出一个空格，便于输入命令</li></ul></li></ul><h3 id="不同类型的-shell-的-bash-启动流程">2.3 不同类型的 Shell 的 Bash 启动流程</h3><ul><li><strong>登录Shell</strong>（Login Shell）<ul><li>通过 <code>SSH</code> 登录远程主机，或者在系统中输入 用户名/密码 直接登录时，启动的 Shell 就是 <code>登录Shell</code></li><li>这种情况下，<code>Bash Shell</code> 会先读取并执行 <code>/etc/profile</code>，然后依次读取 <code>~/.bash_profile</code>, <code>~/.bash_login</code>, <code>~/.profile</code>（谁先被找到就执行哪个，通常系统会默认用 <code>~/.bash_profile</code> 或 <code>~/.profile</code>）</li></ul></li><li><strong>非登录Shell</strong>（Non-login Shell）<ul><li>在图形界面下打开一个 Terminal: 通常是通过 <code>Ctrl + Alt + T</code> 快捷键打开的终端，或者通过 <code>gnome-terminal</code> 命令打开的终端</li><li>这种情况下，<code>Bash Shell</code> 只会读取并执行 <code>~/.bashrc</code></li></ul></li><li><strong>交互式</strong>（Interactive）与<strong>非交互式</strong>（Non-interactive）<ul><li>交互式 Shell：用户与 Shell 之间的交互，例如通过 <code>Ctrl + Alt + T</code> 快捷键打开的终端，用户可以通过键盘输入命令</li><li>非交互式 Shell：Shell 不与用户交互，例如通过脚本执行命令（脚本首行需要写 <code>#!/usr/bin/env bash</code>）</li></ul></li></ul><p>总结：<code>~/.bashrc</code> <mark><strong>默认只在“非登录式且交互式”的 Bash Shell 启动时被读取执行</strong></mark></p>]]></content>
    
    
    <categories>
      
      <category>os</category>
      
      <category>Ubuntu</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ubuntu</tag>
      
      <tag>AppImage</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/01/01/hello-world/"/>
    <url>/2025/01/01/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">code:</span><br>  <span class="hljs-attr">copy_btn:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 开启复制按钮</span><br>  <span class="hljs-attr">language:</span> <span class="hljs-comment"># 代码语言</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">default:</span> <span class="hljs-string">&quot;TEXT&quot;</span><br>  <span class="hljs-attr">highlight:</span> <span class="hljs-comment"># 代码高亮</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">line_number:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 代码块是否显示行号</span><br>    <span class="hljs-attr">lib:</span> <span class="hljs-string">&quot;highlightjs&quot;</span> <span class="hljs-comment"># 实现高亮的库（highlightjs | prismjs）二选一，对应下面的设置</span><br><br>    <span class="hljs-attr">highlightjs:</span><br>      <span class="hljs-attr">style:</span> <span class="hljs-string">&quot;gradient-dark&quot;</span> <span class="hljs-comment"># （style 选项参考https://highlightjs.org/demo/）</span><br>      <span class="hljs-attr">style_dark:</span> <span class="hljs-string">&quot;dark&quot;</span><br><br>    <span class="hljs-attr">prismjs:</span><br>      <span class="hljs-comment"># 在下方链接页面右侧的圆形按钮挑选 style 填入，也可以直接填入 css 链接</span><br>      <span class="hljs-comment"># Select the style button on the right side of the link page, you can also set the CSS link</span><br>      <span class="hljs-comment"># See: https://prismjs.com/</span><br>      <span class="hljs-attr">style:</span> <span class="hljs-string">&quot;default&quot;</span><br>      <span class="hljs-attr">style_dark:</span> <span class="hljs-string">&quot;tomorrow night&quot;</span><br><br>      <span class="hljs-comment"># 设为 true 高亮将本地静态生成（但只支持部分 prismjs 插件），设为 false 高亮将在浏览器通过 js 生成</span><br>      <span class="hljs-comment"># If true, it will be generated locally (but some prismjs plugins are not supported). If false, it will be generated via JS in the browser</span><br>      <span class="hljs-attr">preprocess:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu系列 - 1. 安装AppImage应用</title>
    <link href="/2025/01/01/os/Ubuntu/ubuntu_1-install-2025_01_01/"/>
    <url>/2025/01/01/os/Ubuntu/ubuntu_1-install-2025_01_01/</url>
    
    <content type="html"><![CDATA[<p>AppImage 是一种便携式软件包格式，允许你在 Linux 上运行应用程序 无需安装。以下是下载、运行和管理 AppImage 文件的方法</p><h2 id="下载-appimage-文件">1. 下载 AppImage 文件</h2><h2 id="赋予-appimage-文件可执行权限">2. 赋予 AppImage 文件可执行权限</h2><p>AppImage 文件运行需要赋予权限，以下是赋予权限的两种方式。</p><h3 id="方法1使用终端">方法1：使用终端</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Powershell">chmod +x ~/Downloads/your_app.AppImage<br>./your_app.AppImage<br></code></pre></td></tr></table></figure><h3 id="方法2使用图形界面">方法2：使用图形界面</h3><ul><li>右键点击 AppImage 文件，选择 “属性”（Properties）。</li><li>切换到 “权限”（Permissions） 选项卡。</li><li>勾选 “允许作为可执行文件”（Allow executing file as a program）。</li><li>双击 AppImage 运行程序。</li></ul><h2 id="使用-appimagelauncher-管理-appimage">3. 使用 AppImageLauncher 管理 AppImage</h2><p>AppImage 默认不会自动出现在应用菜单中。</p><p>AppImageLauncher 可以自动管理 AppImage 并集成到系统菜单中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> add-apt-repository ppa:appimagelauncher-team/stable<br><span class="hljs-built_in">sudo</span> apt update<br><span class="hljs-built_in">sudo</span> apt install appimagelauncher<br></code></pre></td></tr></table></figure><h2 id="将-appimage-移动到-opt-并创建全局快捷方式">4. 将 AppImage 移动到 /opt 并创建全局快捷方式</h2><p>如果你希望让 AppImage 可在整个系统中使用</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Powershell">sudo <span class="hljs-built_in">mv</span> ~/Downloads/your_app.AppImage /opt/your_app.AppImage<br>sudo chmod +x /opt/your_app.AppImage<br>sudo ln <span class="hljs-literal">-s</span> /opt/your_app.AppImage /usr/local/bin/your_app<br></code></pre></td></tr></table></figure><h2 id="更新-appimage">5. 更新 AppImage</h2><p>部分 AppImage 支持自动更新，例如： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./your_app.AppImage --update<br></code></pre></td></tr></table></figure> 如果 AppImage 不支持更新，你需要手动下载新版并替换旧版。</p><h2 id="删除-appimage">6. 删除 AppImage</h2><p>由于 AppImage 是一个独立的可执行文件，删除它就等于卸载：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Powershell"><span class="hljs-built_in">rm</span> ~/Downloads/your_app.AppImage<br></code></pre></td></tr></table></figure><p>如果你用 AppImageLauncher 集成了 AppImage，可以在 /Applications 目录中找到它，并右键选择 “删除”。</p><h2 id="hugo-部署到-github-pages">6.Hugo 部署到 Github Pages 🚀</h2>]]></content>
    
    
    <categories>
      
      <category>os</category>
      
      <category>Ubuntu</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ubuntu</tag>
      
      <tag>AppImage</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>配电网系列 - 1. 介绍</title>
    <link href="/2020/11/17/application/DistributionNetwork/DistributionNetwork_1/"/>
    <url>/2020/11/17/application/DistributionNetwork/DistributionNetwork_1/</url>
    
    <content type="html"><![CDATA[<p>test</p>]]></content>
    
    
    <categories>
      
      <category>application</category>
      
      <category>DistriNet</category>
      
    </categories>
    
    
    <tags>
      
      <tag>配电网</tag>
      
      <tag>IEEE33</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深度学习 - 1. test</title>
    <link href="/2020/11/15/ai/dl/DeepLearning_1/"/>
    <url>/2020/11/15/ai/dl/DeepLearning_1/</url>
    
    <content type="html"><![CDATA[<p>test</p>]]></content>
    
    
    <categories>
      
      <category>ai</category>
      
      <category>dl</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ai</tag>
      
      <tag>Deep Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>强化学习系列 - 1. test</title>
    <link href="/2020/11/15/ai/rl/rl_1/"/>
    <url>/2020/11/15/ai/rl/rl_1/</url>
    
    <content type="html"><![CDATA[<p>test</p>]]></content>
    
    
    <categories>
      
      <category>ai</category>
      
      <category>rl</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ai</tag>
      
      <tag>Reinforcement Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习 - 1. test</title>
    <link href="/2020/11/15/ai/ml/MachineLearning_1/"/>
    <url>/2020/11/15/ai/ml/MachineLearning_1/</url>
    
    <content type="html"><![CDATA[<p>test</p>]]></content>
    
    
    <categories>
      
      <category>ai</category>
      
      <category>ml</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ai</tag>
      
      <tag>Machine Learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>鲁棒控制系列 - 1. test</title>
    <link href="/2020/11/15/ctrl/robust_ctrl/robust_ctrl_1/"/>
    <url>/2020/11/15/ctrl/robust_ctrl/robust_ctrl_1/</url>
    
    <content type="html"><![CDATA[<p>test</p>]]></content>
    
    
    <categories>
      
      <category>ctrl</category>
      
      <category>robust-ctrl</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctrl</tag>
      
      <tag>robust control</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自适应控制系列 - 1. test</title>
    <link href="/2020/11/15/ctrl/adapt_ctrl/adap_ctrl_1/"/>
    <url>/2020/11/15/ctrl/adapt_ctrl/adap_ctrl_1/</url>
    
    <content type="html"><![CDATA[<p>test</p>]]></content>
    
    
    <categories>
      
      <category>ctrl</category>
      
      <category>adapt-ctrl</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctrl</tag>
      
      <tag>adaptive control</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最优控制系列 - 1. test</title>
    <link href="/2020/11/15/opt/opt_ctrl/opt_ctrl_1/"/>
    <url>/2020/11/15/opt/opt_ctrl/opt_ctrl_1/</url>
    
    <content type="html"><![CDATA[<p>test</p>]]></content>
    
    
    <categories>
      
      <category>opt</category>
      
      <category>opt-ctrl</category>
      
    </categories>
    
    
    <tags>
      
      <tag>opt</tag>
      
      <tag>optimal control</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>凸优化系列 - 1. test</title>
    <link href="/2020/11/15/opt/opt_cvx/opt_cvx_1/"/>
    <url>/2020/11/15/opt/opt_cvx/opt_cvx_1/</url>
    
    <content type="html"><![CDATA[<p>test</p>]]></content>
    
    
    <categories>
      
      <category>opt</category>
      
      <category>opt-cvx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>opt</tag>
      
      <tag>convex optimization</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>神经网络 - 1. test</title>
    <link href="/2020/11/15/ai/nn/NeuralNetwork_1/"/>
    <url>/2020/11/15/ai/nn/NeuralNetwork_1/</url>
    
    <content type="html"><![CDATA[<p>test</p>]]></content>
    
    
    <categories>
      
      <category>ai</category>
      
      <category>nn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ai</tag>
      
      <tag>Neural Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ADP 系列 - 1. 策略迭代（Policy Iteration）</title>
    <link href="/2020/11/15/opt/adp/adp_1/"/>
    <url>/2020/11/15/opt/adp/adp_1/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>opt</category>
      
      <category>adp</category>
      
    </categories>
    
    
    <tags>
      
      <tag>opt</tag>
      
      <tag>ADP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>优化基础系列 - 1. test</title>
    <link href="/2020/11/15/opt/opt_basics/opt_basics_1/"/>
    <url>/2020/11/15/opt/opt_basics/opt_basics_1/</url>
    
    <content type="html"><![CDATA[<p>test</p>]]></content>
    
    
    <categories>
      
      <category>opt</category>
      
      <category>opt-basics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>opt</tag>
      
      <tag>optimization basics</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>随机分析系列 - 1. 测试</title>
    <link href="/2020/11/15/math/Stochastic/Stochastic_1/"/>
    <url>/2020/11/15/math/Stochastic/Stochastic_1/</url>
    
    <content type="html"><![CDATA[<p>test</p>]]></content>
    
    
    <categories>
      
      <category>math</category>
      
      <category>StoAnalysis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>math</tag>
      
      <tag>Stochastic Analysis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微分方程 - 1. test</title>
    <link href="/2020/11/15/math/DifferentialEquation/DifferentialEquation_1/"/>
    <url>/2020/11/15/math/DifferentialEquation/DifferentialEquation_1/</url>
    
    <content type="html"><![CDATA[<p>test</p>]]></content>
    
    
    <categories>
      
      <category>math</category>
      
      <category>DiffEqn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>math</tag>
      
      <tag>DiffEqn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>李群与李代数 - 1. test</title>
    <link href="/2020/11/15/math/LieAlgebra/LieAlgebra_1/"/>
    <url>/2020/11/15/math/LieAlgebra/LieAlgebra_1/</url>
    
    <content type="html"><![CDATA[<p>test</p>]]></content>
    
    
    <categories>
      
      <category>math</category>
      
      <category>LieAlgebra</category>
      
    </categories>
    
    
    <tags>
      
      <tag>math</tag>
      
      <tag>LieAlgebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数值计算系列 - 1. 测试</title>
    <link href="/2020/11/15/math/Numeric/Numeric_1/"/>
    <url>/2020/11/15/math/Numeric/Numeric_1/</url>
    
    <content type="html"><![CDATA[<p>test</p>]]></content>
    
    
    <categories>
      
      <category>math</category>
      
      <category>NumAnalysis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>math</tag>
      
      <tag>Numeric Analysis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线性代数 - 1. test</title>
    <link href="/2020/11/15/math/LinearAlgebra/LinearAlgebra_1/"/>
    <url>/2020/11/15/math/LinearAlgebra/LinearAlgebra_1/</url>
    
    <content type="html"><![CDATA[<p>test</p>]]></content>
    
    
    <categories>
      
      <category>math</category>
      
      <category>LinAlgebra</category>
      
    </categories>
    
    
    <tags>
      
      <tag>math</tag>
      
      <tag>LinAlgebra</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
