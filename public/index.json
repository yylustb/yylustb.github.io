[{"content":"使用批处理（自动添加右键菜单） 如果不想手动修改注册表，可以运行以下 批处理脚本 来自动添加。\n步骤 新建一个 add_vscode_context_menu.bat 文件\n复制以下代码 并粘贴进去 (注意修改 VS code 安装路径)：\n1 2 3 4 5 @echo off REG ADD \u0026#34;HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\Open with VS Code\u0026#34; /ve /t REG_SZ /d \u0026#34;在此处打开 VS Code\u0026#34; /f REG ADD \u0026#34;HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\Open with VS Code\\command\u0026#34; /ve /t REG_SZ /d \u0026#34;\\\u0026#34;C:\\Users\\%USERNAME%\\AppData\\Local\\Programs\\Microsoft VS Code\\Code.exe\\\u0026#34; \\\u0026#34;%%V\\\u0026#34;\u0026#34; /f echo VS Code 右键菜单添加成功！ pause 右键点击该 .bat 文件，选择 以管理员身份运行\n运行完毕后，右键点击文件夹空白处，看看是否出现 \u0026ldquo;在此处打开 VS Code\u0026rdquo; 选项。\n","permalink":"http://localhost:1313/posts/other/2025-02-27/","summary":"VS code设置","title":"VS code设置：右击文件夹出现“在这里打开 VS code”选项"},{"content":"在 LaTeX 生态中，latex、pdflatex、xelatex 和 lualatex 是不同的编译引擎，各自有不同的特点和适用场景。\n1. latex 最古老的 LaTeX 编译器，输出的是 DVI 文件，不是 PDF 文件 需要使用 dvips 或 dvipdf 等工具将 DVI 文件转换为 PDF 文件（latex → DVI → PS → PDF）。 不支持直接插入 PNG、JPEG、PDF 等图片格式，只支持 EPS 格式。 不支持直接插入中文，需要使用 xeCJK 或 CJK 宏包。 2. pdflatex 直接生成 PDF 文件（不需要使用 dvips 或 dvipdf 等转换工具）。 支持直接插入 PNG、JPEG、PDF 等图片格式（但不支持 EPS 格式）。 不支持 Unicode，默认采用 8-bit 编码（如 latin1、utf8 需用 inputenc 宏包） 对中文支持较差，需要 CJK 宏包（或 ctex 宏包）。 适合英文和西方语言文档（默认 8-bit 编码） 如果一定要用 pdflatex 处理中文，需要 1 \\usepackage[CJKutf8]{CJK} 3. xelatex 直接生成 PDF 文件（不需要使用 dvips 或 dvipdf 等转换工具）。 支持 Unicode，默认采用 UTF-8 编码，适用于多语言文档（包括中文） 支持 OpenType/TrueType（OTF/TTF）字体，可以直接使用系统字体（如宋体、楷体、黑体、SimSun、SimHei 等） 支持 fontspec 宏包，使字体管理更灵活。 支持直接插入 PNG、JPEG、PDF 等图片格式（但不支持 EPS 格式）。 CTeX 默认推荐 xelatex 4. lualatex（推荐用于高级应用，如 Lua 代码交互） 支持 Unicode 和 OpenType 字体。 支持 fontspec 宏包（字体管理）。 支持 luacode 宏包，可以在 LaTeX 代码中直接写 Lua 代码，例如： 1 2 3 4 \\usepackage{luacode} \\begin{luacode} tex.print(\u0026#34;你好，LuaLaTeX！\u0026#34;) \\end{luacode} 5. 总结 编译器 是否支持 Unicode 直接输出 PDF 适用于中文 图片支持 推荐用途 latex ❌ 否 ❌ 需转换 ❌ 需 CJK 仅支持 EPS 过时，基本不用 pdflatex ❌ 否 ✅ 是 ⚠️ 需 CJK PNG、JPEG、PDF 适用于英文或简单中文 xelatex ✅ 是 ✅ 是 ✅ 推荐 PNG、JPEG、PDF 推荐中文文档、支持系统字体 lualatex ✅ 是 ✅ 是 ✅ 推荐 PNG、JPEG、PDF 高级排版、动态 Lua 代码 小贴士 Unicode 是字符集，定义了世界上所有语言的字符例如\nA → U+0041 你 → U+4F60 😊 → U+1F60A 但Unicode 只规定了字符编号（码点），并没有规定如何存储这些字符。\n计算机只能存储 二进制数据（0 和 1），所以我们需要 字符编码（Character Encoding）把 Unicode 转换成二进制。\nUTF-8 是 Unicode 的一种编码方式，是一种 可变长度的 Unicode 编码\n1 个字节（8-bit） 表示 ASCII 字符（兼容英语）。 2~4 个字节 表示其他 Unicode 字符（如中文、Emoji）。 A → U+0041 → 0x41（1 字节） 你 → U+4F60 → 0xE4BDA0（3 字节） 😊 → U+1F60A → 0xF09F988A（4 字节） 8-bit 编码 主要指 每个字符占 1 个字节（8 位） 的旧式编码，常见的包括\nASCII：标准 ASCII 只使用 7-bit（128 个字符），由于 7-bit 只能表示 128 个字符，后来扩展到 8-bit（256 个字符） ISO-8859-1：用于西欧语言，支持法语、德语、西班牙语等， 但不支持中文 GB2312 (6,763个汉字) / GBK(21,003个汉字) / GB18030（Unicode所有汉字） ","permalink":"http://localhost:1313/posts/latex/2025-02-24-latex/","summary":"Learn About LaTex","title":"LaTex 系列 - 1. LaTex 编译器介绍"},{"content":"1. 安装git 这里没什么好说的，官网下载，默认安装。\n2. 配置 git 用户信息 2.1 配置 Git 用户信息 1 2 git config --global user.name \u0026#34;GitHub用户名\u0026#34; # 不需要引号 git config --global user.email \u0026#34;GitHub邮箱\u0026#34; # 不需要引号 2.2 设置 SSH Key 生成 SSH Key\n1 ssh-keygen -t rsa -b 4096 -C \u0026#34;GitHub邮箱\u0026#34; # 不需要引号 -t rsa：使用 RSA 加密算法 -b 4096：密钥长度为 4096 位（更安全） -C \u0026quot;GitHub邮箱\u0026quot;：标识 SSH Key，方便管理 接下来 terminal 提示：\n1 Enter file in which to save the key (/home/user/.ssh/id_rsa): 直接按回车即可（使用默认路径 ~/.ssh/id_rsa）\n接下来 terminal 提示输入密码：\n1 2 Enter passphrase (empty for no passphrase): Enter same passphrase again: 两次回车即可（默认不输入密码），否则每次推送 Git 都需要输入密码\n生成的 SSH密钥 存放在 ~/.ssh/id_rsa.pub\n2.3 将 SSH密钥 添加到 GitHub 账户的 SSH Keys 中 复制 SSH Key 1 cat ~/.ssh/id_rsa.pub 添加到 GitHub 登录 GitHub 账户 点击右上头像 -\u0026gt; Settings（设置） 左侧选择 SSH and GPG keys（SSH 和 GPG 密钥） 点击 New SSH key（新建 SSH 密钥） Title: 可以自定义 Key: 粘贴复制的 SSH Key 点击 Add SSH key 2.3 测试 SSH 连接 1 ssh -T git@github.com 如果配置成功，会显示：\n1 Hi \u0026lt;GitHub用户名\u0026gt;! You\u0026#39;ve successfully authenticated, but GitHub does not provide shell access. 3. 修改文件，提交到本地仓库 进入 path/to/your/workspace/XXX 文件夹，修改其中的文件 AAA.xx，然后执行以下命令：\n1 git status 执行后，会显示\n1 2 3 4 Changes not stated for commit: (use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to update what will be committed) (use \u0026#34;git restore \u0026lt;file\u0026gt;...\u0026#34; to discard changes in working directory) modified: AAA.xx 表明：\nAAA.xx 文件被修改 该文件的修改没有被添加到暂存区 接下来，执行以下命令：\n1 git add AAA.xx # 将 AAA.xx 文件添加到暂存区 再次执行以下命令\n1 git commit -m \u0026#34;第一次修改\u0026#34; # 将暂存区的文件提交到本地仓库，并添加提交备注信息 4. 本地仓库关联配置远程仓库（新建远程仓库后第一次推送） 首先，在 GitHub 上新建一个仓库 (Github 仓库新建后的默认分支是 main)\n本地仓库中文件每次修改后，如需推送，需要按顺序执行以下 Git 操作\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 1 切换到仓库根目录 cd \u0026#34;本地仓库路径\u0026#34; # 2 初始化 Git 仓库 git init # 3 添加所有文件到暂存区 git add . # 4 提交文件 git commit -m \u0026#34;Initial commit\u0026#34; # 5 origin = SSH，并且添加 origin（以后命令行可以用 origin 代表远程仓库） git remote add origin SSH地址 # 6 强制重命名本地仓库的当前分支为 main git branch -M main # 7 第一次推送：将本地的 main 分支推送到 GitHub git push -u origin main 注意：\nGit 仓库默认的主分支是 master，但 GitHub 仓库采用 main 作为默认分支，所以用命令 git branch -M main 将本地分支当前分支 master 改为 main。 第一次推送执行 git push -u origin main ，-u 选项将本地的 main 分支与远程的 origin/main 关联起来，使得后续推送和拉取更方便。 如果不使用 -u 选项，后续推送时需要使用 git push origin main。 使用了 -u 选项后，后续推送时可以直接使用 git push。 -u 的全写是 --set-upstream。 执行完上述指令后，打开 GitHub 仓库, 会看到本地仓库已经推送.\n5. 推送本地仓库到远程仓库（非第一次推送） 执行以下指令，推送本地仓库到远程仓库\n1 git push 执行以下指令，远程仓库拉取到本地仓库\n1 git pull 总结 SSH 密钥配置，不需要每次验证\n从远程仓库 clone 到本地：\ngit clone 远程仓库地址 本地仓库与远程仓库的关联配置（首次推送）：\ngit add . # 提交到暂存区 git commit -m \u0026quot;提交备注信息\u0026quot; # 提交到本地仓库 git remote add origin 远程仓库地址 # 将本地仓库与远程仓库关联 git remote -v # 查看远程仓库的信息 git branch -M main git push -u origin main # 将本地的当前分支与远程的 origin/main 关联并推送 本地仓库提交到远程仓库的流程（非首次推送）：\ngit add . # 提交到暂存区 git commit -m \u0026quot;提交备注信息\u0026quot; # 提交到本地仓库 git push # 提交到远程仓库 上面两条指令可以简化为下面一条指令\ngit commit -am \u0026quot;提交备注信息\u0026quot; # 提交到本地仓库 ","permalink":"http://localhost:1313/posts/git/2025-02-23-git-install/","summary":"Learn About Git \u0026amp; GitHub","title":"Git 系列 - 1. 安装 Git 与配置 Github"},{"content":"1.安装必要软件 一行代码搭建机器人开发环境(ROS/ROS2/ROSDEP)\n1 wget http://fishros.com/install -O fishros \u0026amp;\u0026amp; . fishros 选项：\n[1] 安装 noetic(ros1) [3] 安装 rosdep ","permalink":"http://localhost:1313/posts/git/2025-02-23-git-matlab/","summary":"Learn About Git \u0026amp; Matlab","title":"Git 系列 - 2. Matlab 同步 Git"},{"content":"原理 Texstudio 编译 A/main.tex，本质上是 cmd 进入路径 A，然后执行\n1 pdflatex main.tex 因为推送本地仓库到 github 需要在 cmd 执行 git 指令\n1 2 3 4 git add . git commit -m \u0026#34;First Submit\u0026#34; git branch -M main git push -u origin main 所以如果可以利用texstudio在tex文件路径执行上述指令，即可实现仅通过texstudio推送tex文件至github\nTexStudio 配置 texstudio 中如下配置\nTools -\u0026gt; User -\u0026gt; Git command 等价于在命令行当前目录下执行 Git command\n如何实现 第一次推送需要命令行，后续推送仅需texstudio\n第一次推送：\n1 2 3 4 5 6 git init git remote add origin github_SSH_address git add . # 每次推送执行 git commit -m \u0026#34;First Submit\u0026#34; # 每次推送执行 git branch -M main # 首次推送执行 git push -u origin main # 首次推送执行 后续推送/拉取：\n1 2 3 4 git add . # 每次推送执行 git commit -m \u0026#34;First Submit\u0026#34; # 每次推送执行 git push # 每次推送执行 git pull # 每次拉取执行 注意：上面两行命令等价于下面一行命令\n1 git commit -am \u0026#34;First Submit\u0026#34; # 每次推送执行 ","permalink":"http://localhost:1313/posts/git/2025-02-23-git-texstudio/","summary":"Learn About All Features in PaperMod","title":"Git 系列 - 3. Texstudio 同步 Git"},{"content":"1. 分支的本地操作 新建分支 新建分支 branch_A\n1 git branch branch_A 切换到分支 branch_A\n1 git checkout branch_A 新建分支 branch_B 并切换到分支 branch_B (下面一行效果等同于上面两行)\n1 git checkout -b branch_B 查看分支 查看本地分支\n1 git branch 查看远程分支\n1 git branch -r 查看所有分支\n1 git branch -a 合并分支 合并分支 branch_B 到分支 branch_A: 先切换到分支 branch_A，再执行 git merge\n1 2 git checkout branch_A # 切换当前分支为 branch_A git merge branch_B # 合并分支 branch_B 到当前分支 (branch_A) 删除分支 删除分支 branch_B\n1 2 git branch -d branch_B # 安全删除 git branch -D branch_B # 强制删除 2. 分支的远程操作 推送本地分支到远程仓库 本地分支 branch_A 推送到远程仓库\n1 git push origin branch_A 关联本地分支与远程分支\n删除远程分支 删除远程仓库 origin 的分支 branch_C\n1 git push origin --delete branch_C 注意，远程不一定叫origin，可以是其他名字。\n","permalink":"http://localhost:1313/posts/git/2025-02-23-git-branch/","summary":"Learn About Git \u0026amp; branch","title":"Git 系列 - 4. Git 分支管理"},{"content":"In this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates (extend_head.html) like so: refer ISSUE #236 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTex globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTex on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Block math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\n","permalink":"http://localhost:1313/posts/reinforcement_learning/2025-02-20-rl-pg/","summary":"Learn About DQN in Stochastic Policy Gradient","title":"强化学习系列 - 2. Stochastic Policy Gradient"},{"content":"AppImage 是一种便携式软件包格式，允许你在 Linux 上运行应用程序 无需安装。以下是下载、运行和管理 AppImage 文件的方法\n1. 下载 AppImage 文件 2. 赋予 AppImage 文件可执行权限 AppImage 文件运行需要赋予权限，以下是赋予权限的两种方式。\n方法1：使用终端 1 2 chmod +x ~/Downloads/your_app.AppImage ./your_app.AppImage 方法2：使用图形界面 右键点击 AppImage 文件，选择 \u0026ldquo;属性\u0026rdquo;（Properties）。 切换到 \u0026ldquo;权限\u0026rdquo;（Permissions） 选项卡。 勾选 \u0026ldquo;允许作为可执行文件\u0026rdquo;（Allow executing file as a program）。 双击 AppImage 运行程序。 3. 使用 AppImageLauncher 管理 AppImage AppImage 默认不会自动出现在应用菜单中。\nAppImageLauncher 可以自动管理 AppImage 并集成到系统菜单中\n1 2 3 sudo add-apt-repository ppa:appimagelauncher-team/stable sudo apt update sudo apt install appimagelauncher 4. 将 AppImage 移动到 /opt 并创建全局快捷方式 如果你希望让 AppImage 可在整个系统中使用\n1 2 3 sudo mv ~/Downloads/your_app.AppImage /opt/your_app.AppImage sudo chmod +x /opt/your_app.AppImage sudo ln -s /opt/your_app.AppImage /usr/local/bin/your_app 5. 更新 AppImage 部分 AppImage 支持自动更新，例如：\n1 ./your_app.AppImage --update 如果 AppImage 不支持更新，你需要手动下载新版并替换旧版。\n6. 删除 AppImage 由于 AppImage 是一个独立的可执行文件，删除它就等于卸载：\n1 rm ~/Downloads/your_app.AppImage 如果你用 AppImageLauncher 集成了 AppImage，可以在 /Applications 目录中找到它，并右键选择 \u0026ldquo;删除\u0026rdquo;。\n6.Hugo 部署到 Github Pages 🚀 ","permalink":"http://localhost:1313/posts/ubuntu/2025-02-17-ubuntu-appimage/","summary":"Learn About Ubuntu","title":"Ubuntu系列 - 1. 安装AppImage应用"},{"content":"1. Ubuntu 目录结构 1.1 用户主目录 ~ = /home/username/ 在 ubuntu 系统中，波浪线 ~ 在命令行环境下是 “用户主目录”（Home Directory）的缩写或别名。\n例如 ~/.bashrc:\n~ 代表的就是当前用户的主目录（/home/username/） ~/.bashrc 实际上就是 /home/username/.bashrc 2. shell 和 terminal 2.1 Shell 是什么 Shell 是一种软件层，用来接收用户输入的命令，然后将这些命令传递给操作系统内核去执行。也可以理解为人与操作系统之间的“翻译”或“交互接口”。\n2.2 Shell 的种类 bash Shell: Ubuntu 默认的 Shell zsh Shell fish Shell csh/tcsh Shell 每种 Shell 都有自己的语法特性、配置文件和内置工具，但它们的基本功能相似：运行命令、编写脚本、管理进程和环境变量等。\n2.3 常用的 Shell 配置文件 ~/.bashrc: bash Shell 的配置文件 ~/.zshrc: zsh Shell 的配置文件 ~/.config/fish/config.fish: fish Shell 的配置文件 2.4 Shell 的工作流程 读取用户输入的命令 解释和解析命令，交给操作系统 显示执行结果 2.5 常用的 Shell 命令 echo: 打印文本或变量的值 cd: 改变当前目录 ls: 列出当前目录中的文件和文件夹 2.6 常用的 Shell 快捷键 Ctrl + L: 清屏 Ctrl + C: 中断当前命令 Ctrl + D: 退出当前 Shell 2.7 什么是 terminal \u0026ldquo;终端\u0026rdquo; 指的是实际的硬件设备（如显示器/键盘），通过串口或其他方式连到主机。 Ubuntu 的 terminal 是一个 \u0026ldquo;终端\u0026rdquo; 的软件模拟器 2.8 terminal 和 shell 的关系 terminal: 是一个 “文本交互界面”, 提供了一个文本窗口，允许用户在其中输入命令、接收输出 shell: 是一个命令行解释器，它接收用户在 terminal 内输入的命令，并将其传递给操作系统内核去执行。 Terminal：相当于“聊天窗口” Shell：相当于“对话的另一端的人”（或自动回复程序） 2.9 例子 在 Ubuntu 的 terminal 里输入一条命令： 1 ls -l Terminal 会把这条文本交给正在运行的 Shell（一般是 Bash） Bash 解析这条命令，调用相应的系统调用或程序来列出目录下的文件和文件夹 然后 Bash 把执行结果返回给 Terminal，Terminal 再把结果显示给用户 3. 配置脚本文件 ~/.bashrc 3.1 terminal/shell 启动流程 在 Ubuntu 系统中，点开 terminal 图标，新开一个 terminal 窗口时，会发生以下事情：\n启动一个终端模拟器 terminal，它会创建一个非登录、交互式的 Bash Shell。 Bash Shell 尝试查找并读取 /etc/bash.bashrc（系统全局的 bashrc，可选） Bash Shell 尝试查找并读取当前用户的 ~/.bashrc（用户自定义的 bashrc） Bash Shell 环境初始化完成，用户在就可以正常使用终端了。 3.2 ~/.bashrc 的功能 初始化 Shell\n定义/修改 PATH 等环境变量\n1 2 export PATH=\u0026#34;$HOME/bin:$PATH\u0026#34; export EDITOR=vim 为常用命令设置别名（alias），简化输入，例如\n1 2 alias ll=\u0026#39;ls -l\u0026#39; alias gs=\u0026#39;git status\u0026#39; 让 ~/.bashrc 的修改立即生效（以下两个指令等价）：\n1 2 source ~/.bashrc . ~/.bashrc 配置命令提示符（PS1）：命令行中看到的提示符样式，就是由 PS1 的配置决定的\n1 PS1=\u0026#34;\\u@\\h:\\w\\$ \u0026#34; PS1: Bash 中用于定义主提示符（Primary Prompt）的变量 \\u：当前用户名（user name） \\h：当前主机名（host name）中的前半部分（不含域名） \\w：当前工作目录（working directory），会以相对路径显示，如果是 home 目录则显示 ~ \\$：如果是普通用户则显示 $，如果是 root 用户（即超级用户）则显示 # 最后的空格: 是为了让命令提示符后留出一个空格，便于输入命令 2.3 不同类型的 Shell 的 Bash 启动流程 登录Shell（Login Shell） 通过 SSH 登录远程主机，或者在系统中输入 用户名/密码 直接登录时，启动的 Shell 就是 登录Shell 这种情况下，Bash Shell 会先读取并执行 /etc/profile，然后依次读取 ~/.bash_profile, ~/.bash_login, ~/.profile（谁先被找到就执行哪个，通常系统会默认用 ~/.bash_profile 或 ~/.profile） 非登录Shell（Non-login Shell） 在图形界面下打开一个 Terminal: 通常是通过 Ctrl + Alt + T 快捷键打开的终端，或者通过 gnome-terminal 命令打开的终端 这种情况下，Bash Shell 只会读取并执行 ~/.bashrc 交互式（Interactive）与非交互式（Non-interactive） 交互式 Shell：用户与 Shell 之间的交互，例如通过 Ctrl + Alt + T 快捷键打开的终端，用户可以通过键盘输入命令 非交互式 Shell：Shell 不与用户交互，例如通过脚本执行命令（脚本首行需要写 #!/usr/bin/env bash） 总结：~/.bashrc 默认只在“非登录式且交互式”的 Bash Shell 启动时被读取执行\n","permalink":"http://localhost:1313/posts/ubuntu/2025-02-23-ubuntu-shell/","summary":"Learn About Ubuntu","title":"Ubuntu系列 - 2. bash shell, terminal 和 ~/.bashrc"},{"content":"1.DQN 算法流程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 # 0. 初始化 # 0.1 初始化环境 env env = # 0.2 初始化 DQN q(s, a; θ) = q_(s, a; θ_) = # 0.3 初始化经验回放库 Buffer replay_buffer = # 主循环：N 个 episode for episode = 1 to M: # 1. 初始化 s_t = env.reset() # 初始化状态 s_t episode_return = 0 # 初始化累计回报 episode_return # 每个 episode done = False while not done: # 2. 以 ε-贪婪策略生成动作 a_t a_t = argmax_a Q(s_t, a; θ) or random # 3. 执行动作 a_t，得到奖励 r_t、新状态 s_{t+1}、以及游戏结束标志 done s_{t+1}, r_t, done, _ = env.step(a_t) # 4. 存储一次交互数据 (s_t, a_t, r_t, φ_{t+1}, done) 至经验回放库 replay_buffer replay_buffer.append( (s_t, a_t, r_t, s_{t+1}, done) ) # 5. 当 replay_buffer 数据量满足最小长度 (比如500)，从 replay_buffer 中随机抽取一批数据 batch \u0026lt;- {s_j, a_j, r_j, s_{j+1}, done_j}, j = 1, ..., minimal_size（ batch 数据量为 minimal_size ） if len(Buffer) \u0026gt; 500: batch \u0026lt;- replay_buffer( 1, ..., minimal_size ) # 6. 利用采样数据 batch 训练 DQN DQN.train(batch) # 7. 更新状态 s_t \u0026lt;- s_{t+1} s_t = s_{t+1} # 8. 更新累计回报 episode_return += reward # 更新累计回报 if done: break ","permalink":"http://localhost:1313/posts/reinforcement_learning/2025-02-16-rl-dqn/","summary":"Learn About DQN in RL","title":"强化学习系列 - 1. DQN"},{"content":"1. PyTorch 中使用 TensorBoard 通过 SummaryWriter 记录数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 import torch import torch.nn as nn import torch.optim as optim from torch.utils.tensorboard import SummaryWriter import numpy as np # 初始化 TensorBoard 记录器 writer = SummaryWriter(log_dir=\u0026#34;runs/experiment_1\u0026#34;) # 创建一个简单的模型 model = nn.Linear(1, 1) criterion = nn.MSELoss() optimizer = optim.SGD(model.parameters(), lr=0.01) # 训练循环 for epoch in range(100): x = torch.tensor([[epoch]], dtype=torch.float32) y = torch.tensor([[2 * epoch + 1]], dtype=torch.float32) output = model(x) loss = criterion(output, y) optimizer.zero_grad() loss.backward() optimizer.step() # 记录损失 writer.add_scalar(\u0026#34;Loss/train\u0026#34;, loss.item(), epoch) # 记录权重和梯度 for name, param in model.named_parameters(): writer.add_histogram(name, param, epoch) writer.add_histogram(f\u0026#34;{name}.grad\u0026#34;, param.grad, epoch) writer.close() 在终端启动 TensorBoard\n1 tensorboard --logdir=runs --port=6006 2. TensorFlow 中使用 TensorBoard 记录数据（不需要 SummaryWriter）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import tensorflow as tf import datetime # 创建日志目录 log_dir = \u0026#34;logs/fit/\u0026#34; + datetime.datetime.now().strftime(\u0026#34;%Y%m%d-%H%M%S\u0026#34;) tensorboard_callback = tf.keras.callbacks.TensorBoard(log_dir=log_dir, histogram_freq=1) # 创建一个简单模型，指定 NN 结构 model = tf.keras.Sequential([ tf.keras.layers.Dense(128, activation=\u0026#39;relu\u0026#39;), tf.keras.layers.Dense(10) ]) # 指定NN训练方法为 adam, 损失函数为 SparseCategoricalCrossentropy model.compile(optimizer=\u0026#39;adam\u0026#39;, loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True), metrics=[\u0026#39;accuracy\u0026#39;]) # 训练模型，并使用 TensorBoard 记录 model.fit( tf.random.normal([1000, 32]), tf.random.uniform([1000], maxval=10, dtype=tf.int32), epochs=5, callbacks=[tensorboard_callback] ) 在终端启动 TensorBoard\n1 tensorboard --logdir=logs/fit --port=6006 必选参数：\nhelp=\u0026quot;输入文件的路径\u0026quot;: 在 --help 命令中显示的参数说明 当执行脚本时，需要紧随其后提供必选参数 filename，否则会报错。例如（下面指令中的 input.txt 就是参数 \u0026ldquo;filename\u0026rdquo;） 1 python script.py input.txt 可选参数1：\n-v 和 --verbose: 代表同一个可选参数，用户可以使用任一形式。 action=\u0026quot;store_true\u0026quot;: 当这个选项被使用时，将在解析结果中把 verbose 设置为 True（不使用则为 False）。 help=\u0026quot;是否输出详细信息（布尔开关）\u0026quot;: help 中的内容会在 --help 命令中显示。 可选参数2：\ntype=int：将输入值转换为整数类型（如果传入值无法转换会报错）。 default=1：当用户没有提供该参数时，使用默认值 1。 定义完上面的代码文件后，在命令行的执行如下\n1 2 3 4 5 6 # 带所有参数 python script.py myfile.txt -v -n 3 # 或者：python script.py myfile.txt --verbose --number 3 # 不带可选参数 python script.py myfile.txt 3. 分析 为什么一个是 --logdir=runs 另一个是 --logdir=logs\nPyTorch 示例中，日志记录路径是 \u0026quot;runs/experiment_1\u0026quot;， runs/ 是 SummaryWriter(log_dir=\u0026quot;runs/experiment_1\u0026quot;) 指定的路径的父目录 TensorFlow 示例 中，日志记录路径是 \u0026quot;logs/fit/...\u0026quot;，logs/fit/ 是 log_dir 变量中的路径前缀 PyTorch 通常默认使用 \u0026quot;runs/\u0026quot; 作为日志目录，SummaryWriter 就是这么做的。 TensorFlow 示例中，通常使用 \u0026quot;logs/fit/\u0026quot; + datetime 作为日志目录，所以 TensorBoard 需要从 \u0026quot;logs/fit\u0026quot; 读取数据。 ","permalink":"http://localhost:1313/posts/python/2025-02-15-python-tensorboard/","summary":"Learn About argparse in Python","title":"Python 系列 - 2. tensorboard"},{"content":"1.安装必要软件 一行代码搭建机器人开发环境(ROS/ROS2/ROSDEP)\n1 wget http://fishros.com/install -O fishros \u0026amp;\u0026amp; . fishros 选项：\n[1] 安装 noetic(ros1) [3] 安装 rosdep ","permalink":"http://localhost:1313/posts/ros/2025-02-14-ros-install/","summary":"Learn About ROS1","title":"ROS1系列 - 1. 一键安装 ROS Neotic"},{"content":"1.什么是 argparse argparse 是一个强大的命令行参数解析工具，用于构建命令行脚本或程序时，可以非常方便地对传入的参数进行解释和处理。\n在编写命令行工具或脚本时，往往需要接收来自命令行的参数或选项，以实现配置。\nargparse 则能让你以更高层次、更结构化的方式来定义程序期望的参数形式，以及如何处理这些参数，从而自动生成帮助信息、错误信息等。\n2.基本用法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 import argparse def main(): \u0026#39;\u0026#39;\u0026#39;第一步：创建一个解析器对象，可以给出程序的简单描述\u0026#39;\u0026#39;\u0026#39; parser = argparse.ArgumentParser(description=\u0026#34;这是一个示例命令行工具\u0026#34;) \u0026#39;\u0026#39;\u0026#39;第二步：添加命令行参数和选项\u0026#39;\u0026#39;\u0026#39; # 添加必选参数: 在命令中不需要特意写 -x 或者 --xx ，是脚本必须要获取的数据。 parser.add_argument(\u0026#34;filename\u0026#34;, help=\u0026#34;输入文件的路径\u0026#34;) # 添加可选参数1：一般以短选项（如 -v）或长选项（如 --verbose）的形式出现。 parser.add_argument(\u0026#34;-v\u0026#34;, \u0026#34;--verbose\u0026#34;, action=\u0026#34;store_true\u0026#34;, help=\u0026#34;是否输出详细信息（布尔开关）\u0026#34; ) # 添加可选参数2：一般以短选项（如 -v）或长选项（如 --verbose）的形式出现。 parser.add_argument(\u0026#34;-n\u0026#34;, \u0026#34;--number\u0026#34;, type=int, default=1, help=\u0026#34;重复操作次数，默认为 1\u0026#34; ) # 添加可选参数3：接收某个范围或集合中的值 parser.add_argument(\u0026#34;--mode\u0026#34;, choices=[\u0026#34;train\u0026#34;, \u0026#34;test\u0026#34;, \u0026#34;eval\u0026#34;], help=\u0026#34;模式选择\u0026#34; ) # 添加可选参数4：指定参数的别名 parser.add_argument(\u0026#34;-m\u0026#34;, \u0026#34;--mode\u0026#34;, choices=[\u0026#34;train\u0026#34;, \u0026#34;test\u0026#34;, \u0026#34;eval\u0026#34;] ) \u0026#39;\u0026#39;\u0026#39;第三步：解析命令行参数\u0026#39;\u0026#39;\u0026#39; # args 就是一个包含解析后参数的命名空间对象, 属性名即为参数名。 args = parser.parse_args() # 通过 args.filename 访问参数 filename print(\u0026#34;文件名：\u0026#34;, args.filename) print(\u0026#34;是否详细输出：\u0026#34;, args.verbose) print(\u0026#34;操作次数：\u0026#34;, args.number) if __name__ == \u0026#34;__main__\u0026#34;: main() 必选参数：\nhelp=\u0026quot;输入文件的路径\u0026quot;: 在 --help 命令中显示的参数说明 当执行脚本时，需要紧随其后提供必选参数 filename，否则会报错。例如（下面指令中的 input.txt 就是参数 \u0026ldquo;filename\u0026rdquo;） 1 python script.py input.txt 可选参数1：\n-v 和 --verbose: 代表同一个可选参数，用户可以使用任一形式。 action=\u0026quot;store_true\u0026quot;: 当这个选项被使用时，将在解析结果中把 verbose 设置为 True（不使用则为 False）。 help=\u0026quot;是否输出详细信息（布尔开关）\u0026quot;: help 中的内容会在 --help 命令中显示。 可选参数2：\ntype=int：将输入值转换为整数类型（如果传入值无法转换会报错）。 default=1：当用户没有提供该参数时，使用默认值 1。 定义完上面的代码文件后，在命令行的执行如下\n1 2 3 4 5 6 # 带所有参数 python script.py myfile.txt -v -n 3 # 或者：python script.py myfile.txt --verbose --number 3 # 不带可选参数 python script.py myfile.txt ","permalink":"http://localhost:1313/posts/python/2025-02-13-python-argparse/","summary":"Learn About argparse in Python","title":"Python 系列 - 1. 命令行解析器 argparse"},{"content":"1. 安装必要软件 按照以下顺序安装软件（因为相互依赖关系）\nGit\nPowershell 7.x\nwin11 自带 Powershell 的版本是 5.1，需要更新到 7.x。\n首先，在win11自带 Powershell 里输入以下指令，安装最新稳定版\n1 winget install --id Microsoft.Powershell --source winget 接下来的命令行操作都在 7.x 的 Powershell 内执行 。\nVS Code\nGo\ngo安装说明见官网 https://go.dev/doc/install\nGithub账户\nchoco\n参考官网 https://docs.chocolatey.org/en-us/choco/setup/ 安装choco，执行以下指令\n1 Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString(\u0026#39;https://community.chocolatey.org/install.ps1\u0026#39;)) Hugo\n执行以下指令，利用 choco 安装 hugo\n1 choco install hugo-extended Dart Sass\n执行以下指令，利用 choco 安装 Sass\n1 choco install sass 2. Hugo生成静态站点 Powershell 切换至文件夹 A，执行以下指令\n1 2 cd A hugo new site demo --format yaml 执行完上面指令后，hugo 会生成网站，网站根目录为 A/demo。\n注意：打开网站根目录 A/demo，会发现hugo生成了很多文件，其中最重要的是配置文件 hugo.yaml。 网站的配置文件，会略有区别。常见的配置文件有\nhugo.yaml / hugo.toml config.yaml / config.toml 切换路径至网站根目录 A/demo，执行 git 初始化，为后续步骤做准备。\n1 git init 3. Hugo配置Theme 安装 Hugo 主题，参考官网 Hugo themes，接下来我们以 papermod 为例\n安装 Hugo 主题 papermod，执行以下指令\n1 2 3 git submodule add --depth=1 https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod git submodule update --init --recursive # 当我们要从github上拉去仓库时需要这个指令 git submodule update --remote --merge 执行上述指令后，主题 papermod 会存放在路径 A/demo/themes/papermod。\n配置主题 papermod 的配置文件 hugo.yaml 如下：\n1 echo \u0026#34;theme = \u0026#39;ananke\u0026#39;\u0026#34; \u0026gt;\u0026gt; hugo.toml 执行完上面指令后，网站配置文件最后一行会添加以下内容\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 baseURL: https://yylustb.github.io/ languageCode: en-us title: My New Hugo Site theme: [\u0026#34;PaperMod\u0026#34;] paginate: 5 # 列表页显示文章数 # 默认支持首页 HTML 页面、RSS 订阅、JSON（搜索），可以满足大多数 Hugo 博客需求。 outputs: home: # 主页输出 - HTML - RSS - JSON markup: goldmark: # Hugo 默认使用的 Markdown 渲染引擎 renderer: unsafe: true # 控制是否允许在 Markdown 中渲染 “不安全（raw）” 的 HTML 标签 # 在 Markdown 文件中编写的原生 HTML（例如 \u0026lt;script\u0026gt;, \u0026lt;iframe\u0026gt; 或者其他 HTML 标签）， # 在最终生成的页面中会被原样保留并渲染 highlight: lineNos: true # 是否在代码高亮时显示行号 noClasses: false # 不要禁用 class codeFences: true # 启用 Markdown 代码块语法（```） style: \u0026#34;monokai\u0026#34; params: env: production title: ExampleSite # 站点的标题 description: \u0026#34;ExampleSite description\u0026#34; # 站点的描述信息 keywords: [Blog, Portfolio, PaperMod] # 站点的关键词，有助于 SEO author: Me # 站点的作者 # author: [\u0026#34;Me\u0026#34;, \u0026#34;You\u0026#34;] # multiple authors images: [\u0026#34;\u0026lt;link or path of image for opengraph, twitter-cards\u0026gt;\u0026#34;] # 用于社交分享时的默认封面图片 DateFormat: \u0026#34;January 2, 2006\u0026#34; # 文章日期的显示格式 defaultTheme: auto # dark, light # 站点默认主题模式（自动适应用户偏好） disableThemeToggle: false # 是否禁用深色/浅色模式切换 ShowReadingTime: true # 显示阅读时间 ShowShareButtons: true # 显示社交分享按钮 ShowPostNavLinks: true ShowBreadCrumbs: true ShowCodeCopyButtons: false ShowWordCount: true ShowRssButtonInSectionTermList: true # 在分类/标签页显示 RSS 订阅按钮 UseHugoToc: true disableSpecial1stPost: false disableScrollToTop: false comments: false hidemeta: false hideSummary: false # 是否隐藏文章摘要 showtoc: false # 是否显示文章目录 tocopen: false # 是否默认展开目录 assets: # disableHLJS: true # to disable highlight.js # disableFingerprinting: true favicon: \u0026#34;\u0026lt;link / abs url\u0026gt;\u0026#34; favicon16x16: \u0026#34;\u0026lt;link / abs url\u0026gt;\u0026#34; favicon32x32: \u0026#34;\u0026lt;link / abs url\u0026gt;\u0026#34; apple_touch_icon: \u0026#34;\u0026lt;link / abs url\u0026gt;\u0026#34; safari_pinned_tab: \u0026#34;\u0026lt;link / abs url\u0026gt;\u0026#34; label: text: \u0026#34;Home\u0026#34; icon: /apple-touch-icon.png iconHeight: 35 # profile-mode profileMode: enabled: false # needs to be explicitly set title: ExampleSite subtitle: \u0026#34;This is subtitle\u0026#34; imageUrl: \u0026#34;\u0026lt;img location\u0026gt;\u0026#34; imageWidth: 120 imageHeight: 120 imageTitle: my image buttons: - name: Posts url: posts - name: Tags url: tags homeInfoParams: # 主页信息模式（如果启用，会在主页显示欢迎信息） Title: \u0026#34;Hi there \\U0001F44B\u0026#34; # 主页欢迎信息标题 Content: Welcome to my blog # 主页欢迎信息内容 socialIcons: - name: x url: \u0026#34;https://x.com/\u0026#34; - name: stackoverflow url: \u0026#34;https://stackoverflow.com\u0026#34; - name: github url: \u0026#34;https://github.com/\u0026#34; analytics: google: SiteVerificationTag: \u0026#34;XYZabc\u0026#34; bing: SiteVerificationTag: \u0026#34;XYZabc\u0026#34; yandex: SiteVerificationTag: \u0026#34;XYZabc\u0026#34; cover: # hidden: true # 隐藏封面图片 # hiddenInList: true # 列表页隐藏封面图哦 # hiddenInSingle: true # 文章页面隐藏封面图片 editPost: URL: \u0026#34;https://github.com/\u0026lt;path_to_repo\u0026gt;/content\u0026#34; Text: \u0026#34;Suggest Changes\u0026#34; # edit text appendFilePath: true # to append file path to Edit link # 搜索设置 fuseOpts: isCaseSensitive: false shouldSort: true location: 0 distance: 1000 threshold: 0.4 minMatchCharLength: 0 limit: 10 # # 最大返回搜索结果数 keys: [\u0026#34;title\u0026#34;, \u0026#34;permalink\u0026#34;, \u0026#34;summary\u0026#34;, \u0026#34;content\u0026#34;] # 参与搜索的字段 menu: # 定义导航菜单 main: # Hugo 主题 PaperMod 默认的主菜单（可以有多个菜单） - identifier: categories # 菜单的唯一标识符，用于 Hugo 内部管理这个菜单项 name: categories # 分类菜单项的显示名称 url: /categories/ # 分类页面的 URL （/categories/ Hugo 的分类页面（taxonomy page）） weight: 10 # 菜单的权重（值越小越靠前） - identifier: tags name: tags # 标签菜单项 url: /tags/ # 标签页面的 URL weight: 20 - identifier: example name: example.org # 自定义菜单项 url: https://example.org # 自定义菜单的链接 weight: 30 # 自定义菜单的权重 - identifier: archive name: Archive url: archives weight: 5 - identifier: search name: Search url: search/ weight: 10 4. 添加网页内容 在路径 A/demo 下，执行以下指令\n1 hugo new content posts/hello.md 执行完上面指令后，hugo 会生成网页，保存路径为 A/demo/content/posts/hello.md。打开该文档，会看到以下内容\n1 2 3 4 5 +++ date = \u0026#39;2025-02-11T07:14:09+08:00\u0026#39; draft = false title = \u0026#39;My First Post\u0026#39; +++ 5. Hugo本地部署 如果 draft = true，执行以下指令（以下两个指令是一样的，只执行一个即可）\n1 2 hugo server -D hugo server --buildDrafts 如果 draft = false，\n1 hugo server 最后，可以在浏览器输入地址 http://localhost:1313/，即看到网页内容\n6. Hugo 部署到 Github Pages 🚀 6.1 新建 Github 仓库 step 1. 新建 Github 仓库，仓库名必须为 username.github.io，username 为 Github 用户名。\nstep 2. 将本地仓库推到 Github 仓库\n切换路径至 A/demo，执行以下指令\n1 2 3 4 5 git remote add origin \u0026#34;Github 仓库 SSH 地址\u0026#34; # 不需要井号 git add . git commit -m \u0026#34;First Submit\u0026#34; git branch -M main git push -u origin main 刷新 Github 仓库，会看到git仓库已上传。\nstep 3. 这时 username.github.io 还是不能访问，接下来进行部署\nstep 3.1 建立部署配置文件\n回到本地仓库根目录，建立文件夹 .github/workflows，在该文件夹下新建文件 hugo.yaml （hugo.yaml的内容参考 这个博客 或者 官方教程），hugo.yaml的具体内容如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 # Sample workflow for building and deploying a Hugo site to GitHub Pages name: Deploy Hugo site to Pages on: # Runs on pushes targeting the default branch push: branches: - main # Allows you to run this workflow manually from the Actions tab workflow_dispatch: # Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages permissions: contents: read pages: write id-token: write # Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued. # However, do NOT cancel in-progress runs as we want to allow these production deployments to complete. concurrency: group: \u0026#34;pages\u0026#34; cancel-in-progress: false # Default to bash defaults: run: shell: bash jobs: # Build job build: runs-on: ubuntu-latest env: HUGO_VERSION: 0.141.0 steps: - name: Install Hugo CLI run: | wget -O ${{ runner.temp }}/hugo.deb https://github.com/gohugoio/hugo/releases/download/v${HUGO_VERSION}/hugo_extended_${HUGO_VERSION}_linux-amd64.deb \\ \u0026amp;\u0026amp; sudo dpkg -i ${{ runner.temp }}/hugo.deb - name: Install Dart Sass run: sudo snap install dart-sass - name: Checkout uses: actions/checkout@v4 with: submodules: recursive fetch-depth: 0 - name: Setup Pages id: pages uses: actions/configure-pages@v5 - name: Install Node.js dependencies run: \u0026#34;[[ -f package-lock.json || -f npm-shrinkwrap.json ]] \u0026amp;\u0026amp; npm ci || true\u0026#34; - name: Build with Hugo env: HUGO_CACHEDIR: ${{ runner.temp }}/hugo_cache HUGO_ENVIRONMENT: production TZ: America/Los_Angeles run: | hugo \\ --gc \\ --minify \\ --baseURL \u0026#34;${{ steps.pages.outputs.base_url }}/\u0026#34; - name: Upload artifact uses: actions/upload-pages-artifact@v3 with: path: ./public # Deployment job deploy: environment: name: github-pages url: ${{ steps.deployment.outputs.page_url }} runs-on: ubuntu-latest needs: build steps: - name: Deploy to GitHub Pages id: deployment uses: actions/deploy-pages@v4 step 3.2 选择 GitHub 部署方式\nGithub项目页面 -\u0026gt; Settings -\u0026gt; Pages -\u0026gt; Build and deployment -\u0026gt; Source -\u0026gt; 改为 GitHub Actions\nstep 3.3 查看 GitHub 部署结果\nGithub项目页面 -\u0026gt; Action 页面会看到 GitHub 的部署情况。 部署正确后即可看到 username.giuhub.io 页面。\n注意，根目录 A/demo 下的网站配置文件（不是 .github/workflows 目录下的部署配置文件） hugo.yaml 的设置必须如下，否则报错\n1 baseURL: https://username.github.io/ ","permalink":"http://localhost:1313/posts/hugo/2025-02-11-hugo/","summary":"Learn About Hugo \u0026amp; GitHub Pages","title":"Hugo 系列 - 1. 搭建 Hugo 网站并部署到 Github Pages"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates (extend_head.html) like so: refer ISSUE #236 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTex globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTex on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Block math:\n$$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\n","permalink":"http://localhost:1313/posts/papermod/math-typesetting/","summary":"\u003cp\u003eMathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\u003c/p\u003e","title":"Math Typesetting"},{"content":"使用批处理（自动添加右键菜单） 如果不想手动修改注册表，可以运行以下 批处理脚本 来自动添加。\n步骤 新建一个 add_vscode_context_menu.bat 文件\n复制以下代码 并粘贴进去 (注意修改 VS code 安装路径)：\n1 2 3 4 5 @echo off REG ADD \u0026#34;HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\Open with VS Code\u0026#34; /ve /t REG_SZ /d \u0026#34;在此处打开 VS Code\u0026#34; /f REG ADD \u0026#34;HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\Open with VS Code\\command\u0026#34; /ve /t REG_SZ /d \u0026#34;\\\u0026#34;C:\\Users\\%USERNAME%\\AppData\\Local\\Programs\\Microsoft VS Code\\Code.exe\\\u0026#34; \\\u0026#34;%%V\\\u0026#34;\u0026#34; /f echo VS Code 右键菜单添加成功！ pause 右键点击该 .bat 文件，选择 以管理员身份运行\n运行完毕后，右键点击文件夹空白处，看看是否出现 \u0026ldquo;在此处打开 VS Code\u0026rdquo; 选项。\n","permalink":"http://localhost:1313/posts/other/2025-02-27/","summary":"VS code设置","title":"VS code设置：右击文件夹出现“在这里打开 VS code”选项"},{"content":"在 LaTeX 生态中，latex、pdflatex、xelatex 和 lualatex 是不同的编译引擎，各自有不同的特点和适用场景。\n1. latex 最古老的 LaTeX 编译器，输出的是 DVI 文件，不是 PDF 文件 需要使用 dvips 或 dvipdf 等工具将 DVI 文件转换为 PDF 文件（latex → DVI → PS → PDF）。 不支持直接插入 PNG、JPEG、PDF 等图片格式，只支持 EPS 格式。 不支持直接插入中文，需要使用 xeCJK 或 CJK 宏包。 2. pdflatex 直接生成 PDF 文件（不需要使用 dvips 或 dvipdf 等转换工具）。 支持直接插入 PNG、JPEG、PDF 等图片格式（但不支持 EPS 格式）。 不支持 Unicode，默认采用 8-bit 编码（如 latin1、utf8 需用 inputenc 宏包） 对中文支持较差，需要 CJK 宏包（或 ctex 宏包）。 适合英文和西方语言文档（默认 8-bit 编码） 如果一定要用 pdflatex 处理中文，需要 1 \\usepackage[CJKutf8]{CJK} 3. xelatex 直接生成 PDF 文件（不需要使用 dvips 或 dvipdf 等转换工具）。 支持 Unicode，默认采用 UTF-8 编码，适用于多语言文档（包括中文） 支持 OpenType/TrueType（OTF/TTF）字体，可以直接使用系统字体（如宋体、楷体、黑体、SimSun、SimHei 等） 支持 fontspec 宏包，使字体管理更灵活。 支持直接插入 PNG、JPEG、PDF 等图片格式（但不支持 EPS 格式）。 CTeX 默认推荐 xelatex 4. lualatex（推荐用于高级应用，如 Lua 代码交互） 支持 Unicode 和 OpenType 字体。 支持 fontspec 宏包（字体管理）。 支持 luacode 宏包，可以在 LaTeX 代码中直接写 Lua 代码，例如： 1 2 3 4 \\usepackage{luacode} \\begin{luacode} tex.print(\u0026#34;你好，LuaLaTeX！\u0026#34;) \\end{luacode} 5. 总结 编译器 是否支持 Unicode 直接输出 PDF 适用于中文 图片支持 推荐用途 latex ❌ 否 ❌ 需转换 ❌ 需 CJK 仅支持 EPS 过时，基本不用 pdflatex ❌ 否 ✅ 是 ⚠️ 需 CJK PNG、JPEG、PDF 适用于英文或简单中文 xelatex ✅ 是 ✅ 是 ✅ 推荐 PNG、JPEG、PDF 推荐中文文档、支持系统字体 lualatex ✅ 是 ✅ 是 ✅ 推荐 PNG、JPEG、PDF 高级排版、动态 Lua 代码 小贴士 Unicode 是字符集，定义了世界上所有语言的字符例如\nA → U+0041 你 → U+4F60 😊 → U+1F60A 但Unicode 只规定了字符编号（码点），并没有规定如何存储这些字符。\n计算机只能存储 二进制数据（0 和 1），所以我们需要 字符编码（Character Encoding）把 Unicode 转换成二进制。\nUTF-8 是 Unicode 的一种编码方式，是一种 可变长度的 Unicode 编码\n1 个字节（8-bit） 表示 ASCII 字符（兼容英语）。 2~4 个字节 表示其他 Unicode 字符（如中文、Emoji）。 A → U+0041 → 0x41（1 字节） 你 → U+4F60 → 0xE4BDA0（3 字节） 😊 → U+1F60A → 0xF09F988A（4 字节） 8-bit 编码 主要指 每个字符占 1 个字节（8 位） 的旧式编码，常见的包括\nASCII：标准 ASCII 只使用 7-bit（128 个字符），由于 7-bit 只能表示 128 个字符，后来扩展到 8-bit（256 个字符） ISO-8859-1：用于西欧语言，支持法语、德语、西班牙语等， 但不支持中文 GB2312 (6,763个汉字) / GBK(21,003个汉字) / GB18030（Unicode所有汉字） ","permalink":"http://localhost:1313/posts/latex/2025-02-24-latex/","summary":"Learn About LaTex","title":"LaTex 系列 - 1. LaTex 编译器介绍"},{"content":"1. 安装git 这里没什么好说的，官网下载，默认安装。\n2. 配置 git 用户信息 2.1 配置 Git 用户信息 1 2 git config --global user.name \u0026#34;GitHub用户名\u0026#34; # 不需要引号 git config --global user.email \u0026#34;GitHub邮箱\u0026#34; # 不需要引号 2.2 设置 SSH Key 生成 SSH Key\n1 ssh-keygen -t rsa -b 4096 -C \u0026#34;GitHub邮箱\u0026#34; # 不需要引号 -t rsa：使用 RSA 加密算法 -b 4096：密钥长度为 4096 位（更安全） -C \u0026quot;GitHub邮箱\u0026quot;：标识 SSH Key，方便管理 接下来 terminal 提示：\n1 Enter file in which to save the key (/home/user/.ssh/id_rsa): 直接按回车即可（使用默认路径 ~/.ssh/id_rsa）\n接下来 terminal 提示输入密码：\n1 2 Enter passphrase (empty for no passphrase): Enter same passphrase again: 两次回车即可（默认不输入密码），否则每次推送 Git 都需要输入密码\n生成的 SSH密钥 存放在 ~/.ssh/id_rsa.pub\n2.3 将 SSH密钥 添加到 GitHub 账户的 SSH Keys 中 复制 SSH Key 1 cat ~/.ssh/id_rsa.pub 添加到 GitHub 登录 GitHub 账户 点击右上头像 -\u0026gt; Settings（设置） 左侧选择 SSH and GPG keys（SSH 和 GPG 密钥） 点击 New SSH key（新建 SSH 密钥） Title: 可以自定义 Key: 粘贴复制的 SSH Key 点击 Add SSH key 2.3 测试 SSH 连接 1 ssh -T git@github.com 如果配置成功，会显示：\n1 Hi \u0026lt;GitHub用户名\u0026gt;! You\u0026#39;ve successfully authenticated, but GitHub does not provide shell access. 3. 修改文件，提交到本地仓库 进入 path/to/your/workspace/XXX 文件夹，修改其中的文件 AAA.xx，然后执行以下命令：\n1 git status 执行后，会显示\n1 2 3 4 Changes not stated for commit: (use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to update what will be committed) (use \u0026#34;git restore \u0026lt;file\u0026gt;...\u0026#34; to discard changes in working directory) modified: AAA.xx 表明：\nAAA.xx 文件被修改 该文件的修改没有被添加到暂存区 接下来，执行以下命令：\n1 git add AAA.xx # 将 AAA.xx 文件添加到暂存区 再次执行以下命令\n1 git commit -m \u0026#34;第一次修改\u0026#34; # 将暂存区的文件提交到本地仓库，并添加提交备注信息 4. 本地仓库关联配置远程仓库（新建远程仓库后第一次推送） 首先，在 GitHub 上新建一个仓库 (Github 仓库新建后的默认分支是 main)\n本地仓库中文件每次修改后，如需推送，需要按顺序执行以下 Git 操作\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 1 切换到仓库根目录 cd \u0026#34;本地仓库路径\u0026#34; # 2 初始化 Git 仓库 git init # 3 添加所有文件到暂存区 git add . # 4 提交文件 git commit -m \u0026#34;Initial commit\u0026#34; # 5 origin = SSH，并且添加 origin（以后命令行可以用 origin 代表远程仓库） git remote add origin SSH地址 # 6 强制重命名本地仓库的当前分支为 main git branch -M main # 7 第一次推送：将本地的 main 分支推送到 GitHub git push -u origin main 注意：\nGit 仓库默认的主分支是 master，但 GitHub 仓库采用 main 作为默认分支，所以用命令 git branch -M main 将本地分支当前分支 master 改为 main。 第一次推送执行 git push -u origin main ，-u 选项将本地的 main 分支与远程的 origin/main 关联起来，使得后续推送和拉取更方便。 如果不使用 -u 选项，后续推送时需要使用 git push origin main。 使用了 -u 选项后，后续推送时可以直接使用 git push。 -u 的全写是 --set-upstream。 执行完上述指令后，打开 GitHub 仓库, 会看到本地仓库已经推送.\n5. 推送本地仓库到远程仓库（非第一次推送） 执行以下指令，推送本地仓库到远程仓库\n1 git push 执行以下指令，远程仓库拉取到本地仓库\n1 git pull 总结 SSH 密钥配置，不需要每次验证\n从远程仓库 clone 到本地：\ngit clone 远程仓库地址 本地仓库与远程仓库的关联配置（首次推送）：\ngit add . # 提交到暂存区 git commit -m \u0026quot;提交备注信息\u0026quot; # 提交到本地仓库 git remote add origin 远程仓库地址 # 将本地仓库与远程仓库关联 git remote -v # 查看远程仓库的信息 git branch -M main git push -u origin main # 将本地的当前分支与远程的 origin/main 关联并推送 本地仓库提交到远程仓库的流程（非首次推送）：\ngit add . # 提交到暂存区 git commit -m \u0026quot;提交备注信息\u0026quot; # 提交到本地仓库 git push # 提交到远程仓库 上面两条指令可以简化为下面一条指令\ngit commit -am \u0026quot;提交备注信息\u0026quot; # 提交到本地仓库 ","permalink":"http://localhost:1313/posts/git/2025-02-23-git-install/","summary":"Learn About Git \u0026amp; GitHub","title":"Git 系列 - 1. 安装 Git 与配置 Github"},{"content":"1.安装必要软件 一行代码搭建机器人开发环境(ROS/ROS2/ROSDEP)\n1 wget http://fishros.com/install -O fishros \u0026amp;\u0026amp; . fishros 选项：\n[1] 安装 noetic(ros1) [3] 安装 rosdep ","permalink":"http://localhost:1313/posts/git/2025-02-23-git-matlab/","summary":"Learn About Git \u0026amp; Matlab","title":"Git 系列 - 2. Matlab 同步 Git"},{"content":"原理 Texstudio 编译 A/main.tex，本质上是 cmd 进入路径 A，然后执行\n1 pdflatex main.tex 因为推送本地仓库到 github 需要在 cmd 执行 git 指令\n1 2 3 4 git add . git commit -m \u0026#34;First Submit\u0026#34; git branch -M main git push -u origin main 所以如果可以利用texstudio在tex文件路径执行上述指令，即可实现仅通过texstudio推送tex文件至github\nTexStudio 配置 texstudio 中如下配置\nTools -\u0026gt; User -\u0026gt; Git command 等价于在命令行当前目录下执行 Git command\n如何实现 第一次推送需要命令行，后续推送仅需texstudio\n第一次推送：\n1 2 3 4 5 6 git init git remote add origin github_SSH_address git add . # 每次推送执行 git commit -m \u0026#34;First Submit\u0026#34; # 每次推送执行 git branch -M main # 首次推送执行 git push -u origin main # 首次推送执行 后续推送/拉取：\n1 2 3 4 git add . # 每次推送执行 git commit -m \u0026#34;First Submit\u0026#34; # 每次推送执行 git push # 每次推送执行 git pull # 每次拉取执行 注意：上面两行命令等价于下面一行命令\n1 git commit -am \u0026#34;First Submit\u0026#34; # 每次推送执行 ","permalink":"http://localhost:1313/posts/git/2025-02-23-git-texstudio/","summary":"Learn About All Features in PaperMod","title":"Git 系列 - 3. Texstudio 同步 Git"},{"content":"1. 分支的本地操作 新建分支 新建分支 branch_A\n1 git branch branch_A 切换到分支 branch_A\n1 git checkout branch_A 新建分支 branch_B 并切换到分支 branch_B (下面一行效果等同于上面两行)\n1 git checkout -b branch_B 查看分支 查看本地分支\n1 git branch 查看远程分支\n1 git branch -r 查看所有分支\n1 git branch -a 合并分支 合并分支 branch_B 到分支 branch_A: 先切换到分支 branch_A，再执行 git merge\n1 2 git checkout branch_A # 切换当前分支为 branch_A git merge branch_B # 合并分支 branch_B 到当前分支 (branch_A) 删除分支 删除分支 branch_B\n1 2 git branch -d branch_B # 安全删除 git branch -D branch_B # 强制删除 2. 分支的远程操作 推送本地分支到远程仓库 本地分支 branch_A 推送到远程仓库\n1 git push origin branch_A 关联本地分支与远程分支\n删除远程分支 删除远程仓库 origin 的分支 branch_C\n1 git push origin --delete branch_C 注意，远程不一定叫origin，可以是其他名字。\n","permalink":"http://localhost:1313/posts/git/2025-02-23-git-branch/","summary":"Learn About Git \u0026amp; branch","title":"Git 系列 - 4. Git 分支管理"},{"content":"In this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates (extend_head.html) like so: refer ISSUE #236 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTex globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTex on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Block math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\n","permalink":"http://localhost:1313/posts/reinforcement_learning/2025-02-20-rl-pg/","summary":"Learn About DQN in Stochastic Policy Gradient","title":"强化学习系列 - 2. Stochastic Policy Gradient"},{"content":"AppImage 是一种便携式软件包格式，允许你在 Linux 上运行应用程序 无需安装。以下是下载、运行和管理 AppImage 文件的方法\n1. 下载 AppImage 文件 2. 赋予 AppImage 文件可执行权限 AppImage 文件运行需要赋予权限，以下是赋予权限的两种方式。\n方法1：使用终端 1 2 chmod +x ~/Downloads/your_app.AppImage ./your_app.AppImage 方法2：使用图形界面 右键点击 AppImage 文件，选择 \u0026ldquo;属性\u0026rdquo;（Properties）。 切换到 \u0026ldquo;权限\u0026rdquo;（Permissions） 选项卡。 勾选 \u0026ldquo;允许作为可执行文件\u0026rdquo;（Allow executing file as a program）。 双击 AppImage 运行程序。 3. 使用 AppImageLauncher 管理 AppImage AppImage 默认不会自动出现在应用菜单中。\nAppImageLauncher 可以自动管理 AppImage 并集成到系统菜单中\n1 2 3 sudo add-apt-repository ppa:appimagelauncher-team/stable sudo apt update sudo apt install appimagelauncher 4. 将 AppImage 移动到 /opt 并创建全局快捷方式 如果你希望让 AppImage 可在整个系统中使用\n1 2 3 sudo mv ~/Downloads/your_app.AppImage /opt/your_app.AppImage sudo chmod +x /opt/your_app.AppImage sudo ln -s /opt/your_app.AppImage /usr/local/bin/your_app 5. 更新 AppImage 部分 AppImage 支持自动更新，例如：\n1 ./your_app.AppImage --update 如果 AppImage 不支持更新，你需要手动下载新版并替换旧版。\n6. 删除 AppImage 由于 AppImage 是一个独立的可执行文件，删除它就等于卸载：\n1 rm ~/Downloads/your_app.AppImage 如果你用 AppImageLauncher 集成了 AppImage，可以在 /Applications 目录中找到它，并右键选择 \u0026ldquo;删除\u0026rdquo;。\n6.Hugo 部署到 Github Pages 🚀 ","permalink":"http://localhost:1313/posts/ubuntu/2025-02-17-ubuntu-appimage/","summary":"Learn About Ubuntu","title":"Ubuntu系列 - 1. 安装AppImage应用"},{"content":"1. Ubuntu 目录结构 1.1 用户主目录 ~ = /home/username/ 在 ubuntu 系统中，波浪线 ~ 在命令行环境下是 “用户主目录”（Home Directory）的缩写或别名。\n例如 ~/.bashrc:\n~ 代表的就是当前用户的主目录（/home/username/） ~/.bashrc 实际上就是 /home/username/.bashrc 2. shell 和 terminal 2.1 Shell 是什么 Shell 是一种软件层，用来接收用户输入的命令，然后将这些命令传递给操作系统内核去执行。也可以理解为人与操作系统之间的“翻译”或“交互接口”。\n2.2 Shell 的种类 bash Shell: Ubuntu 默认的 Shell zsh Shell fish Shell csh/tcsh Shell 每种 Shell 都有自己的语法特性、配置文件和内置工具，但它们的基本功能相似：运行命令、编写脚本、管理进程和环境变量等。\n2.3 常用的 Shell 配置文件 ~/.bashrc: bash Shell 的配置文件 ~/.zshrc: zsh Shell 的配置文件 ~/.config/fish/config.fish: fish Shell 的配置文件 2.4 Shell 的工作流程 读取用户输入的命令 解释和解析命令，交给操作系统 显示执行结果 2.5 常用的 Shell 命令 echo: 打印文本或变量的值 cd: 改变当前目录 ls: 列出当前目录中的文件和文件夹 2.6 常用的 Shell 快捷键 Ctrl + L: 清屏 Ctrl + C: 中断当前命令 Ctrl + D: 退出当前 Shell 2.7 什么是 terminal \u0026ldquo;终端\u0026rdquo; 指的是实际的硬件设备（如显示器/键盘），通过串口或其他方式连到主机。 Ubuntu 的 terminal 是一个 \u0026ldquo;终端\u0026rdquo; 的软件模拟器 2.8 terminal 和 shell 的关系 terminal: 是一个 “文本交互界面”, 提供了一个文本窗口，允许用户在其中输入命令、接收输出 shell: 是一个命令行解释器，它接收用户在 terminal 内输入的命令，并将其传递给操作系统内核去执行。 Terminal：相当于“聊天窗口” Shell：相当于“对话的另一端的人”（或自动回复程序） 2.9 例子 在 Ubuntu 的 terminal 里输入一条命令： 1 ls -l Terminal 会把这条文本交给正在运行的 Shell（一般是 Bash） Bash 解析这条命令，调用相应的系统调用或程序来列出目录下的文件和文件夹 然后 Bash 把执行结果返回给 Terminal，Terminal 再把结果显示给用户 3. 配置脚本文件 ~/.bashrc 3.1 terminal/shell 启动流程 在 Ubuntu 系统中，点开 terminal 图标，新开一个 terminal 窗口时，会发生以下事情：\n启动一个终端模拟器 terminal，它会创建一个非登录、交互式的 Bash Shell。 Bash Shell 尝试查找并读取 /etc/bash.bashrc（系统全局的 bashrc，可选） Bash Shell 尝试查找并读取当前用户的 ~/.bashrc（用户自定义的 bashrc） Bash Shell 环境初始化完成，用户在就可以正常使用终端了。 3.2 ~/.bashrc 的功能 初始化 Shell\n定义/修改 PATH 等环境变量\n1 2 export PATH=\u0026#34;$HOME/bin:$PATH\u0026#34; export EDITOR=vim 为常用命令设置别名（alias），简化输入，例如\n1 2 alias ll=\u0026#39;ls -l\u0026#39; alias gs=\u0026#39;git status\u0026#39; 让 ~/.bashrc 的修改立即生效（以下两个指令等价）：\n1 2 source ~/.bashrc . ~/.bashrc 配置命令提示符（PS1）：命令行中看到的提示符样式，就是由 PS1 的配置决定的\n1 PS1=\u0026#34;\\u@\\h:\\w\\$ \u0026#34; PS1: Bash 中用于定义主提示符（Primary Prompt）的变量 \\u：当前用户名（user name） \\h：当前主机名（host name）中的前半部分（不含域名） \\w：当前工作目录（working directory），会以相对路径显示，如果是 home 目录则显示 ~ \\$：如果是普通用户则显示 $，如果是 root 用户（即超级用户）则显示 # 最后的空格: 是为了让命令提示符后留出一个空格，便于输入命令 2.3 不同类型的 Shell 的 Bash 启动流程 登录Shell（Login Shell） 通过 SSH 登录远程主机，或者在系统中输入 用户名/密码 直接登录时，启动的 Shell 就是 登录Shell 这种情况下，Bash Shell 会先读取并执行 /etc/profile，然后依次读取 ~/.bash_profile, ~/.bash_login, ~/.profile（谁先被找到就执行哪个，通常系统会默认用 ~/.bash_profile 或 ~/.profile） 非登录Shell（Non-login Shell） 在图形界面下打开一个 Terminal: 通常是通过 Ctrl + Alt + T 快捷键打开的终端，或者通过 gnome-terminal 命令打开的终端 这种情况下，Bash Shell 只会读取并执行 ~/.bashrc 交互式（Interactive）与非交互式（Non-interactive） 交互式 Shell：用户与 Shell 之间的交互，例如通过 Ctrl + Alt + T 快捷键打开的终端，用户可以通过键盘输入命令 非交互式 Shell：Shell 不与用户交互，例如通过脚本执行命令（脚本首行需要写 #!/usr/bin/env bash） 总结：~/.bashrc 默认只在“非登录式且交互式”的 Bash Shell 启动时被读取执行\n","permalink":"http://localhost:1313/posts/ubuntu/2025-02-23-ubuntu-shell/","summary":"Learn About Ubuntu","title":"Ubuntu系列 - 2. bash shell, terminal 和 ~/.bashrc"},{"content":"1.DQN 算法流程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 # 0. 初始化 # 0.1 初始化环境 env env = # 0.2 初始化 DQN q(s, a; θ) = q_(s, a; θ_) = # 0.3 初始化经验回放库 Buffer replay_buffer = # 主循环：N 个 episode for episode = 1 to M: # 1. 初始化 s_t = env.reset() # 初始化状态 s_t episode_return = 0 # 初始化累计回报 episode_return # 每个 episode done = False while not done: # 2. 以 ε-贪婪策略生成动作 a_t a_t = argmax_a Q(s_t, a; θ) or random # 3. 执行动作 a_t，得到奖励 r_t、新状态 s_{t+1}、以及游戏结束标志 done s_{t+1}, r_t, done, _ = env.step(a_t) # 4. 存储一次交互数据 (s_t, a_t, r_t, φ_{t+1}, done) 至经验回放库 replay_buffer replay_buffer.append( (s_t, a_t, r_t, s_{t+1}, done) ) # 5. 当 replay_buffer 数据量满足最小长度 (比如500)，从 replay_buffer 中随机抽取一批数据 batch \u0026lt;- {s_j, a_j, r_j, s_{j+1}, done_j}, j = 1, ..., minimal_size（ batch 数据量为 minimal_size ） if len(Buffer) \u0026gt; 500: batch \u0026lt;- replay_buffer( 1, ..., minimal_size ) # 6. 利用采样数据 batch 训练 DQN DQN.train(batch) # 7. 更新状态 s_t \u0026lt;- s_{t+1} s_t = s_{t+1} # 8. 更新累计回报 episode_return += reward # 更新累计回报 if done: break ","permalink":"http://localhost:1313/posts/reinforcement_learning/2025-02-16-rl-dqn/","summary":"Learn About DQN in RL","title":"强化学习系列 - 1. DQN"},{"content":"1. PyTorch 中使用 TensorBoard 通过 SummaryWriter 记录数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 import torch import torch.nn as nn import torch.optim as optim from torch.utils.tensorboard import SummaryWriter import numpy as np # 初始化 TensorBoard 记录器 writer = SummaryWriter(log_dir=\u0026#34;runs/experiment_1\u0026#34;) # 创建一个简单的模型 model = nn.Linear(1, 1) criterion = nn.MSELoss() optimizer = optim.SGD(model.parameters(), lr=0.01) # 训练循环 for epoch in range(100): x = torch.tensor([[epoch]], dtype=torch.float32) y = torch.tensor([[2 * epoch + 1]], dtype=torch.float32) output = model(x) loss = criterion(output, y) optimizer.zero_grad() loss.backward() optimizer.step() # 记录损失 writer.add_scalar(\u0026#34;Loss/train\u0026#34;, loss.item(), epoch) # 记录权重和梯度 for name, param in model.named_parameters(): writer.add_histogram(name, param, epoch) writer.add_histogram(f\u0026#34;{name}.grad\u0026#34;, param.grad, epoch) writer.close() 在终端启动 TensorBoard\n1 tensorboard --logdir=runs --port=6006 2. TensorFlow 中使用 TensorBoard 记录数据（不需要 SummaryWriter）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import tensorflow as tf import datetime # 创建日志目录 log_dir = \u0026#34;logs/fit/\u0026#34; + datetime.datetime.now().strftime(\u0026#34;%Y%m%d-%H%M%S\u0026#34;) tensorboard_callback = tf.keras.callbacks.TensorBoard(log_dir=log_dir, histogram_freq=1) # 创建一个简单模型，指定 NN 结构 model = tf.keras.Sequential([ tf.keras.layers.Dense(128, activation=\u0026#39;relu\u0026#39;), tf.keras.layers.Dense(10) ]) # 指定NN训练方法为 adam, 损失函数为 SparseCategoricalCrossentropy model.compile(optimizer=\u0026#39;adam\u0026#39;, loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True), metrics=[\u0026#39;accuracy\u0026#39;]) # 训练模型，并使用 TensorBoard 记录 model.fit( tf.random.normal([1000, 32]), tf.random.uniform([1000], maxval=10, dtype=tf.int32), epochs=5, callbacks=[tensorboard_callback] ) 在终端启动 TensorBoard\n1 tensorboard --logdir=logs/fit --port=6006 必选参数：\nhelp=\u0026quot;输入文件的路径\u0026quot;: 在 --help 命令中显示的参数说明 当执行脚本时，需要紧随其后提供必选参数 filename，否则会报错。例如（下面指令中的 input.txt 就是参数 \u0026ldquo;filename\u0026rdquo;） 1 python script.py input.txt 可选参数1：\n-v 和 --verbose: 代表同一个可选参数，用户可以使用任一形式。 action=\u0026quot;store_true\u0026quot;: 当这个选项被使用时，将在解析结果中把 verbose 设置为 True（不使用则为 False）。 help=\u0026quot;是否输出详细信息（布尔开关）\u0026quot;: help 中的内容会在 --help 命令中显示。 可选参数2：\ntype=int：将输入值转换为整数类型（如果传入值无法转换会报错）。 default=1：当用户没有提供该参数时，使用默认值 1。 定义完上面的代码文件后，在命令行的执行如下\n1 2 3 4 5 6 # 带所有参数 python script.py myfile.txt -v -n 3 # 或者：python script.py myfile.txt --verbose --number 3 # 不带可选参数 python script.py myfile.txt 3. 分析 为什么一个是 --logdir=runs 另一个是 --logdir=logs\nPyTorch 示例中，日志记录路径是 \u0026quot;runs/experiment_1\u0026quot;， runs/ 是 SummaryWriter(log_dir=\u0026quot;runs/experiment_1\u0026quot;) 指定的路径的父目录 TensorFlow 示例 中，日志记录路径是 \u0026quot;logs/fit/...\u0026quot;，logs/fit/ 是 log_dir 变量中的路径前缀 PyTorch 通常默认使用 \u0026quot;runs/\u0026quot; 作为日志目录，SummaryWriter 就是这么做的。 TensorFlow 示例中，通常使用 \u0026quot;logs/fit/\u0026quot; + datetime 作为日志目录，所以 TensorBoard 需要从 \u0026quot;logs/fit\u0026quot; 读取数据。 ","permalink":"http://localhost:1313/posts/python/2025-02-15-python-tensorboard/","summary":"Learn About argparse in Python","title":"Python 系列 - 2. tensorboard"},{"content":"1.安装必要软件 一行代码搭建机器人开发环境(ROS/ROS2/ROSDEP)\n1 wget http://fishros.com/install -O fishros \u0026amp;\u0026amp; . fishros 选项：\n[1] 安装 noetic(ros1) [3] 安装 rosdep ","permalink":"http://localhost:1313/posts/ros/2025-02-14-ros-install/","summary":"Learn About ROS1","title":"ROS1系列 - 1. 一键安装 ROS Neotic"},{"content":"1.什么是 argparse argparse 是一个强大的命令行参数解析工具，用于构建命令行脚本或程序时，可以非常方便地对传入的参数进行解释和处理。\n在编写命令行工具或脚本时，往往需要接收来自命令行的参数或选项，以实现配置。\nargparse 则能让你以更高层次、更结构化的方式来定义程序期望的参数形式，以及如何处理这些参数，从而自动生成帮助信息、错误信息等。\n2.基本用法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 import argparse def main(): \u0026#39;\u0026#39;\u0026#39;第一步：创建一个解析器对象，可以给出程序的简单描述\u0026#39;\u0026#39;\u0026#39; parser = argparse.ArgumentParser(description=\u0026#34;这是一个示例命令行工具\u0026#34;) \u0026#39;\u0026#39;\u0026#39;第二步：添加命令行参数和选项\u0026#39;\u0026#39;\u0026#39; # 添加必选参数: 在命令中不需要特意写 -x 或者 --xx ，是脚本必须要获取的数据。 parser.add_argument(\u0026#34;filename\u0026#34;, help=\u0026#34;输入文件的路径\u0026#34;) # 添加可选参数1：一般以短选项（如 -v）或长选项（如 --verbose）的形式出现。 parser.add_argument(\u0026#34;-v\u0026#34;, \u0026#34;--verbose\u0026#34;, action=\u0026#34;store_true\u0026#34;, help=\u0026#34;是否输出详细信息（布尔开关）\u0026#34; ) # 添加可选参数2：一般以短选项（如 -v）或长选项（如 --verbose）的形式出现。 parser.add_argument(\u0026#34;-n\u0026#34;, \u0026#34;--number\u0026#34;, type=int, default=1, help=\u0026#34;重复操作次数，默认为 1\u0026#34; ) # 添加可选参数3：接收某个范围或集合中的值 parser.add_argument(\u0026#34;--mode\u0026#34;, choices=[\u0026#34;train\u0026#34;, \u0026#34;test\u0026#34;, \u0026#34;eval\u0026#34;], help=\u0026#34;模式选择\u0026#34; ) # 添加可选参数4：指定参数的别名 parser.add_argument(\u0026#34;-m\u0026#34;, \u0026#34;--mode\u0026#34;, choices=[\u0026#34;train\u0026#34;, \u0026#34;test\u0026#34;, \u0026#34;eval\u0026#34;] ) \u0026#39;\u0026#39;\u0026#39;第三步：解析命令行参数\u0026#39;\u0026#39;\u0026#39; # args 就是一个包含解析后参数的命名空间对象, 属性名即为参数名。 args = parser.parse_args() # 通过 args.filename 访问参数 filename print(\u0026#34;文件名：\u0026#34;, args.filename) print(\u0026#34;是否详细输出：\u0026#34;, args.verbose) print(\u0026#34;操作次数：\u0026#34;, args.number) if __name__ == \u0026#34;__main__\u0026#34;: main() 必选参数：\nhelp=\u0026quot;输入文件的路径\u0026quot;: 在 --help 命令中显示的参数说明 当执行脚本时，需要紧随其后提供必选参数 filename，否则会报错。例如（下面指令中的 input.txt 就是参数 \u0026ldquo;filename\u0026rdquo;） 1 python script.py input.txt 可选参数1：\n-v 和 --verbose: 代表同一个可选参数，用户可以使用任一形式。 action=\u0026quot;store_true\u0026quot;: 当这个选项被使用时，将在解析结果中把 verbose 设置为 True（不使用则为 False）。 help=\u0026quot;是否输出详细信息（布尔开关）\u0026quot;: help 中的内容会在 --help 命令中显示。 可选参数2：\ntype=int：将输入值转换为整数类型（如果传入值无法转换会报错）。 default=1：当用户没有提供该参数时，使用默认值 1。 定义完上面的代码文件后，在命令行的执行如下\n1 2 3 4 5 6 # 带所有参数 python script.py myfile.txt -v -n 3 # 或者：python script.py myfile.txt --verbose --number 3 # 不带可选参数 python script.py myfile.txt ","permalink":"http://localhost:1313/posts/python/2025-02-13-python-argparse/","summary":"Learn About argparse in Python","title":"Python 系列 - 1. 命令行解析器 argparse"},{"content":"1. 安装必要软件 按照以下顺序安装软件（因为相互依赖关系）\nGit\nPowershell 7.x\nwin11 自带 Powershell 的版本是 5.1，需要更新到 7.x。\n首先，在win11自带 Powershell 里输入以下指令，安装最新稳定版\n1 winget install --id Microsoft.Powershell --source winget 接下来的命令行操作都在 7.x 的 Powershell 内执行 。\nVS Code\nGo\ngo安装说明见官网 https://go.dev/doc/install\nGithub账户\nchoco\n参考官网 https://docs.chocolatey.org/en-us/choco/setup/ 安装choco，执行以下指令\n1 Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString(\u0026#39;https://community.chocolatey.org/install.ps1\u0026#39;)) Hugo\n执行以下指令，利用 choco 安装 hugo\n1 choco install hugo-extended Dart Sass\n执行以下指令，利用 choco 安装 Sass\n1 choco install sass 2. Hugo生成静态站点 Powershell 切换至文件夹 A，执行以下指令\n1 2 cd A hugo new site demo --format yaml 执行完上面指令后，hugo 会生成网站，网站根目录为 A/demo。\n注意：打开网站根目录 A/demo，会发现hugo生成了很多文件，其中最重要的是配置文件 hugo.yaml。 网站的配置文件，会略有区别。常见的配置文件有\nhugo.yaml / hugo.toml config.yaml / config.toml 切换路径至网站根目录 A/demo，执行 git 初始化，为后续步骤做准备。\n1 git init 3. Hugo配置Theme 安装 Hugo 主题，参考官网 Hugo themes，接下来我们以 papermod 为例\n安装 Hugo 主题 papermod，执行以下指令\n1 2 3 git submodule add --depth=1 https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod git submodule update --init --recursive # 当我们要从github上拉去仓库时需要这个指令 git submodule update --remote --merge 执行上述指令后，主题 papermod 会存放在路径 A/demo/themes/papermod。\n配置主题 papermod 的配置文件 hugo.yaml 如下：\n1 echo \u0026#34;theme = \u0026#39;ananke\u0026#39;\u0026#34; \u0026gt;\u0026gt; hugo.toml 执行完上面指令后，网站配置文件最后一行会添加以下内容\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 baseURL: https://yylustb.github.io/ languageCode: en-us title: My New Hugo Site theme: [\u0026#34;PaperMod\u0026#34;] paginate: 5 # 列表页显示文章数 # 默认支持首页 HTML 页面、RSS 订阅、JSON（搜索），可以满足大多数 Hugo 博客需求。 outputs: home: # 主页输出 - HTML - RSS - JSON markup: goldmark: # Hugo 默认使用的 Markdown 渲染引擎 renderer: unsafe: true # 控制是否允许在 Markdown 中渲染 “不安全（raw）” 的 HTML 标签 # 在 Markdown 文件中编写的原生 HTML（例如 \u0026lt;script\u0026gt;, \u0026lt;iframe\u0026gt; 或者其他 HTML 标签）， # 在最终生成的页面中会被原样保留并渲染 highlight: lineNos: true # 是否在代码高亮时显示行号 noClasses: false # 不要禁用 class codeFences: true # 启用 Markdown 代码块语法（```） style: \u0026#34;monokai\u0026#34; params: env: production title: ExampleSite # 站点的标题 description: \u0026#34;ExampleSite description\u0026#34; # 站点的描述信息 keywords: [Blog, Portfolio, PaperMod] # 站点的关键词，有助于 SEO author: Me # 站点的作者 # author: [\u0026#34;Me\u0026#34;, \u0026#34;You\u0026#34;] # multiple authors images: [\u0026#34;\u0026lt;link or path of image for opengraph, twitter-cards\u0026gt;\u0026#34;] # 用于社交分享时的默认封面图片 DateFormat: \u0026#34;January 2, 2006\u0026#34; # 文章日期的显示格式 defaultTheme: auto # dark, light # 站点默认主题模式（自动适应用户偏好） disableThemeToggle: false # 是否禁用深色/浅色模式切换 ShowReadingTime: true # 显示阅读时间 ShowShareButtons: true # 显示社交分享按钮 ShowPostNavLinks: true ShowBreadCrumbs: true ShowCodeCopyButtons: false ShowWordCount: true ShowRssButtonInSectionTermList: true # 在分类/标签页显示 RSS 订阅按钮 UseHugoToc: true disableSpecial1stPost: false disableScrollToTop: false comments: false hidemeta: false hideSummary: false # 是否隐藏文章摘要 showtoc: false # 是否显示文章目录 tocopen: false # 是否默认展开目录 assets: # disableHLJS: true # to disable highlight.js # disableFingerprinting: true favicon: \u0026#34;\u0026lt;link / abs url\u0026gt;\u0026#34; favicon16x16: \u0026#34;\u0026lt;link / abs url\u0026gt;\u0026#34; favicon32x32: \u0026#34;\u0026lt;link / abs url\u0026gt;\u0026#34; apple_touch_icon: \u0026#34;\u0026lt;link / abs url\u0026gt;\u0026#34; safari_pinned_tab: \u0026#34;\u0026lt;link / abs url\u0026gt;\u0026#34; label: text: \u0026#34;Home\u0026#34; icon: /apple-touch-icon.png iconHeight: 35 # profile-mode profileMode: enabled: false # needs to be explicitly set title: ExampleSite subtitle: \u0026#34;This is subtitle\u0026#34; imageUrl: \u0026#34;\u0026lt;img location\u0026gt;\u0026#34; imageWidth: 120 imageHeight: 120 imageTitle: my image buttons: - name: Posts url: posts - name: Tags url: tags homeInfoParams: # 主页信息模式（如果启用，会在主页显示欢迎信息） Title: \u0026#34;Hi there \\U0001F44B\u0026#34; # 主页欢迎信息标题 Content: Welcome to my blog # 主页欢迎信息内容 socialIcons: - name: x url: \u0026#34;https://x.com/\u0026#34; - name: stackoverflow url: \u0026#34;https://stackoverflow.com\u0026#34; - name: github url: \u0026#34;https://github.com/\u0026#34; analytics: google: SiteVerificationTag: \u0026#34;XYZabc\u0026#34; bing: SiteVerificationTag: \u0026#34;XYZabc\u0026#34; yandex: SiteVerificationTag: \u0026#34;XYZabc\u0026#34; cover: # hidden: true # 隐藏封面图片 # hiddenInList: true # 列表页隐藏封面图哦 # hiddenInSingle: true # 文章页面隐藏封面图片 editPost: URL: \u0026#34;https://github.com/\u0026lt;path_to_repo\u0026gt;/content\u0026#34; Text: \u0026#34;Suggest Changes\u0026#34; # edit text appendFilePath: true # to append file path to Edit link # 搜索设置 fuseOpts: isCaseSensitive: false shouldSort: true location: 0 distance: 1000 threshold: 0.4 minMatchCharLength: 0 limit: 10 # # 最大返回搜索结果数 keys: [\u0026#34;title\u0026#34;, \u0026#34;permalink\u0026#34;, \u0026#34;summary\u0026#34;, \u0026#34;content\u0026#34;] # 参与搜索的字段 menu: # 定义导航菜单 main: # Hugo 主题 PaperMod 默认的主菜单（可以有多个菜单） - identifier: categories # 菜单的唯一标识符，用于 Hugo 内部管理这个菜单项 name: categories # 分类菜单项的显示名称 url: /categories/ # 分类页面的 URL （/categories/ Hugo 的分类页面（taxonomy page）） weight: 10 # 菜单的权重（值越小越靠前） - identifier: tags name: tags # 标签菜单项 url: /tags/ # 标签页面的 URL weight: 20 - identifier: example name: example.org # 自定义菜单项 url: https://example.org # 自定义菜单的链接 weight: 30 # 自定义菜单的权重 - identifier: archive name: Archive url: archives weight: 5 - identifier: search name: Search url: search/ weight: 10 4. 添加网页内容 在路径 A/demo 下，执行以下指令\n1 hugo new content posts/hello.md 执行完上面指令后，hugo 会生成网页，保存路径为 A/demo/content/posts/hello.md。打开该文档，会看到以下内容\n1 2 3 4 5 +++ date = \u0026#39;2025-02-11T07:14:09+08:00\u0026#39; draft = false title = \u0026#39;My First Post\u0026#39; +++ 5. Hugo本地部署 如果 draft = true，执行以下指令（以下两个指令是一样的，只执行一个即可）\n1 2 hugo server -D hugo server --buildDrafts 如果 draft = false，\n1 hugo server 最后，可以在浏览器输入地址 http://localhost:1313/，即看到网页内容\n6. Hugo 部署到 Github Pages 🚀 6.1 新建 Github 仓库 step 1. 新建 Github 仓库，仓库名必须为 username.github.io，username 为 Github 用户名。\nstep 2. 将本地仓库推到 Github 仓库\n切换路径至 A/demo，执行以下指令\n1 2 3 4 5 git remote add origin \u0026#34;Github 仓库 SSH 地址\u0026#34; # 不需要井号 git add . git commit -m \u0026#34;First Submit\u0026#34; git branch -M main git push -u origin main 刷新 Github 仓库，会看到git仓库已上传。\nstep 3. 这时 username.github.io 还是不能访问，接下来进行部署\nstep 3.1 建立部署配置文件\n回到本地仓库根目录，建立文件夹 .github/workflows，在该文件夹下新建文件 hugo.yaml （hugo.yaml的内容参考 这个博客 或者 官方教程），hugo.yaml的具体内容如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 # Sample workflow for building and deploying a Hugo site to GitHub Pages name: Deploy Hugo site to Pages on: # Runs on pushes targeting the default branch push: branches: - main # Allows you to run this workflow manually from the Actions tab workflow_dispatch: # Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages permissions: contents: read pages: write id-token: write # Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued. # However, do NOT cancel in-progress runs as we want to allow these production deployments to complete. concurrency: group: \u0026#34;pages\u0026#34; cancel-in-progress: false # Default to bash defaults: run: shell: bash jobs: # Build job build: runs-on: ubuntu-latest env: HUGO_VERSION: 0.141.0 steps: - name: Install Hugo CLI run: | wget -O ${{ runner.temp }}/hugo.deb https://github.com/gohugoio/hugo/releases/download/v${HUGO_VERSION}/hugo_extended_${HUGO_VERSION}_linux-amd64.deb \\ \u0026amp;\u0026amp; sudo dpkg -i ${{ runner.temp }}/hugo.deb - name: Install Dart Sass run: sudo snap install dart-sass - name: Checkout uses: actions/checkout@v4 with: submodules: recursive fetch-depth: 0 - name: Setup Pages id: pages uses: actions/configure-pages@v5 - name: Install Node.js dependencies run: \u0026#34;[[ -f package-lock.json || -f npm-shrinkwrap.json ]] \u0026amp;\u0026amp; npm ci || true\u0026#34; - name: Build with Hugo env: HUGO_CACHEDIR: ${{ runner.temp }}/hugo_cache HUGO_ENVIRONMENT: production TZ: America/Los_Angeles run: | hugo \\ --gc \\ --minify \\ --baseURL \u0026#34;${{ steps.pages.outputs.base_url }}/\u0026#34; - name: Upload artifact uses: actions/upload-pages-artifact@v3 with: path: ./public # Deployment job deploy: environment: name: github-pages url: ${{ steps.deployment.outputs.page_url }} runs-on: ubuntu-latest needs: build steps: - name: Deploy to GitHub Pages id: deployment uses: actions/deploy-pages@v4 step 3.2 选择 GitHub 部署方式\nGithub项目页面 -\u0026gt; Settings -\u0026gt; Pages -\u0026gt; Build and deployment -\u0026gt; Source -\u0026gt; 改为 GitHub Actions\nstep 3.3 查看 GitHub 部署结果\nGithub项目页面 -\u0026gt; Action 页面会看到 GitHub 的部署情况。 部署正确后即可看到 username.giuhub.io 页面。\n注意，根目录 A/demo 下的网站配置文件（不是 .github/workflows 目录下的部署配置文件） hugo.yaml 的设置必须如下，否则报错\n1 baseURL: https://username.github.io/ ","permalink":"http://localhost:1313/posts/hugo/2025-02-11-hugo/","summary":"Learn About Hugo \u0026amp; GitHub Pages","title":"Hugo 系列 - 1. 搭建 Hugo 网站并部署到 Github Pages"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates (extend_head.html) like so: refer ISSUE #236 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTex globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTex on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Block math:\n$$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\n","permalink":"http://localhost:1313/posts/papermod/math-typesetting/","summary":"\u003cp\u003eMathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\u003c/p\u003e","title":"Math Typesetting"},{"content":"","permalink":"http://localhost:1313/publications/","summary":"","title":""},{"content":"使用批处理（自动添加右键菜单） 如果不想手动修改注册表，可以运行以下 批处理脚本 来自动添加。\n步骤 新建一个 add_vscode_context_menu.bat 文件\n复制以下代码 并粘贴进去 (注意修改 VS code 安装路径)：\n1 2 3 4 5 @echo off REG ADD \u0026#34;HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\Open with VS Code\u0026#34; /ve /t REG_SZ /d \u0026#34;在此处打开 VS Code\u0026#34; /f REG ADD \u0026#34;HKEY_CLASSES_ROOT\\Directory\\Background\\shell\\Open with VS Code\\command\u0026#34; /ve /t REG_SZ /d \u0026#34;\\\u0026#34;C:\\Users\\%USERNAME%\\AppData\\Local\\Programs\\Microsoft VS Code\\Code.exe\\\u0026#34; \\\u0026#34;%%V\\\u0026#34;\u0026#34; /f echo VS Code 右键菜单添加成功！ pause 右键点击该 .bat 文件，选择 以管理员身份运行\n运行完毕后，右键点击文件夹空白处，看看是否出现 \u0026ldquo;在此处打开 VS Code\u0026rdquo; 选项。\n","permalink":"http://localhost:1313/posts/other/2025-02-27/","summary":"VS code设置","title":"VS code设置：右击文件夹出现“在这里打开 VS code”选项"},{"content":"在 LaTeX 生态中，latex、pdflatex、xelatex 和 lualatex 是不同的编译引擎，各自有不同的特点和适用场景。\n1. latex 最古老的 LaTeX 编译器，输出的是 DVI 文件，不是 PDF 文件 需要使用 dvips 或 dvipdf 等工具将 DVI 文件转换为 PDF 文件（latex → DVI → PS → PDF）。 不支持直接插入 PNG、JPEG、PDF 等图片格式，只支持 EPS 格式。 不支持直接插入中文，需要使用 xeCJK 或 CJK 宏包。 2. pdflatex 直接生成 PDF 文件（不需要使用 dvips 或 dvipdf 等转换工具）。 支持直接插入 PNG、JPEG、PDF 等图片格式（但不支持 EPS 格式）。 不支持 Unicode，默认采用 8-bit 编码（如 latin1、utf8 需用 inputenc 宏包） 对中文支持较差，需要 CJK 宏包（或 ctex 宏包）。 适合英文和西方语言文档（默认 8-bit 编码） 如果一定要用 pdflatex 处理中文，需要 1 \\usepackage[CJKutf8]{CJK} 3. xelatex 直接生成 PDF 文件（不需要使用 dvips 或 dvipdf 等转换工具）。 支持 Unicode，默认采用 UTF-8 编码，适用于多语言文档（包括中文） 支持 OpenType/TrueType（OTF/TTF）字体，可以直接使用系统字体（如宋体、楷体、黑体、SimSun、SimHei 等） 支持 fontspec 宏包，使字体管理更灵活。 支持直接插入 PNG、JPEG、PDF 等图片格式（但不支持 EPS 格式）。 CTeX 默认推荐 xelatex 4. lualatex（推荐用于高级应用，如 Lua 代码交互） 支持 Unicode 和 OpenType 字体。 支持 fontspec 宏包（字体管理）。 支持 luacode 宏包，可以在 LaTeX 代码中直接写 Lua 代码，例如： 1 2 3 4 \\usepackage{luacode} \\begin{luacode} tex.print(\u0026#34;你好，LuaLaTeX！\u0026#34;) \\end{luacode} 5. 总结 编译器 是否支持 Unicode 直接输出 PDF 适用于中文 图片支持 推荐用途 latex ❌ 否 ❌ 需转换 ❌ 需 CJK 仅支持 EPS 过时，基本不用 pdflatex ❌ 否 ✅ 是 ⚠️ 需 CJK PNG、JPEG、PDF 适用于英文或简单中文 xelatex ✅ 是 ✅ 是 ✅ 推荐 PNG、JPEG、PDF 推荐中文文档、支持系统字体 lualatex ✅ 是 ✅ 是 ✅ 推荐 PNG、JPEG、PDF 高级排版、动态 Lua 代码 小贴士 Unicode 是字符集，定义了世界上所有语言的字符例如\nA → U+0041 你 → U+4F60 😊 → U+1F60A 但Unicode 只规定了字符编号（码点），并没有规定如何存储这些字符。\n计算机只能存储 二进制数据（0 和 1），所以我们需要 字符编码（Character Encoding）把 Unicode 转换成二进制。\nUTF-8 是 Unicode 的一种编码方式，是一种 可变长度的 Unicode 编码\n1 个字节（8-bit） 表示 ASCII 字符（兼容英语）。 2~4 个字节 表示其他 Unicode 字符（如中文、Emoji）。 A → U+0041 → 0x41（1 字节） 你 → U+4F60 → 0xE4BDA0（3 字节） 😊 → U+1F60A → 0xF09F988A（4 字节） 8-bit 编码 主要指 每个字符占 1 个字节（8 位） 的旧式编码，常见的包括\nASCII：标准 ASCII 只使用 7-bit（128 个字符），由于 7-bit 只能表示 128 个字符，后来扩展到 8-bit（256 个字符） ISO-8859-1：用于西欧语言，支持法语、德语、西班牙语等， 但不支持中文 GB2312 (6,763个汉字) / GBK(21,003个汉字) / GB18030（Unicode所有汉字） ","permalink":"http://localhost:1313/posts/latex/2025-02-24-latex/","summary":"Learn About LaTex","title":"LaTex 系列 - 1. LaTex 编译器介绍"},{"content":"1. 安装git 这里没什么好说的，官网下载，默认安装。\n2. 配置 git 用户信息 2.1 配置 Git 用户信息 1 2 git config --global user.name \u0026#34;GitHub用户名\u0026#34; # 不需要引号 git config --global user.email \u0026#34;GitHub邮箱\u0026#34; # 不需要引号 2.2 设置 SSH Key 生成 SSH Key\n1 ssh-keygen -t rsa -b 4096 -C \u0026#34;GitHub邮箱\u0026#34; # 不需要引号 -t rsa：使用 RSA 加密算法 -b 4096：密钥长度为 4096 位（更安全） -C \u0026quot;GitHub邮箱\u0026quot;：标识 SSH Key，方便管理 接下来 terminal 提示：\n1 Enter file in which to save the key (/home/user/.ssh/id_rsa): 直接按回车即可（使用默认路径 ~/.ssh/id_rsa）\n接下来 terminal 提示输入密码：\n1 2 Enter passphrase (empty for no passphrase): Enter same passphrase again: 两次回车即可（默认不输入密码），否则每次推送 Git 都需要输入密码\n生成的 SSH密钥 存放在 ~/.ssh/id_rsa.pub\n2.3 将 SSH密钥 添加到 GitHub 账户的 SSH Keys 中 复制 SSH Key 1 cat ~/.ssh/id_rsa.pub 添加到 GitHub 登录 GitHub 账户 点击右上头像 -\u0026gt; Settings（设置） 左侧选择 SSH and GPG keys（SSH 和 GPG 密钥） 点击 New SSH key（新建 SSH 密钥） Title: 可以自定义 Key: 粘贴复制的 SSH Key 点击 Add SSH key 2.3 测试 SSH 连接 1 ssh -T git@github.com 如果配置成功，会显示：\n1 Hi \u0026lt;GitHub用户名\u0026gt;! You\u0026#39;ve successfully authenticated, but GitHub does not provide shell access. 3. 修改文件，提交到本地仓库 进入 path/to/your/workspace/XXX 文件夹，修改其中的文件 AAA.xx，然后执行以下命令：\n1 git status 执行后，会显示\n1 2 3 4 Changes not stated for commit: (use \u0026#34;git add \u0026lt;file\u0026gt;...\u0026#34; to update what will be committed) (use \u0026#34;git restore \u0026lt;file\u0026gt;...\u0026#34; to discard changes in working directory) modified: AAA.xx 表明：\nAAA.xx 文件被修改 该文件的修改没有被添加到暂存区 接下来，执行以下命令：\n1 git add AAA.xx # 将 AAA.xx 文件添加到暂存区 再次执行以下命令\n1 git commit -m \u0026#34;第一次修改\u0026#34; # 将暂存区的文件提交到本地仓库，并添加提交备注信息 4. 本地仓库关联配置远程仓库（新建远程仓库后第一次推送） 首先，在 GitHub 上新建一个仓库 (Github 仓库新建后的默认分支是 main)\n本地仓库中文件每次修改后，如需推送，需要按顺序执行以下 Git 操作\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 1 切换到仓库根目录 cd \u0026#34;本地仓库路径\u0026#34; # 2 初始化 Git 仓库 git init # 3 添加所有文件到暂存区 git add . # 4 提交文件 git commit -m \u0026#34;Initial commit\u0026#34; # 5 origin = SSH，并且添加 origin（以后命令行可以用 origin 代表远程仓库） git remote add origin SSH地址 # 6 强制重命名本地仓库的当前分支为 main git branch -M main # 7 第一次推送：将本地的 main 分支推送到 GitHub git push -u origin main 注意：\nGit 仓库默认的主分支是 master，但 GitHub 仓库采用 main 作为默认分支，所以用命令 git branch -M main 将本地分支当前分支 master 改为 main。 第一次推送执行 git push -u origin main ，-u 选项将本地的 main 分支与远程的 origin/main 关联起来，使得后续推送和拉取更方便。 如果不使用 -u 选项，后续推送时需要使用 git push origin main。 使用了 -u 选项后，后续推送时可以直接使用 git push。 -u 的全写是 --set-upstream。 执行完上述指令后，打开 GitHub 仓库, 会看到本地仓库已经推送.\n5. 推送本地仓库到远程仓库（非第一次推送） 执行以下指令，推送本地仓库到远程仓库\n1 git push 执行以下指令，远程仓库拉取到本地仓库\n1 git pull 总结 SSH 密钥配置，不需要每次验证\n从远程仓库 clone 到本地：\ngit clone 远程仓库地址 本地仓库与远程仓库的关联配置（首次推送）：\ngit add . # 提交到暂存区 git commit -m \u0026quot;提交备注信息\u0026quot; # 提交到本地仓库 git remote add origin 远程仓库地址 # 将本地仓库与远程仓库关联 git remote -v # 查看远程仓库的信息 git branch -M main git push -u origin main # 将本地的当前分支与远程的 origin/main 关联并推送 本地仓库提交到远程仓库的流程（非首次推送）：\ngit add . # 提交到暂存区 git commit -m \u0026quot;提交备注信息\u0026quot; # 提交到本地仓库 git push # 提交到远程仓库 上面两条指令可以简化为下面一条指令\ngit commit -am \u0026quot;提交备注信息\u0026quot; # 提交到本地仓库 ","permalink":"http://localhost:1313/posts/git/2025-02-23-git-install/","summary":"Learn About Git \u0026amp; GitHub","title":"Git 系列 - 1. 安装 Git 与配置 Github"},{"content":"1.安装必要软件 一行代码搭建机器人开发环境(ROS/ROS2/ROSDEP)\n1 wget http://fishros.com/install -O fishros \u0026amp;\u0026amp; . fishros 选项：\n[1] 安装 noetic(ros1) [3] 安装 rosdep ","permalink":"http://localhost:1313/posts/git/2025-02-23-git-matlab/","summary":"Learn About Git \u0026amp; Matlab","title":"Git 系列 - 2. Matlab 同步 Git"},{"content":"原理 Texstudio 编译 A/main.tex，本质上是 cmd 进入路径 A，然后执行\n1 pdflatex main.tex 因为推送本地仓库到 github 需要在 cmd 执行 git 指令\n1 2 3 4 git add . git commit -m \u0026#34;First Submit\u0026#34; git branch -M main git push -u origin main 所以如果可以利用texstudio在tex文件路径执行上述指令，即可实现仅通过texstudio推送tex文件至github\nTexStudio 配置 texstudio 中如下配置\nTools -\u0026gt; User -\u0026gt; Git command 等价于在命令行当前目录下执行 Git command\n如何实现 第一次推送需要命令行，后续推送仅需texstudio\n第一次推送：\n1 2 3 4 5 6 git init git remote add origin github_SSH_address git add . # 每次推送执行 git commit -m \u0026#34;First Submit\u0026#34; # 每次推送执行 git branch -M main # 首次推送执行 git push -u origin main # 首次推送执行 后续推送/拉取：\n1 2 3 4 git add . # 每次推送执行 git commit -m \u0026#34;First Submit\u0026#34; # 每次推送执行 git push # 每次推送执行 git pull # 每次拉取执行 注意：上面两行命令等价于下面一行命令\n1 git commit -am \u0026#34;First Submit\u0026#34; # 每次推送执行 ","permalink":"http://localhost:1313/posts/git/2025-02-23-git-texstudio/","summary":"Learn About All Features in PaperMod","title":"Git 系列 - 3. Texstudio 同步 Git"},{"content":"1. 分支的本地操作 新建分支 新建分支 branch_A\n1 git branch branch_A 切换到分支 branch_A\n1 git checkout branch_A 新建分支 branch_B 并切换到分支 branch_B (下面一行效果等同于上面两行)\n1 git checkout -b branch_B 查看分支 查看本地分支\n1 git branch 查看远程分支\n1 git branch -r 查看所有分支\n1 git branch -a 合并分支 合并分支 branch_B 到分支 branch_A: 先切换到分支 branch_A，再执行 git merge\n1 2 git checkout branch_A # 切换当前分支为 branch_A git merge branch_B # 合并分支 branch_B 到当前分支 (branch_A) 删除分支 删除分支 branch_B\n1 2 git branch -d branch_B # 安全删除 git branch -D branch_B # 强制删除 2. 分支的远程操作 推送本地分支到远程仓库 本地分支 branch_A 推送到远程仓库\n1 git push origin branch_A 关联本地分支与远程分支\n删除远程分支 删除远程仓库 origin 的分支 branch_C\n1 git push origin --delete branch_C 注意，远程不一定叫origin，可以是其他名字。\n","permalink":"http://localhost:1313/posts/git/2025-02-23-git-branch/","summary":"Learn About Git \u0026amp; branch","title":"Git 系列 - 4. Git 分支管理"},{"content":"In this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates (extend_head.html) like so: refer ISSUE #236 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTex globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTex on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Block math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\n","permalink":"http://localhost:1313/posts/reinforcement_learning/2025-02-20-rl-pg/","summary":"Learn About DQN in Stochastic Policy Gradient","title":"强化学习系列 - 2. Stochastic Policy Gradient"},{"content":"AppImage 是一种便携式软件包格式，允许你在 Linux 上运行应用程序 无需安装。以下是下载、运行和管理 AppImage 文件的方法\n1. 下载 AppImage 文件 2. 赋予 AppImage 文件可执行权限 AppImage 文件运行需要赋予权限，以下是赋予权限的两种方式。\n方法1：使用终端 1 2 chmod +x ~/Downloads/your_app.AppImage ./your_app.AppImage 方法2：使用图形界面 右键点击 AppImage 文件，选择 \u0026ldquo;属性\u0026rdquo;（Properties）。 切换到 \u0026ldquo;权限\u0026rdquo;（Permissions） 选项卡。 勾选 \u0026ldquo;允许作为可执行文件\u0026rdquo;（Allow executing file as a program）。 双击 AppImage 运行程序。 3. 使用 AppImageLauncher 管理 AppImage AppImage 默认不会自动出现在应用菜单中。\nAppImageLauncher 可以自动管理 AppImage 并集成到系统菜单中\n1 2 3 sudo add-apt-repository ppa:appimagelauncher-team/stable sudo apt update sudo apt install appimagelauncher 4. 将 AppImage 移动到 /opt 并创建全局快捷方式 如果你希望让 AppImage 可在整个系统中使用\n1 2 3 sudo mv ~/Downloads/your_app.AppImage /opt/your_app.AppImage sudo chmod +x /opt/your_app.AppImage sudo ln -s /opt/your_app.AppImage /usr/local/bin/your_app 5. 更新 AppImage 部分 AppImage 支持自动更新，例如：\n1 ./your_app.AppImage --update 如果 AppImage 不支持更新，你需要手动下载新版并替换旧版。\n6. 删除 AppImage 由于 AppImage 是一个独立的可执行文件，删除它就等于卸载：\n1 rm ~/Downloads/your_app.AppImage 如果你用 AppImageLauncher 集成了 AppImage，可以在 /Applications 目录中找到它，并右键选择 \u0026ldquo;删除\u0026rdquo;。\n6.Hugo 部署到 Github Pages 🚀 ","permalink":"http://localhost:1313/posts/ubuntu/2025-02-17-ubuntu-appimage/","summary":"Learn About Ubuntu","title":"Ubuntu系列 - 1. 安装AppImage应用"},{"content":"1. Ubuntu 目录结构 1.1 用户主目录 ~ = /home/username/ 在 ubuntu 系统中，波浪线 ~ 在命令行环境下是 “用户主目录”（Home Directory）的缩写或别名。\n例如 ~/.bashrc:\n~ 代表的就是当前用户的主目录（/home/username/） ~/.bashrc 实际上就是 /home/username/.bashrc 2. shell 和 terminal 2.1 Shell 是什么 Shell 是一种软件层，用来接收用户输入的命令，然后将这些命令传递给操作系统内核去执行。也可以理解为人与操作系统之间的“翻译”或“交互接口”。\n2.2 Shell 的种类 bash Shell: Ubuntu 默认的 Shell zsh Shell fish Shell csh/tcsh Shell 每种 Shell 都有自己的语法特性、配置文件和内置工具，但它们的基本功能相似：运行命令、编写脚本、管理进程和环境变量等。\n2.3 常用的 Shell 配置文件 ~/.bashrc: bash Shell 的配置文件 ~/.zshrc: zsh Shell 的配置文件 ~/.config/fish/config.fish: fish Shell 的配置文件 2.4 Shell 的工作流程 读取用户输入的命令 解释和解析命令，交给操作系统 显示执行结果 2.5 常用的 Shell 命令 echo: 打印文本或变量的值 cd: 改变当前目录 ls: 列出当前目录中的文件和文件夹 2.6 常用的 Shell 快捷键 Ctrl + L: 清屏 Ctrl + C: 中断当前命令 Ctrl + D: 退出当前 Shell 2.7 什么是 terminal \u0026ldquo;终端\u0026rdquo; 指的是实际的硬件设备（如显示器/键盘），通过串口或其他方式连到主机。 Ubuntu 的 terminal 是一个 \u0026ldquo;终端\u0026rdquo; 的软件模拟器 2.8 terminal 和 shell 的关系 terminal: 是一个 “文本交互界面”, 提供了一个文本窗口，允许用户在其中输入命令、接收输出 shell: 是一个命令行解释器，它接收用户在 terminal 内输入的命令，并将其传递给操作系统内核去执行。 Terminal：相当于“聊天窗口” Shell：相当于“对话的另一端的人”（或自动回复程序） 2.9 例子 在 Ubuntu 的 terminal 里输入一条命令： 1 ls -l Terminal 会把这条文本交给正在运行的 Shell（一般是 Bash） Bash 解析这条命令，调用相应的系统调用或程序来列出目录下的文件和文件夹 然后 Bash 把执行结果返回给 Terminal，Terminal 再把结果显示给用户 3. 配置脚本文件 ~/.bashrc 3.1 terminal/shell 启动流程 在 Ubuntu 系统中，点开 terminal 图标，新开一个 terminal 窗口时，会发生以下事情：\n启动一个终端模拟器 terminal，它会创建一个非登录、交互式的 Bash Shell。 Bash Shell 尝试查找并读取 /etc/bash.bashrc（系统全局的 bashrc，可选） Bash Shell 尝试查找并读取当前用户的 ~/.bashrc（用户自定义的 bashrc） Bash Shell 环境初始化完成，用户在就可以正常使用终端了。 3.2 ~/.bashrc 的功能 初始化 Shell\n定义/修改 PATH 等环境变量\n1 2 export PATH=\u0026#34;$HOME/bin:$PATH\u0026#34; export EDITOR=vim 为常用命令设置别名（alias），简化输入，例如\n1 2 alias ll=\u0026#39;ls -l\u0026#39; alias gs=\u0026#39;git status\u0026#39; 让 ~/.bashrc 的修改立即生效（以下两个指令等价）：\n1 2 source ~/.bashrc . ~/.bashrc 配置命令提示符（PS1）：命令行中看到的提示符样式，就是由 PS1 的配置决定的\n1 PS1=\u0026#34;\\u@\\h:\\w\\$ \u0026#34; PS1: Bash 中用于定义主提示符（Primary Prompt）的变量 \\u：当前用户名（user name） \\h：当前主机名（host name）中的前半部分（不含域名） \\w：当前工作目录（working directory），会以相对路径显示，如果是 home 目录则显示 ~ \\$：如果是普通用户则显示 $，如果是 root 用户（即超级用户）则显示 # 最后的空格: 是为了让命令提示符后留出一个空格，便于输入命令 2.3 不同类型的 Shell 的 Bash 启动流程 登录Shell（Login Shell） 通过 SSH 登录远程主机，或者在系统中输入 用户名/密码 直接登录时，启动的 Shell 就是 登录Shell 这种情况下，Bash Shell 会先读取并执行 /etc/profile，然后依次读取 ~/.bash_profile, ~/.bash_login, ~/.profile（谁先被找到就执行哪个，通常系统会默认用 ~/.bash_profile 或 ~/.profile） 非登录Shell（Non-login Shell） 在图形界面下打开一个 Terminal: 通常是通过 Ctrl + Alt + T 快捷键打开的终端，或者通过 gnome-terminal 命令打开的终端 这种情况下，Bash Shell 只会读取并执行 ~/.bashrc 交互式（Interactive）与非交互式（Non-interactive） 交互式 Shell：用户与 Shell 之间的交互，例如通过 Ctrl + Alt + T 快捷键打开的终端，用户可以通过键盘输入命令 非交互式 Shell：Shell 不与用户交互，例如通过脚本执行命令（脚本首行需要写 #!/usr/bin/env bash） 总结：~/.bashrc 默认只在“非登录式且交互式”的 Bash Shell 启动时被读取执行\n","permalink":"http://localhost:1313/posts/ubuntu/2025-02-23-ubuntu-shell/","summary":"Learn About Ubuntu","title":"Ubuntu系列 - 2. bash shell, terminal 和 ~/.bashrc"},{"content":"1.DQN 算法流程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 # 0. 初始化 # 0.1 初始化环境 env env = # 0.2 初始化 DQN q(s, a; θ) = q_(s, a; θ_) = # 0.3 初始化经验回放库 Buffer replay_buffer = # 主循环：N 个 episode for episode = 1 to M: # 1. 初始化 s_t = env.reset() # 初始化状态 s_t episode_return = 0 # 初始化累计回报 episode_return # 每个 episode done = False while not done: # 2. 以 ε-贪婪策略生成动作 a_t a_t = argmax_a Q(s_t, a; θ) or random # 3. 执行动作 a_t，得到奖励 r_t、新状态 s_{t+1}、以及游戏结束标志 done s_{t+1}, r_t, done, _ = env.step(a_t) # 4. 存储一次交互数据 (s_t, a_t, r_t, φ_{t+1}, done) 至经验回放库 replay_buffer replay_buffer.append( (s_t, a_t, r_t, s_{t+1}, done) ) # 5. 当 replay_buffer 数据量满足最小长度 (比如500)，从 replay_buffer 中随机抽取一批数据 batch \u0026lt;- {s_j, a_j, r_j, s_{j+1}, done_j}, j = 1, ..., minimal_size（ batch 数据量为 minimal_size ） if len(Buffer) \u0026gt; 500: batch \u0026lt;- replay_buffer( 1, ..., minimal_size ) # 6. 利用采样数据 batch 训练 DQN DQN.train(batch) # 7. 更新状态 s_t \u0026lt;- s_{t+1} s_t = s_{t+1} # 8. 更新累计回报 episode_return += reward # 更新累计回报 if done: break ","permalink":"http://localhost:1313/posts/reinforcement_learning/2025-02-16-rl-dqn/","summary":"Learn About DQN in RL","title":"强化学习系列 - 1. DQN"},{"content":"1. PyTorch 中使用 TensorBoard 通过 SummaryWriter 记录数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 import torch import torch.nn as nn import torch.optim as optim from torch.utils.tensorboard import SummaryWriter import numpy as np # 初始化 TensorBoard 记录器 writer = SummaryWriter(log_dir=\u0026#34;runs/experiment_1\u0026#34;) # 创建一个简单的模型 model = nn.Linear(1, 1) criterion = nn.MSELoss() optimizer = optim.SGD(model.parameters(), lr=0.01) # 训练循环 for epoch in range(100): x = torch.tensor([[epoch]], dtype=torch.float32) y = torch.tensor([[2 * epoch + 1]], dtype=torch.float32) output = model(x) loss = criterion(output, y) optimizer.zero_grad() loss.backward() optimizer.step() # 记录损失 writer.add_scalar(\u0026#34;Loss/train\u0026#34;, loss.item(), epoch) # 记录权重和梯度 for name, param in model.named_parameters(): writer.add_histogram(name, param, epoch) writer.add_histogram(f\u0026#34;{name}.grad\u0026#34;, param.grad, epoch) writer.close() 在终端启动 TensorBoard\n1 tensorboard --logdir=runs --port=6006 2. TensorFlow 中使用 TensorBoard 记录数据（不需要 SummaryWriter）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import tensorflow as tf import datetime # 创建日志目录 log_dir = \u0026#34;logs/fit/\u0026#34; + datetime.datetime.now().strftime(\u0026#34;%Y%m%d-%H%M%S\u0026#34;) tensorboard_callback = tf.keras.callbacks.TensorBoard(log_dir=log_dir, histogram_freq=1) # 创建一个简单模型，指定 NN 结构 model = tf.keras.Sequential([ tf.keras.layers.Dense(128, activation=\u0026#39;relu\u0026#39;), tf.keras.layers.Dense(10) ]) # 指定NN训练方法为 adam, 损失函数为 SparseCategoricalCrossentropy model.compile(optimizer=\u0026#39;adam\u0026#39;, loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True), metrics=[\u0026#39;accuracy\u0026#39;]) # 训练模型，并使用 TensorBoard 记录 model.fit( tf.random.normal([1000, 32]), tf.random.uniform([1000], maxval=10, dtype=tf.int32), epochs=5, callbacks=[tensorboard_callback] ) 在终端启动 TensorBoard\n1 tensorboard --logdir=logs/fit --port=6006 必选参数：\nhelp=\u0026quot;输入文件的路径\u0026quot;: 在 --help 命令中显示的参数说明 当执行脚本时，需要紧随其后提供必选参数 filename，否则会报错。例如（下面指令中的 input.txt 就是参数 \u0026ldquo;filename\u0026rdquo;） 1 python script.py input.txt 可选参数1：\n-v 和 --verbose: 代表同一个可选参数，用户可以使用任一形式。 action=\u0026quot;store_true\u0026quot;: 当这个选项被使用时，将在解析结果中把 verbose 设置为 True（不使用则为 False）。 help=\u0026quot;是否输出详细信息（布尔开关）\u0026quot;: help 中的内容会在 --help 命令中显示。 可选参数2：\ntype=int：将输入值转换为整数类型（如果传入值无法转换会报错）。 default=1：当用户没有提供该参数时，使用默认值 1。 定义完上面的代码文件后，在命令行的执行如下\n1 2 3 4 5 6 # 带所有参数 python script.py myfile.txt -v -n 3 # 或者：python script.py myfile.txt --verbose --number 3 # 不带可选参数 python script.py myfile.txt 3. 分析 为什么一个是 --logdir=runs 另一个是 --logdir=logs\nPyTorch 示例中，日志记录路径是 \u0026quot;runs/experiment_1\u0026quot;， runs/ 是 SummaryWriter(log_dir=\u0026quot;runs/experiment_1\u0026quot;) 指定的路径的父目录 TensorFlow 示例 中，日志记录路径是 \u0026quot;logs/fit/...\u0026quot;，logs/fit/ 是 log_dir 变量中的路径前缀 PyTorch 通常默认使用 \u0026quot;runs/\u0026quot; 作为日志目录，SummaryWriter 就是这么做的。 TensorFlow 示例中，通常使用 \u0026quot;logs/fit/\u0026quot; + datetime 作为日志目录，所以 TensorBoard 需要从 \u0026quot;logs/fit\u0026quot; 读取数据。 ","permalink":"http://localhost:1313/posts/python/2025-02-15-python-tensorboard/","summary":"Learn About argparse in Python","title":"Python 系列 - 2. tensorboard"},{"content":"1.安装必要软件 一行代码搭建机器人开发环境(ROS/ROS2/ROSDEP)\n1 wget http://fishros.com/install -O fishros \u0026amp;\u0026amp; . fishros 选项：\n[1] 安装 noetic(ros1) [3] 安装 rosdep ","permalink":"http://localhost:1313/posts/ros/2025-02-14-ros-install/","summary":"Learn About ROS1","title":"ROS1系列 - 1. 一键安装 ROS Neotic"},{"content":"1.什么是 argparse argparse 是一个强大的命令行参数解析工具，用于构建命令行脚本或程序时，可以非常方便地对传入的参数进行解释和处理。\n在编写命令行工具或脚本时，往往需要接收来自命令行的参数或选项，以实现配置。\nargparse 则能让你以更高层次、更结构化的方式来定义程序期望的参数形式，以及如何处理这些参数，从而自动生成帮助信息、错误信息等。\n2.基本用法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 import argparse def main(): \u0026#39;\u0026#39;\u0026#39;第一步：创建一个解析器对象，可以给出程序的简单描述\u0026#39;\u0026#39;\u0026#39; parser = argparse.ArgumentParser(description=\u0026#34;这是一个示例命令行工具\u0026#34;) \u0026#39;\u0026#39;\u0026#39;第二步：添加命令行参数和选项\u0026#39;\u0026#39;\u0026#39; # 添加必选参数: 在命令中不需要特意写 -x 或者 --xx ，是脚本必须要获取的数据。 parser.add_argument(\u0026#34;filename\u0026#34;, help=\u0026#34;输入文件的路径\u0026#34;) # 添加可选参数1：一般以短选项（如 -v）或长选项（如 --verbose）的形式出现。 parser.add_argument(\u0026#34;-v\u0026#34;, \u0026#34;--verbose\u0026#34;, action=\u0026#34;store_true\u0026#34;, help=\u0026#34;是否输出详细信息（布尔开关）\u0026#34; ) # 添加可选参数2：一般以短选项（如 -v）或长选项（如 --verbose）的形式出现。 parser.add_argument(\u0026#34;-n\u0026#34;, \u0026#34;--number\u0026#34;, type=int, default=1, help=\u0026#34;重复操作次数，默认为 1\u0026#34; ) # 添加可选参数3：接收某个范围或集合中的值 parser.add_argument(\u0026#34;--mode\u0026#34;, choices=[\u0026#34;train\u0026#34;, \u0026#34;test\u0026#34;, \u0026#34;eval\u0026#34;], help=\u0026#34;模式选择\u0026#34; ) # 添加可选参数4：指定参数的别名 parser.add_argument(\u0026#34;-m\u0026#34;, \u0026#34;--mode\u0026#34;, choices=[\u0026#34;train\u0026#34;, \u0026#34;test\u0026#34;, \u0026#34;eval\u0026#34;] ) \u0026#39;\u0026#39;\u0026#39;第三步：解析命令行参数\u0026#39;\u0026#39;\u0026#39; # args 就是一个包含解析后参数的命名空间对象, 属性名即为参数名。 args = parser.parse_args() # 通过 args.filename 访问参数 filename print(\u0026#34;文件名：\u0026#34;, args.filename) print(\u0026#34;是否详细输出：\u0026#34;, args.verbose) print(\u0026#34;操作次数：\u0026#34;, args.number) if __name__ == \u0026#34;__main__\u0026#34;: main() 必选参数：\nhelp=\u0026quot;输入文件的路径\u0026quot;: 在 --help 命令中显示的参数说明 当执行脚本时，需要紧随其后提供必选参数 filename，否则会报错。例如（下面指令中的 input.txt 就是参数 \u0026ldquo;filename\u0026rdquo;） 1 python script.py input.txt 可选参数1：\n-v 和 --verbose: 代表同一个可选参数，用户可以使用任一形式。 action=\u0026quot;store_true\u0026quot;: 当这个选项被使用时，将在解析结果中把 verbose 设置为 True（不使用则为 False）。 help=\u0026quot;是否输出详细信息（布尔开关）\u0026quot;: help 中的内容会在 --help 命令中显示。 可选参数2：\ntype=int：将输入值转换为整数类型（如果传入值无法转换会报错）。 default=1：当用户没有提供该参数时，使用默认值 1。 定义完上面的代码文件后，在命令行的执行如下\n1 2 3 4 5 6 # 带所有参数 python script.py myfile.txt -v -n 3 # 或者：python script.py myfile.txt --verbose --number 3 # 不带可选参数 python script.py myfile.txt ","permalink":"http://localhost:1313/posts/python/2025-02-13-python-argparse/","summary":"Learn About argparse in Python","title":"Python 系列 - 1. 命令行解析器 argparse"},{"content":"1. 安装必要软件 按照以下顺序安装软件（因为相互依赖关系）\nGit\nPowershell 7.x\nwin11 自带 Powershell 的版本是 5.1，需要更新到 7.x。\n首先，在win11自带 Powershell 里输入以下指令，安装最新稳定版\n1 winget install --id Microsoft.Powershell --source winget 接下来的命令行操作都在 7.x 的 Powershell 内执行 。\nVS Code\nGo\ngo安装说明见官网 https://go.dev/doc/install\nGithub账户\nchoco\n参考官网 https://docs.chocolatey.org/en-us/choco/setup/ 安装choco，执行以下指令\n1 Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString(\u0026#39;https://community.chocolatey.org/install.ps1\u0026#39;)) Hugo\n执行以下指令，利用 choco 安装 hugo\n1 choco install hugo-extended Dart Sass\n执行以下指令，利用 choco 安装 Sass\n1 choco install sass 2. Hugo生成静态站点 Powershell 切换至文件夹 A，执行以下指令\n1 2 cd A hugo new site demo --format yaml 执行完上面指令后，hugo 会生成网站，网站根目录为 A/demo。\n注意：打开网站根目录 A/demo，会发现hugo生成了很多文件，其中最重要的是配置文件 hugo.yaml。 网站的配置文件，会略有区别。常见的配置文件有\nhugo.yaml / hugo.toml config.yaml / config.toml 切换路径至网站根目录 A/demo，执行 git 初始化，为后续步骤做准备。\n1 git init 3. Hugo配置Theme 安装 Hugo 主题，参考官网 Hugo themes，接下来我们以 papermod 为例\n安装 Hugo 主题 papermod，执行以下指令\n1 2 3 git submodule add --depth=1 https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod git submodule update --init --recursive # 当我们要从github上拉去仓库时需要这个指令 git submodule update --remote --merge 执行上述指令后，主题 papermod 会存放在路径 A/demo/themes/papermod。\n配置主题 papermod 的配置文件 hugo.yaml 如下：\n1 echo \u0026#34;theme = \u0026#39;ananke\u0026#39;\u0026#34; \u0026gt;\u0026gt; hugo.toml 执行完上面指令后，网站配置文件最后一行会添加以下内容\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 baseURL: https://yylustb.github.io/ languageCode: en-us title: My New Hugo Site theme: [\u0026#34;PaperMod\u0026#34;] paginate: 5 # 列表页显示文章数 # 默认支持首页 HTML 页面、RSS 订阅、JSON（搜索），可以满足大多数 Hugo 博客需求。 outputs: home: # 主页输出 - HTML - RSS - JSON markup: goldmark: # Hugo 默认使用的 Markdown 渲染引擎 renderer: unsafe: true # 控制是否允许在 Markdown 中渲染 “不安全（raw）” 的 HTML 标签 # 在 Markdown 文件中编写的原生 HTML（例如 \u0026lt;script\u0026gt;, \u0026lt;iframe\u0026gt; 或者其他 HTML 标签）， # 在最终生成的页面中会被原样保留并渲染 highlight: lineNos: true # 是否在代码高亮时显示行号 noClasses: false # 不要禁用 class codeFences: true # 启用 Markdown 代码块语法（```） style: \u0026#34;monokai\u0026#34; params: env: production title: ExampleSite # 站点的标题 description: \u0026#34;ExampleSite description\u0026#34; # 站点的描述信息 keywords: [Blog, Portfolio, PaperMod] # 站点的关键词，有助于 SEO author: Me # 站点的作者 # author: [\u0026#34;Me\u0026#34;, \u0026#34;You\u0026#34;] # multiple authors images: [\u0026#34;\u0026lt;link or path of image for opengraph, twitter-cards\u0026gt;\u0026#34;] # 用于社交分享时的默认封面图片 DateFormat: \u0026#34;January 2, 2006\u0026#34; # 文章日期的显示格式 defaultTheme: auto # dark, light # 站点默认主题模式（自动适应用户偏好） disableThemeToggle: false # 是否禁用深色/浅色模式切换 ShowReadingTime: true # 显示阅读时间 ShowShareButtons: true # 显示社交分享按钮 ShowPostNavLinks: true ShowBreadCrumbs: true ShowCodeCopyButtons: false ShowWordCount: true ShowRssButtonInSectionTermList: true # 在分类/标签页显示 RSS 订阅按钮 UseHugoToc: true disableSpecial1stPost: false disableScrollToTop: false comments: false hidemeta: false hideSummary: false # 是否隐藏文章摘要 showtoc: false # 是否显示文章目录 tocopen: false # 是否默认展开目录 assets: # disableHLJS: true # to disable highlight.js # disableFingerprinting: true favicon: \u0026#34;\u0026lt;link / abs url\u0026gt;\u0026#34; favicon16x16: \u0026#34;\u0026lt;link / abs url\u0026gt;\u0026#34; favicon32x32: \u0026#34;\u0026lt;link / abs url\u0026gt;\u0026#34; apple_touch_icon: \u0026#34;\u0026lt;link / abs url\u0026gt;\u0026#34; safari_pinned_tab: \u0026#34;\u0026lt;link / abs url\u0026gt;\u0026#34; label: text: \u0026#34;Home\u0026#34; icon: /apple-touch-icon.png iconHeight: 35 # profile-mode profileMode: enabled: false # needs to be explicitly set title: ExampleSite subtitle: \u0026#34;This is subtitle\u0026#34; imageUrl: \u0026#34;\u0026lt;img location\u0026gt;\u0026#34; imageWidth: 120 imageHeight: 120 imageTitle: my image buttons: - name: Posts url: posts - name: Tags url: tags homeInfoParams: # 主页信息模式（如果启用，会在主页显示欢迎信息） Title: \u0026#34;Hi there \\U0001F44B\u0026#34; # 主页欢迎信息标题 Content: Welcome to my blog # 主页欢迎信息内容 socialIcons: - name: x url: \u0026#34;https://x.com/\u0026#34; - name: stackoverflow url: \u0026#34;https://stackoverflow.com\u0026#34; - name: github url: \u0026#34;https://github.com/\u0026#34; analytics: google: SiteVerificationTag: \u0026#34;XYZabc\u0026#34; bing: SiteVerificationTag: \u0026#34;XYZabc\u0026#34; yandex: SiteVerificationTag: \u0026#34;XYZabc\u0026#34; cover: # hidden: true # 隐藏封面图片 # hiddenInList: true # 列表页隐藏封面图哦 # hiddenInSingle: true # 文章页面隐藏封面图片 editPost: URL: \u0026#34;https://github.com/\u0026lt;path_to_repo\u0026gt;/content\u0026#34; Text: \u0026#34;Suggest Changes\u0026#34; # edit text appendFilePath: true # to append file path to Edit link # 搜索设置 fuseOpts: isCaseSensitive: false shouldSort: true location: 0 distance: 1000 threshold: 0.4 minMatchCharLength: 0 limit: 10 # # 最大返回搜索结果数 keys: [\u0026#34;title\u0026#34;, \u0026#34;permalink\u0026#34;, \u0026#34;summary\u0026#34;, \u0026#34;content\u0026#34;] # 参与搜索的字段 menu: # 定义导航菜单 main: # Hugo 主题 PaperMod 默认的主菜单（可以有多个菜单） - identifier: categories # 菜单的唯一标识符，用于 Hugo 内部管理这个菜单项 name: categories # 分类菜单项的显示名称 url: /categories/ # 分类页面的 URL （/categories/ Hugo 的分类页面（taxonomy page）） weight: 10 # 菜单的权重（值越小越靠前） - identifier: tags name: tags # 标签菜单项 url: /tags/ # 标签页面的 URL weight: 20 - identifier: example name: example.org # 自定义菜单项 url: https://example.org # 自定义菜单的链接 weight: 30 # 自定义菜单的权重 - identifier: archive name: Archive url: archives weight: 5 - identifier: search name: Search url: search/ weight: 10 4. 添加网页内容 在路径 A/demo 下，执行以下指令\n1 hugo new content posts/hello.md 执行完上面指令后，hugo 会生成网页，保存路径为 A/demo/content/posts/hello.md。打开该文档，会看到以下内容\n1 2 3 4 5 +++ date = \u0026#39;2025-02-11T07:14:09+08:00\u0026#39; draft = false title = \u0026#39;My First Post\u0026#39; +++ 5. Hugo本地部署 如果 draft = true，执行以下指令（以下两个指令是一样的，只执行一个即可）\n1 2 hugo server -D hugo server --buildDrafts 如果 draft = false，\n1 hugo server 最后，可以在浏览器输入地址 http://localhost:1313/，即看到网页内容\n6. Hugo 部署到 Github Pages 🚀 6.1 新建 Github 仓库 step 1. 新建 Github 仓库，仓库名必须为 username.github.io，username 为 Github 用户名。\nstep 2. 将本地仓库推到 Github 仓库\n切换路径至 A/demo，执行以下指令\n1 2 3 4 5 git remote add origin \u0026#34;Github 仓库 SSH 地址\u0026#34; # 不需要井号 git add . git commit -m \u0026#34;First Submit\u0026#34; git branch -M main git push -u origin main 刷新 Github 仓库，会看到git仓库已上传。\nstep 3. 这时 username.github.io 还是不能访问，接下来进行部署\nstep 3.1 建立部署配置文件\n回到本地仓库根目录，建立文件夹 .github/workflows，在该文件夹下新建文件 hugo.yaml （hugo.yaml的内容参考 这个博客 或者 官方教程），hugo.yaml的具体内容如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 # Sample workflow for building and deploying a Hugo site to GitHub Pages name: Deploy Hugo site to Pages on: # Runs on pushes targeting the default branch push: branches: - main # Allows you to run this workflow manually from the Actions tab workflow_dispatch: # Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages permissions: contents: read pages: write id-token: write # Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued. # However, do NOT cancel in-progress runs as we want to allow these production deployments to complete. concurrency: group: \u0026#34;pages\u0026#34; cancel-in-progress: false # Default to bash defaults: run: shell: bash jobs: # Build job build: runs-on: ubuntu-latest env: HUGO_VERSION: 0.141.0 steps: - name: Install Hugo CLI run: | wget -O ${{ runner.temp }}/hugo.deb https://github.com/gohugoio/hugo/releases/download/v${HUGO_VERSION}/hugo_extended_${HUGO_VERSION}_linux-amd64.deb \\ \u0026amp;\u0026amp; sudo dpkg -i ${{ runner.temp }}/hugo.deb - name: Install Dart Sass run: sudo snap install dart-sass - name: Checkout uses: actions/checkout@v4 with: submodules: recursive fetch-depth: 0 - name: Setup Pages id: pages uses: actions/configure-pages@v5 - name: Install Node.js dependencies run: \u0026#34;[[ -f package-lock.json || -f npm-shrinkwrap.json ]] \u0026amp;\u0026amp; npm ci || true\u0026#34; - name: Build with Hugo env: HUGO_CACHEDIR: ${{ runner.temp }}/hugo_cache HUGO_ENVIRONMENT: production TZ: America/Los_Angeles run: | hugo \\ --gc \\ --minify \\ --baseURL \u0026#34;${{ steps.pages.outputs.base_url }}/\u0026#34; - name: Upload artifact uses: actions/upload-pages-artifact@v3 with: path: ./public # Deployment job deploy: environment: name: github-pages url: ${{ steps.deployment.outputs.page_url }} runs-on: ubuntu-latest needs: build steps: - name: Deploy to GitHub Pages id: deployment uses: actions/deploy-pages@v4 step 3.2 选择 GitHub 部署方式\nGithub项目页面 -\u0026gt; Settings -\u0026gt; Pages -\u0026gt; Build and deployment -\u0026gt; Source -\u0026gt; 改为 GitHub Actions\nstep 3.3 查看 GitHub 部署结果\nGithub项目页面 -\u0026gt; Action 页面会看到 GitHub 的部署情况。 部署正确后即可看到 username.giuhub.io 页面。\n注意，根目录 A/demo 下的网站配置文件（不是 .github/workflows 目录下的部署配置文件） hugo.yaml 的设置必须如下，否则报错\n1 baseURL: https://username.github.io/ ","permalink":"http://localhost:1313/posts/hugo/2025-02-11-hugo/","summary":"Learn About Hugo \u0026amp; GitHub Pages","title":"Hugo 系列 - 1. 搭建 Hugo 网站并部署到 Github Pages"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates (extend_head.html) like so: refer ISSUE #236 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTex globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTex on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Block math:\n$$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\n","permalink":"http://localhost:1313/posts/papermod/math-typesetting/","summary":"\u003cp\u003eMathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\u003c/p\u003e","title":"Math Typesetting"},{"content":"","permalink":"http://localhost:1313/publications/","summary":"publications","title":"Publications"}]