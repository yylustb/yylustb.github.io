[{"content":"在 LaTeX 生态中，latex、pdflatex、xelatex 和 lualatex 是不同的编译引擎，各自有不同的特点和适用场景。\n1. latex 最古老的 LaTeX 编译器，输出的是 DVI 文件，不是 PDF 文件 需要使用 dvips 或 dvipdf 等工具将 DVI 文件转换为 PDF 文件（latex → DVI → PS → PDF）。 不支持直接插入 PNG、JPEG、PDF 等图片格式，只支持 EPS 格式。 不支持直接插入中文，需要使用 xeCJK 或 CJK 宏包。 2. pdflatex 直接生成 PDF 文件（不需要使用 dvips 或 dvipdf 等转换工具）。 支持直接插入 PNG、JPEG、PDF 等图片格式（但不支持 EPS 格式）。 不支持 Unicode，默认采用 8-bit 编码（如 latin1、utf8 需用 inputenc 宏包） 对中文支持较差，需要 CJK 宏包（或 ctex 宏包）。 适合英文和西方语言文档（默认 8-bit 编码） 如果一定要用 pdflatex 处理中文，需要 1 \\usepackage[CJKutf8]{CJK} 3. xelatex 直接生成 PDF 文件（不需要使用 dvips 或 dvipdf 等转换工具）。 支持 Unicode，默认采用 UTF-8 编码，适用于多语言文档（包括中文） 支持 OpenType/TrueType（OTF/TTF）字体，可以直接使用系统字体（如宋体、楷体、黑体、SimSun、SimHei 等） 支持 fontspec 宏包，使字体管理更灵活。 支持直接插入 PNG、JPEG、PDF 等图片格式（但不支持 EPS 格式）。 CTeX 默认推荐 xelatex 4. lualatex（推荐用于高级应用，如 Lua 代码交互） 支持 Unicode 和 OpenType 字体。 支持 fontspec 宏包（字体管理）。 支持 luacode 宏包，可以在 LaTeX 代码中直接写 Lua 代码，例如： 1 2 3 4 \\usepackage{luacode} \\begin{luacode} tex.print(\u0026#34;你好，LuaLaTeX！\u0026#34;) \\end{luacode} 5. 总结 编译器 是否支持 Unicode 直接输出 PDF 适用于中文 图片支持 推荐用途 latex ❌ 否 ❌ 需转换 ❌ 需 CJK 仅支持 EPS 过时，基本不用 pdflatex ❌ 否 ✅ 是 ⚠️ 需 CJK PNG、JPEG、PDF 适用于英文或简单中文 xelatex ✅ 是 ✅ 是 ✅ 推荐 PNG、JPEG、PDF 推荐中文文档、支持系统字体 lualatex ✅ 是 ✅ 是 ✅ 推荐 PNG、JPEG、PDF 高级排版、动态 Lua 代码 小贴士 Unicode 是字符集，定义了世界上所有语言的字符例如\nA → U+0041 你 → U+4F60 😊 → U+1F60A 但Unicode 只规定了字符编号（码点），并没有规定如何存储这些字符。\n计算机只能存储 二进制数据（0 和 1），所以我们需要 字符编码（Character Encoding）把 Unicode 转换成二进制。\nUTF-8 是 Unicode 的一种编码方式，是一种 可变长度的 Unicode 编码\n1 个字节（8-bit） 表示 ASCII 字符（兼容英语）。 2~4 个字节 表示其他 Unicode 字符（如中文、Emoji）。 A → U+0041 → 0x41（1 字节） 你 → U+4F60 → 0xE4BDA0（3 字节） 😊 → U+1F60A → 0xF09F988A（4 字节） 8-bit 编码 主要指 每个字符占 1 个字节（8 位） 的旧式编码，常见的包括\nASCII：标准 ASCII 只使用 7-bit（128 个字符），由于 7-bit 只能表示 128 个字符，后来扩展到 8-bit（256 个字符） ISO-8859-1：用于西欧语言，支持法语、德语、西班牙语等， 但不支持中文 GB2312 (6,763个汉字) / GBK(21,003个汉字) / GB18030（Unicode所有汉字） ","permalink":"http://localhost:1313/posts/latex/2025-02-24-latex/","summary":"Read aboout Install and Update instructions and sampled configuration templates","title":"LaTex系列1. LaTex编译器"},{"content":"asd texstudio 中如下配置\nTools -\u0026gt; User -\u0026gt; Git command 等价于在命令行当前目录下执行 Git command\n","permalink":"http://localhost:1313/posts/git/2025-02-23-git-texstudio/","summary":"Learn About All Features in PaperMod","title":"Git 系列 - 3. Texstudio 同步 Git"},{"content":"1. 安装git 2. 利用 git 配置 github 账户 2.1 配置 Git 用户信息 1 2 git config --global user.name \u0026#34;GitHub用户名\u0026#34; # 不需要引号 git config --global user.email \u0026#34;GitHub邮箱\u0026#34; # 不需要引号 2.2 设置 SSH Key 生成 SSH Key\n1 ssh-keygen -t rsa -b 4096 -C \u0026#34;GitHub邮箱\u0026#34; # 不需要引号 -t rsa：使用 RSA 加密算法 -b 4096：密钥长度为 4096 位（更安全） -C \u0026quot;GitHub邮箱\u0026quot;：标识 SSH Key，方便管理 接下来 terminal 提示：\n1 Enter file in which to save the key (/home/user/.ssh/id_rsa): 直接按回车即可（使用默认路径 ~/.ssh/id_rsa）\n接下来 terminal 提示输入密码：\n1 2 Enter passphrase (empty for no passphrase): Enter same passphrase again: 两次回车即可（默认不输入密码），否则每次推送 Git 都需要输入密码\n生成的 SSH密钥 存放在 ~/.ssh/id_rsa.pub\n2.3 将 SSH密钥 添加到 GitHub 账户的 SSH Keys 中 复制 SSH Key 1 cat ~/.ssh/id_rsa.pub 添加到 GitHub 登录 GitHub 账户 点击右上头像 -\u0026gt; Settings（设置） 左侧选择 SSH and GPG keys（SSH 和 GPG 密钥） 点击 New SSH key（新建 SSH 密钥） Title: 可以自定义 Key: 粘贴复制的 SSH Key 点击 Add SSH key 2.3 测试 SSH 连接 1 ssh -T git@github.com 如果配置成功，会显示：\n1 Hi \u0026lt;GitHub用户名\u0026gt;! You\u0026#39;ve successfully authenticated, but GitHub does not provide shell access. 3. 将本地 Git 仓库与 GitHub 仓库首次关联 步骤 1：准备本地仓库\n步骤 2：在本地 Git 仓库中执行 Git 操作\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 2.1 切换到仓库根目录 cd \u0026#34;本地仓库路径\u0026#34; # 2.2 初始化 Git 仓库 git init # 2.3 添加所有文件到暂存区 git add . # 2.4 提交文件 git commit -m \u0026#34;Initial commit\u0026#34; # 2.5 告诉 Git，本地仓库的 origin 远程地址是 GitHub 仓库的 SSH 地址 git remote add origin git@github.com:你的GitHub用户名/你的仓库名.git # 2.6 强制重命名当前分支为 main git branch -M main # 2.7 第一次推送：将本地的 main 分支推送到 GitHub git push -u origin main 注意事项1：Git 仓库默认的主分支是 master，但 GitHub 仓库采用 main 作为默认分支，所以用此命令改为 main。 注意事项2：第一次推送时，需要使用 git push -u origin main 。以后推送/拉去只需使用： 1 2 git push git pull 步骤 3：检查 GitHub 仓库 打开 GitHub 主页 (https://github.com/GitHub用户名), 会看到一个新创建的仓库，且代码已经上传.\n","permalink":"http://localhost:1313/posts/git/2025-02-23-git-install/","summary":"Read aboout Install and Update instructions and sampled configuration templates","title":"Git 系列1. 安装 Git 链接 Github"},{"content":"1.安装必要软件 一行代码搭建机器人开发环境(ROS/ROS2/ROSDEP)\n1 wget http://fishros.com/install -O fishros \u0026amp;\u0026amp; . fishros 选项：\n[1] 安装 noetic(ros1) [3] 安装 rosdep ","permalink":"http://localhost:1313/posts/git/2025-02-23-git-matlab/","summary":"Read aboout Install and Update instructions and sampled configuration templates","title":"Git 系列2. Matlab同步Git"},{"content":"1. Ubuntu 目录结构 1.1 用户主目录 ~ = /home/username/ 在 ubuntu 系统中，波浪线 ~ 在命令行环境下是 “用户主目录”（Home Directory）的缩写或别名。\n例如 ~/.bashrc:\n~ 代表的就是当前用户的主目录（/home/username/） ~/.bashrc 实际上就是 /home/username/.bashrc 2. shell 和 terminal 2.1 Shell 是什么 Shell 是一种软件层，用来接收用户输入的命令，然后将这些命令传递给操作系统内核去执行。也可以理解为人与操作系统之间的“翻译”或“交互接口”。\n2.2 Shell 的种类 bash Shell: Ubuntu 默认的 Shell zsh Shell fish Shell csh/tcsh Shell 每种 Shell 都有自己的语法特性、配置文件和内置工具，但它们的基本功能相似：运行命令、编写脚本、管理进程和环境变量等。\n2.3 常用的 Shell 配置文件 ~/.bashrc: bash Shell 的配置文件 ~/.zshrc: zsh Shell 的配置文件 ~/.config/fish/config.fish: fish Shell 的配置文件 2.4 Shell 的工作流程 读取用户输入的命令 解释和解析命令，交给操作系统 显示执行结果 2.5 常用的 Shell 命令 echo: 打印文本或变量的值 cd: 改变当前目录 ls: 列出当前目录中的文件和文件夹 2.6 常用的 Shell 快捷键 Ctrl + L: 清屏 Ctrl + C: 中断当前命令 Ctrl + D: 退出当前 Shell 2.7 什么是 terminal \u0026ldquo;终端\u0026rdquo; 指的是实际的硬件设备（如显示器/键盘），通过串口或其他方式连到主机。 Ubuntu 的 terminal 是一个 \u0026ldquo;终端\u0026rdquo; 的软件模拟器 2.8 terminal 和 shell 的关系 terminal: 是一个 “文本交互界面”, 提供了一个文本窗口，允许用户在其中输入命令、接收输出 shell: 是一个命令行解释器，它接收用户在 terminal 内输入的命令，并将其传递给操作系统内核去执行。 Terminal：相当于“聊天窗口” Shell：相当于“对话的另一端的人”（或自动回复程序） 2.9 例子 在 Ubuntu 的 terminal 里输入一条命令： 1 ls -l Terminal 会把这条文本交给正在运行的 Shell（一般是 Bash） Bash 解析这条命令，调用相应的系统调用或程序来列出目录下的文件和文件夹 然后 Bash 把执行结果返回给 Terminal，Terminal 再把结果显示给用户 3. 配置脚本文件 ~/.bashrc 3.1 terminal/shell 启动流程 在 Ubuntu 系统中，点开 terminal 图标，新开一个 terminal 窗口时，会发生以下事情：\n启动一个终端模拟器 terminal，它会创建一个非登录、交互式的 Bash Shell。 Bash Shell 尝试查找并读取 /etc/bash.bashrc（系统全局的 bashrc，可选） Bash Shell 尝试查找并读取当前用户的 ~/.bashrc（用户自定义的 bashrc） Bash Shell 环境初始化完成，用户在就可以正常使用终端了。 3.2 ~/.bashrc 的功能 初始化 Shell\n定义/修改 PATH 等环境变量\n1 2 export PATH=\u0026#34;$HOME/bin:$PATH\u0026#34; export EDITOR=vim 为常用命令设置别名（alias），简化输入，例如\n1 2 alias ll=\u0026#39;ls -l\u0026#39; alias gs=\u0026#39;git status\u0026#39; 让 ~/.bashrc 的修改立即生效（以下两个指令等价）：\n1 2 source ~/.bashrc . ~/.bashrc 配置命令提示符（PS1）：命令行中看到的提示符样式，就是由 PS1 的配置决定的\n1 PS1=\u0026#34;\\u@\\h:\\w\\$ \u0026#34; PS1: Bash 中用于定义主提示符（Primary Prompt）的变量 \\u：当前用户名（user name） \\h：当前主机名（host name）中的前半部分（不含域名） \\w：当前工作目录（working directory），会以相对路径显示，如果是 home 目录则显示 ~ \\$：如果是普通用户则显示 $，如果是 root 用户（即超级用户）则显示 # 最后的空格: 是为了让命令提示符后留出一个空格，便于输入命令 2.3 不同类型的 Shell 的 Bash 启动流程 登录Shell（Login Shell） 通过 SSH 登录远程主机，或者在系统中输入 用户名/密码 直接登录时，启动的 Shell 就是 登录Shell 这种情况下，Bash Shell 会先读取并执行 /etc/profile，然后依次读取 ~/.bash_profile, ~/.bash_login, ~/.profile（谁先被找到就执行哪个，通常系统会默认用 ~/.bash_profile 或 ~/.profile） 非登录Shell（Non-login Shell） 在图形界面下打开一个 Terminal: 通常是通过 Ctrl + Alt + T 快捷键打开的终端，或者通过 gnome-terminal 命令打开的终端 这种情况下，Bash Shell 只会读取并执行 ~/.bashrc 交互式（Interactive）与非交互式（Non-interactive） 交互式 Shell：用户与 Shell 之间的交互，例如通过 Ctrl + Alt + T 快捷键打开的终端，用户可以通过键盘输入命令 非交互式 Shell：Shell 不与用户交互，例如通过脚本执行命令（脚本首行需要写 #!/usr/bin/env bash） 总结：~/.bashrc 默认只在“非登录式且交互式”的 Bash Shell 启动时被读取执行\n","permalink":"http://localhost:1313/posts/ubuntu/2025-02-23-ubuntu-shell/","summary":"Read aboout Install and Update instructions and sampled configuration templates","title":"Ubuntu系列2. bash shell, terminal 和 ~/.bashrc"},{"content":"In this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates (extend_head.html) like so: refer ISSUE #236 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTex globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTex on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Block math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\n","permalink":"http://localhost:1313/posts/reinforcement_learning/2025-02-20-rl-pg/","summary":"Python argparse","title":"强化学习系列2. Policy Gradient"},{"content":"AppImage 是一种便携式软件包格式，允许你在 Linux 上运行应用程序 无需安装。以下是下载、运行和管理 AppImage 文件的方法\n1. 下载 AppImage 文件 2. 赋予 AppImage 文件可执行权限 AppImage 文件运行需要赋予权限，以下是赋予权限的两种方式。\n方法1：使用终端 1 2 chmod +x ~/Downloads/your_app.AppImage ./your_app.AppImage 方法2：使用图形界面 右键点击 AppImage 文件，选择 \u0026ldquo;属性\u0026rdquo;（Properties）。 切换到 \u0026ldquo;权限\u0026rdquo;（Permissions） 选项卡。 勾选 \u0026ldquo;允许作为可执行文件\u0026rdquo;（Allow executing file as a program）。 双击 AppImage 运行程序。 3. 使用 AppImageLauncher 管理 AppImage AppImage 默认不会自动出现在应用菜单中。\nAppImageLauncher 可以自动管理 AppImage 并集成到系统菜单中\n1 2 3 sudo add-apt-repository ppa:appimagelauncher-team/stable sudo apt update sudo apt install appimagelauncher 4. 将 AppImage 移动到 /opt 并创建全局快捷方式 如果你希望让 AppImage 可在整个系统中使用\n1 2 3 sudo mv ~/Downloads/your_app.AppImage /opt/your_app.AppImage sudo chmod +x /opt/your_app.AppImage sudo ln -s /opt/your_app.AppImage /usr/local/bin/your_app 5. 更新 AppImage 部分 AppImage 支持自动更新，例如：\n1 ./your_app.AppImage --update 如果 AppImage 不支持更新，你需要手动下载新版并替换旧版。\n6. 删除 AppImage 由于 AppImage 是一个独立的可执行文件，删除它就等于卸载：\n1 rm ~/Downloads/your_app.AppImage 如果你用 AppImageLauncher 集成了 AppImage，可以在 /Applications 目录中找到它，并右键选择 \u0026ldquo;删除\u0026rdquo;。\n6.Hugo 部署到 Github Pages 🚀 ","permalink":"http://localhost:1313/posts/ubuntu/2025-02-17-ubuntu-appimage/","summary":"Read aboout Install and Update instructions and sampled configuration templates","title":"Ubuntu系列1. 安装AppImage应用"},{"content":"1.DQN 算法流程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 # 0. 初始化 # 0.1 初始化环境 env env = # 0.2 初始化 DQN q(s, a; θ) = q_(s, a; θ_) = # 0.3 初始化经验回放库 Buffer replay_buffer = # 主循环：N 个 episode for episode = 1 to M: # 1. 初始化 s_t = env.reset() # 初始化状态 s_t episode_return = 0 # 初始化累计回报 episode_return # 每个 episode done = False while not done: # 2. 以 ε-贪婪策略生成动作 a_t a_t = argmax_a Q(s_t, a; θ) or random # 3. 执行动作 a_t，得到奖励 r_t、新状态 s_{t+1}、以及游戏结束标志 done s_{t+1}, r_t, done, _ = env.step(a_t) # 4. 存储一次交互数据 (s_t, a_t, r_t, φ_{t+1}, done) 至经验回放库 replay_buffer replay_buffer.append( (s_t, a_t, r_t, s_{t+1}, done) ) # 5. 当 replay_buffer 数据量满足最小长度 (比如500)，从 replay_buffer 中随机抽取一批数据 batch \u0026lt;- {s_j, a_j, r_j, s_{j+1}, done_j}, j = 1, ..., minimal_size（ batch 数据量为 minimal_size ） if len(Buffer) \u0026gt; 500: batch \u0026lt;- replay_buffer( 1, ..., minimal_size ) # 6. 利用采样数据 batch 训练 DQN DQN.train(batch) # 7. 更新状态 s_t \u0026lt;- s_{t+1} s_t = s_{t+1} # 8. 更新累计回报 episode_return += reward # 更新累计回报 if done: break ","permalink":"http://localhost:1313/posts/reinforcement_learning/2025-02-16-rl-dqn/","summary":"Python argparse","title":"强化学习系1. DQN"},{"content":"1. PyTorch 中使用 TensorBoard 通过 SummaryWriter 记录数据\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 import torch import torch.nn as nn import torch.optim as optim from torch.utils.tensorboard import SummaryWriter import numpy as np # 初始化 TensorBoard 记录器 writer = SummaryWriter(log_dir=\u0026#34;runs/experiment_1\u0026#34;) # 创建一个简单的模型 model = nn.Linear(1, 1) criterion = nn.MSELoss() optimizer = optim.SGD(model.parameters(), lr=0.01) # 训练循环 for epoch in range(100): x = torch.tensor([[epoch]], dtype=torch.float32) y = torch.tensor([[2 * epoch + 1]], dtype=torch.float32) output = model(x) loss = criterion(output, y) optimizer.zero_grad() loss.backward() optimizer.step() # 记录损失 writer.add_scalar(\u0026#34;Loss/train\u0026#34;, loss.item(), epoch) # 记录权重和梯度 for name, param in model.named_parameters(): writer.add_histogram(name, param, epoch) writer.add_histogram(f\u0026#34;{name}.grad\u0026#34;, param.grad, epoch) writer.close() 在终端启动 TensorBoard\n1 tensorboard --logdir=runs --port=6006 2. TensorFlow 中使用 TensorBoard 记录数据（不需要 SummaryWriter）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 import tensorflow as tf import datetime # 创建日志目录 log_dir = \u0026#34;logs/fit/\u0026#34; + datetime.datetime.now().strftime(\u0026#34;%Y%m%d-%H%M%S\u0026#34;) tensorboard_callback = tf.keras.callbacks.TensorBoard(log_dir=log_dir, histogram_freq=1) # 创建一个简单模型，指定 NN 结构 model = tf.keras.Sequential([ tf.keras.layers.Dense(128, activation=\u0026#39;relu\u0026#39;), tf.keras.layers.Dense(10) ]) # 指定NN训练方法为 adam, 损失函数为 SparseCategoricalCrossentropy model.compile(optimizer=\u0026#39;adam\u0026#39;, loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=True), metrics=[\u0026#39;accuracy\u0026#39;]) # 训练模型，并使用 TensorBoard 记录 model.fit( tf.random.normal([1000, 32]), tf.random.uniform([1000], maxval=10, dtype=tf.int32), epochs=5, callbacks=[tensorboard_callback] ) 在终端启动 TensorBoard\n1 tensorboard --logdir=logs/fit --port=6006 必选参数：\nhelp=\u0026quot;输入文件的路径\u0026quot;: 在 --help 命令中显示的参数说明 当执行脚本时，需要紧随其后提供必选参数 filename，否则会报错。例如（下面指令中的 input.txt 就是参数 \u0026ldquo;filename\u0026rdquo;） 1 python script.py input.txt 可选参数1：\n-v 和 --verbose: 代表同一个可选参数，用户可以使用任一形式。 action=\u0026quot;store_true\u0026quot;: 当这个选项被使用时，将在解析结果中把 verbose 设置为 True（不使用则为 False）。 help=\u0026quot;是否输出详细信息（布尔开关）\u0026quot;: help 中的内容会在 --help 命令中显示。 可选参数2：\ntype=int：将输入值转换为整数类型（如果传入值无法转换会报错）。 default=1：当用户没有提供该参数时，使用默认值 1。 定义完上面的代码文件后，在命令行的执行如下\n1 2 3 4 5 6 # 带所有参数 python script.py myfile.txt -v -n 3 # 或者：python script.py myfile.txt --verbose --number 3 # 不带可选参数 python script.py myfile.txt 3. 分析 为什么一个是 --logdir=runs 另一个是 --logdir=logs\nPyTorch 示例中，日志记录路径是 \u0026quot;runs/experiment_1\u0026quot;， runs/ 是 SummaryWriter(log_dir=\u0026quot;runs/experiment_1\u0026quot;) 指定的路径的父目录 TensorFlow 示例 中，日志记录路径是 \u0026quot;logs/fit/...\u0026quot;，logs/fit/ 是 log_dir 变量中的路径前缀 PyTorch 通常默认使用 \u0026quot;runs/\u0026quot; 作为日志目录，SummaryWriter 就是这么做的。 TensorFlow 示例中，通常使用 \u0026quot;logs/fit/\u0026quot; + datetime 作为日志目录，所以 TensorBoard 需要从 \u0026quot;logs/fit\u0026quot; 读取数据。 ","permalink":"http://localhost:1313/posts/python/2025-02-15-python-tensorboard/","summary":"Python tensorboard","title":"Python系列2. tensorboard"},{"content":"1.安装必要软件 一行代码搭建机器人开发环境(ROS/ROS2/ROSDEP)\n1 wget http://fishros.com/install -O fishros \u0026amp;\u0026amp; . fishros 选项：\n[1] 安装 noetic(ros1) [3] 安装 rosdep ","permalink":"http://localhost:1313/posts/ros/2025-02-14-ros-install/","summary":"Read aboout Install and Update instructions and sampled configuration templates","title":"ROS1系列1. 一键安装 ROS Neotic"},{"content":"1.什么是 argparse argparse 是一个强大的命令行参数解析工具，用于构建命令行脚本或程序时，可以非常方便地对传入的参数进行解释和处理。\n在编写命令行工具或脚本时，往往需要接收来自命令行的参数或选项，以实现配置。\nargparse 则能让你以更高层次、更结构化的方式来定义程序期望的参数形式，以及如何处理这些参数，从而自动生成帮助信息、错误信息等。\n2.基本用法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 import argparse def main(): \u0026#39;\u0026#39;\u0026#39;第一步：创建一个解析器对象，可以给出程序的简单描述\u0026#39;\u0026#39;\u0026#39; parser = argparse.ArgumentParser(description=\u0026#34;这是一个示例命令行工具\u0026#34;) \u0026#39;\u0026#39;\u0026#39;第二步：添加命令行参数和选项\u0026#39;\u0026#39;\u0026#39; # 添加必选参数: 在命令中不需要特意写 -x 或者 --xx ，是脚本必须要获取的数据。 parser.add_argument(\u0026#34;filename\u0026#34;, help=\u0026#34;输入文件的路径\u0026#34;) # 添加可选参数1：一般以短选项（如 -v）或长选项（如 --verbose）的形式出现。 parser.add_argument(\u0026#34;-v\u0026#34;, \u0026#34;--verbose\u0026#34;, action=\u0026#34;store_true\u0026#34;, help=\u0026#34;是否输出详细信息（布尔开关）\u0026#34; ) # 添加可选参数2：一般以短选项（如 -v）或长选项（如 --verbose）的形式出现。 parser.add_argument(\u0026#34;-n\u0026#34;, \u0026#34;--number\u0026#34;, type=int, default=1, help=\u0026#34;重复操作次数，默认为 1\u0026#34; ) # 添加可选参数3：接收某个范围或集合中的值 parser.add_argument(\u0026#34;--mode\u0026#34;, choices=[\u0026#34;train\u0026#34;, \u0026#34;test\u0026#34;, \u0026#34;eval\u0026#34;], help=\u0026#34;模式选择\u0026#34; ) # 添加可选参数4：指定参数的别名 parser.add_argument(\u0026#34;-m\u0026#34;, \u0026#34;--mode\u0026#34;, choices=[\u0026#34;train\u0026#34;, \u0026#34;test\u0026#34;, \u0026#34;eval\u0026#34;] ) \u0026#39;\u0026#39;\u0026#39;第三步：解析命令行参数\u0026#39;\u0026#39;\u0026#39; # args 就是一个包含解析后参数的命名空间对象, 属性名即为参数名。 args = parser.parse_args() # 通过 args.filename 访问参数 filename print(\u0026#34;文件名：\u0026#34;, args.filename) print(\u0026#34;是否详细输出：\u0026#34;, args.verbose) print(\u0026#34;操作次数：\u0026#34;, args.number) if __name__ == \u0026#34;__main__\u0026#34;: main() 必选参数：\nhelp=\u0026quot;输入文件的路径\u0026quot;: 在 --help 命令中显示的参数说明 当执行脚本时，需要紧随其后提供必选参数 filename，否则会报错。例如（下面指令中的 input.txt 就是参数 \u0026ldquo;filename\u0026rdquo;） 1 python script.py input.txt 可选参数1：\n-v 和 --verbose: 代表同一个可选参数，用户可以使用任一形式。 action=\u0026quot;store_true\u0026quot;: 当这个选项被使用时，将在解析结果中把 verbose 设置为 True（不使用则为 False）。 help=\u0026quot;是否输出详细信息（布尔开关）\u0026quot;: help 中的内容会在 --help 命令中显示。 可选参数2：\ntype=int：将输入值转换为整数类型（如果传入值无法转换会报错）。 default=1：当用户没有提供该参数时，使用默认值 1。 定义完上面的代码文件后，在命令行的执行如下\n1 2 3 4 5 6 # 带所有参数 python script.py myfile.txt -v -n 3 # 或者：python script.py myfile.txt --verbose --number 3 # 不带可选参数 python script.py myfile.txt ","permalink":"http://localhost:1313/posts/python/2025-02-13-python-argparse/","summary":"Python argparse","title":"Python系列1. argparse"},{"content":"1.安装必要软件 按照以下顺序安装软件（因为相互依赖关系）\nGit\nPowershell 7.x\nwin11自带Powershell是5.1，需要更新到7.x。 在win11自带Powershell里输入以下指令，安装最新稳定版\n1 winget install --id Microsoft.Powershell --source winget VS Code\nGo\ngo安装说明见官网 https://go.dev/doc/install\nGithub账户\nchoco\n参考官网 https://docs.chocolatey.org/en-us/choco/setup/ 安装choco，执行以下指令\n1 Set-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString(\u0026#39;https://community.chocolatey.org/install.ps1\u0026#39;)) Hugo\n执行以下指令，利用 choco 安装 hugo\n1 choco install hugo-extended Dart Sass\n执行以下指令，利用 choco 安装 Sass\n1 choco install sass 2.Hugo生成静态站点 Powershell 切换至文件夹 A，执行以下指令\n1 2 cd A hugo new site demo 执行完上面指令后，hugo 会生成网站，保存路径为 A/demo。\n注意：打开文件夹 A/demo，会发现hugo生成了很多文件，其中最重要的是配置文件 hugo.toml。 网站的配置文件，会略有区别。常见的配置文件有\nhugo.yaml / hugo.toml config.yaml / config.toml 切换路径至 A/demo，执行 git 初始化，为后续步骤做准备。\n1 git init 3.Hugo配置Theme 安装 Hugo 主题，参考官网 Hugo themes，接下来我们以 ananke 为例\n安装 Hugo 主题 Ananke，执行以下指令\n1 git submodule add https://github.com/theNewDynamic/gohugo-theme-ananke.git themes/ananke 主题 ananke 会存放在路径 A/demo/themes/ananke。 配置主题，执行以下指令\n1 echo \u0026#34;theme = \u0026#39;ananke\u0026#39;\u0026#34; \u0026gt;\u0026gt; hugo.toml 执行完上面指令后，网站配置文件最后一行会添加以下内容\n1 theme: [\u0026#34;PaperMod\u0026#34;] 4. 添加网页内容 在路径 A/demo 下，执行以下指令\n1 hugo new content posts/hello.md 执行完上面指令后，hugo 会生成网页，保存路径为 A/demo/content/posts/hello.md。打开该文档，会看到以下内容\n1 2 3 4 5 +++ date = \u0026#39;2025-02-11T07:14:09+08:00\u0026#39; draft = false title = \u0026#39;My First Post\u0026#39; +++ 5.Hugo本地部署 如果 draft = true，执行以下指令（以下两个指令是一样的，只执行一个即可）\n1 2 hugo server -D hugo server --buildDrafts 如果 draft = false，\n1 hugo server 最后，可以在浏览器输入地址 http://localhost:1313/，即看到网页内容\n6.Hugo 部署到 Github Pages 🚀 6.1 新建 Github 仓库 新建 Github 仓库，仓库名必须为 username.github.io，username 为 Github 用户名。\n将本地仓库推到 Github 仓库\n切换路径至 A/demo，执行以下指令\n1 2 3 git remote add origin \u0026#34;Github 仓库 SSH 地址\u0026#34; # 不需要井号 git branch -M main git push -u origin main 检查 Github 仓库，会看到网页内容。\n这时 username.github.io 还是不能访问，接下来进行部署\nGithub项目页面 -\u0026gt; Settings -\u0026gt; Pages -\u0026gt; Build and deployment -\u0026gt; Source -\u0026gt; 改为 GitHub Actions -\u0026gt; save\n回到本地仓库根目录，建立文件夹 .github/workflows，在该文件夹下新建文件 hugo.yaml，hugo.yaml的内容参考 这个博客 或者 官方教程\n","permalink":"http://localhost:1313/posts/hugo/2025-02-11-hugo/","summary":"Read aboout Install and Update instructions and sampled configuration templates","title":"Hugo:1. 搭建个人网页"},{"content":"","permalink":"http://localhost:1313/posts/hello/","summary":"","title":"Hello"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates (extend_head.html) like so: refer ISSUE #236 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTex globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTex on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Block math:\n$$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\n","permalink":"http://localhost:1313/posts/papermod/math-typesetting/","summary":"\u003cp\u003eMathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\u003c/p\u003e","title":"Math Typesetting"}]